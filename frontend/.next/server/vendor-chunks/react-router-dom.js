"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(rsc)/./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   unstable_useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-router */ \"(rsc)/./node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @remix-run/router */ \"(rsc)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.22.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n        // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n        // web extensions. Relevant Bugzilla tickets:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : 0;\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        }\n        // <button>/<input type=\"submit\"> may override attributes of <form>\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        // Build a FormData object populated from a form and submitter\n        formData = new FormData(form, target);\n        // If this browser doesn't support the `FormData(el, submitter)` format,\n        // then tack on the submitter value at the end.  This is a lightweight\n        // solution that is not 100% spec compliant.  For complete support in older\n        // browsers, consider using the `formdata-submitter-polyfill` package\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? name + \".\" : \"\";\n                formData.append(prefix + \"x\", \"0\");\n                formData.append(prefix + \"y\", \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + '<input type=\"submit|image\">');\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = undefined;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\nconst _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"unstable_viewTransition\",\n    \"children\"\n], _excluded3 = [\n    \"fetcherKey\",\n    \"navigate\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"relative\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n];\n// HEY YOU! DON'T TOUCH THIS VARIABLE!\n//\n// It is replaced with the proper version at build time via a babel plugin in\n// the rollup config.\n//\n// Export a global property onto the window for React Router detection by the\n// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\n// to detect and properly classify live websites as being built with React Router:\n// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\nconst REACT_ROUTER_VERSION = \"6\";\ntry {\n    window.__reactRouterVersion = REACT_ROUTER_VERSION;\n} catch (e) {\n// no-op\n}\nfunction createBrowserRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        // @ts-expect-error\n                        let error = new ErrorConstructor(val.message);\n                        // Wipe away the client-side stack trace.  Nothing to fill it in with\n                        // because we don't serialize SSR stack traces for security reasons\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {\n                    // no-op - fall through and create a normal Error\n                    }\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                // Wipe away the client-side stack trace.  Nothing to fill it in with\n                // because we don't serialize SSR stack traces for security reasons\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    isTransitioning: false\n});\nif (true) {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\nif (true) {\n    FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = react_dom__WEBPACK_IMPORTED_MODULE_1__[FLUSH_SYNC];\nconst USE_ID = \"useId\";\nconst useIdImpl = react__WEBPACK_IMPORTED_MODULE_0__[USE_ID];\nfunction startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n        startTransitionImpl(cb);\n    } else {\n        cb();\n    }\n}\nfunction flushSyncSafe(cb) {\n    if (flushSyncImpl) {\n        flushSyncImpl(cb);\n    } else {\n        cb();\n    }\n}\nclass Deferred {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\n    let { v7_startTransition } = future || {};\n    let optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cb)=>{\n        if (v7_startTransition) {\n            startTransitionSafe(cb);\n        } else {\n            cb();\n        }\n    }, [\n        v7_startTransition\n    ]);\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, _ref2)=>{\n        let { deletedFetchers, unstable_flushSync: flushSync, unstable_viewTransitionOpts: viewTransitionOpts } = _ref2;\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== undefined) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n        // If this isn't a view transition or it's not available in this browser,\n        // just update and be done with it\n        if (!viewTransitionOpts || isViewTransitionUnavailable) {\n            if (flushSync) {\n                flushSyncSafe(()=>setStateImpl(newState));\n            } else {\n                optInStartTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        // flushSync + startViewTransition\n        if (flushSync) {\n            // Flush through the context to mark DOM elements as transition=ing\n            flushSyncSafe(()=>{\n                // Cancel any pending transitions\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            // Update the DOM\n            let t = router.window.document.startViewTransition(()=>{\n                flushSyncSafe(()=>setStateImpl(newState));\n            });\n            // Clean up after the animation completes\n            t.finished.finally(()=>{\n                flushSyncSafe(()=>{\n                    setRenderDfd(undefined);\n                    setTransition(undefined);\n                    setPendingState(undefined);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            flushSyncSafe(()=>setTransition(t));\n            return;\n        }\n        // startTransition + startViewTransition\n        if (transition) {\n            // Interrupting an in-progress transition, cancel and let everything flush\n            // out, and then kick off a new transition from the interruption state\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            // Completed navigation update with opted-in view transitions, let 'er rip\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        transition,\n        renderDfd,\n        fetcherData,\n        optInStartTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition = router.window.document.startViewTransition(async ()=>{\n                optInStartTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition.finished.finally(()=>{\n                setRenderDfd(undefined);\n                setTransition(undefined);\n                setPendingState(undefined);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition);\n        }\n    }, [\n        optInStartTransition,\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(undefined);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n    let { routes, future, state } = _ref3;\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRoutesImpl)(routes, undefined, state, future);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref4) {\n    let { basename, children, future, window: window1 } = _ref4;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref5) {\n    let { basename, children, future, window: window1 } = _ref5;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref6) {\n    let { basename, children, future, history } = _ref6;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser =  false && 0;\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */ const Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\n    let { onClick, relative, reloadDocument, replace, state, target, to, preventScrollReset, unstable_viewTransition } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to;\n        // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break ' + \"when clicked - please update to a valid URL path.\") : 0;\n            }\n        }\n    }\n    // Rendered into <a href> for relative URLs\n    let href = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useHref)(to, {\n        relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n        replace,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */ const NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, unstable_viewTransition, children } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    let { navigator, basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && unstable_viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n        nextLocationPathname = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n    // we're looking for a slash _after_ what's in `to`.  For example:\n    //\n    // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n    // both want to look for a / at index 6 to match URL `/users/matt`\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to,\n        unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref9, forwardedRef)=>{\n    let { fetcherKey, navigate, reloadDocument, replace, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, unstable_viewTransition } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace,\n            state,\n            relative,\n            preventScrollReset,\n            unstable_viewTransition\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref10) {\n    let { getKey, storageKey } = _ref10;\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    let { target, replace: replaceProp, state, preventScrollReset, relative, unstable_viewTransition } = _temp === void 0 ? {} : _temp;\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n            navigate(to, {\n                replace,\n                state,\n                preventScrollReset,\n                relative,\n                unstable_viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nfunction validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n        throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = ()=>\"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    let { router } = useDataRouterContext(DataRouterHook.UseSubmit);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        validateClientSideSubmission();\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                unstable_flushSync: options.unstable_flushSync\n            });\n        } else {\n            router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                unstable_flushSync: options.unstable_flushSync,\n                unstable_viewTransition: options.unstable_viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(action ? action : \".\", {\n        relative\n    }));\n    // If no action was specified, browsers will persist current search params\n    // when determining the path, so match that behavior\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    if (action == null) {\n        // Safe to write to this directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        path.search = location.search;\n        // When grabbing search params from the URL, remove any included ?index param\n        // since it might not apply to our contextual route.  We add it back based\n        // on match.route.index below\n        let params = new URLSearchParams(path.search);\n        if (params.has(\"index\") && params.get(\"index\") === \"\") {\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher(_temp3) {\n    var _route$matches;\n    let { key } = _temp3 === void 0 ? {} : _temp3;\n    let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !fetcherData ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : 0 : void 0;\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    // Fetcher key handling\n    // OK to call conditionally to feature detect `useId`\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    let defaultKey = useIdImpl ? useIdImpl() : \"\";\n    let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    } else if (!fetcherKey) {\n        // We will only fall through here when `useId` is not available\n        setFetcherKey(getUniqueFetcherId());\n    }\n    // Registration/cleanup\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>{\n            // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n            // will not delete immediately but instead queue up a delete after the\n            // fetcher returns to an `idle` state\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    // Fetcher additions\n    let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((href, opts)=>{\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n        router.fetch(fetcherKey, routeId, href, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, opts)=>{\n        submitImpl(target, _extends({}, opts, {\n            navigate: false,\n            fetcherKey\n        }));\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\n                navigate: false,\n                fetcherKey: fetcherKey,\n                ref: ref\n            }));\n        });\n        if (true) {\n            FetcherForm.displayName = \"fetcher.Form\";\n        }\n        return FetcherForm;\n    }, [\n        fetcherKey\n    ]);\n    // Exposed FetcherWithComponents\n    let fetcher = state.fetchers.get(fetcherKey) || react_router__WEBPACK_IMPORTED_MODULE_2__.IDLE_FETCHER;\n    let data = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>_extends({\n            Form: FetcherForm,\n            submit,\n            load\n        }, fetcher, {\n            data\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return Array.from(state.fetchers.entries()).map((_ref11)=>{\n        let [key, fetcher] = _ref11;\n        return _extends({}, fetcher, {\n            key\n        });\n    });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp4) {\n    let { getKey, storageKey } = _temp4 === void 0 ? {} : _temp4;\n    let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches)();\n    let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation)();\n    // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    // Save positions on pagehide\n    usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n             true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : 0;\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ]));\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {\n            // no-op, use default empty object\n            }\n        }, [\n            storageKey\n        ]);\n        // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches)=>getKey(_extends({}, location, {\n                    pathname: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(location.pathname, basename) || location.pathname\n                }), matches) : getKey;\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKeyWithoutBasename);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            }\n            // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function usePageHide(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function usePrompt(_ref12) {\n    let { when, message } = _ref12;\n    let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker)(when);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                // This timeout is needed to avoid a weird \"race\" on POP navigations\n                // between the `window.history` revert navigation and the result of\n                // `window.confirm`\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */ function useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n    !(vtContext != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : 0 : void 0;\n    let { basename } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, nextPath) != null || (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, currentPath) != null;\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ087QUFDbVI7QUFDMGU7QUFDMWxCO0FBRXpNLFNBQVNnRTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBQ0EsU0FBU1EsOEJBQThCTixNQUFNLEVBQUVPLFFBQVE7SUFDckQsSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJSixTQUFTLENBQUM7SUFDZCxJQUFJWSxhQUFhZixPQUFPZ0IsSUFBSSxDQUFDVDtJQUM3QixJQUFJQyxLQUFLSjtJQUNULElBQUtBLElBQUksR0FBR0EsSUFBSVcsV0FBV1QsTUFBTSxFQUFFRixJQUFLO1FBQ3RDSSxNQUFNTyxVQUFVLENBQUNYLEVBQUU7UUFDbkIsSUFBSVUsU0FBU0csT0FBTyxDQUFDVCxRQUFRLEdBQUc7UUFDaENMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUND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S0FBSztJQUNoUyxJQUFJLEVBQ0ZzRSxRQUFRLEVBQ1QsR0FBR3lPLHFCQUFxQkosZUFBZXJDLHNCQUFzQjtJQUM5RCxJQUFJcEIsT0FBT3RTLDZEQUFlQSxDQUFDeVAsSUFBSTtRQUM3QitCLFVBQVV6SSxLQUFLeUksUUFBUTtJQUN6QjtJQUNBLElBQUksQ0FBQy9FLFVBQVU3QixlQUFlLEVBQUU7UUFDOUIsT0FBTztJQUNUO0lBQ0EsSUFBSThRLGNBQWM1WSwyREFBYUEsQ0FBQzJKLFVBQVU2QixlQUFlLENBQUNpRSxRQUFRLEVBQUU3SyxhQUFhK0UsVUFBVTZCLGVBQWUsQ0FBQ2lFLFFBQVE7SUFDbkgsSUFBSW9KLFdBQVc3WSwyREFBYUEsQ0FBQzJKLFVBQVU4QixZQUFZLENBQUNnRSxRQUFRLEVBQUU3SyxhQUFhK0UsVUFBVThCLFlBQVksQ0FBQ2dFLFFBQVE7SUFDMUcsc0VBQXNFO0lBQ3RFLHNFQUFzRTtJQUN0RSxtRUFBbUU7SUFDbkUsRUFBRTtJQUNGLHNEQUFzRDtJQUN0RCxFQUFFO0lBQ0YscURBQXFEO0lBQ3JELEVBQUU7SUFDRixpREFBaUQ7SUFDakQsRUFBRTtJQUNGLHdFQUF3RTtJQUN4RSx5RUFBeUU7SUFDekUsa0RBQWtEO0lBQ2xELE9BQU85USx1REFBU0EsQ0FBQzZRLEtBQUtDLFFBQVEsRUFBRW9KLGFBQWEsUUFBUWxhLHVEQUFTQSxDQUFDNlEsS0FBS0MsUUFBUSxFQUFFbUosZ0JBQWdCO0FBQ2hHO0FBQ0EsWUFBWTtBQUVraEIsQ0FDOWhCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JyZWV6ZS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcz8wM2E2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgUm91dGVyIERPTSB2Ni4yMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBSb3V0ZXIsIFVOU0FGRV91c2VSb3V0ZXNJbXBsLCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIHVzZUhyZWYsIHVzZVJlc29sdmVkUGF0aCwgdXNlTG9jYXRpb24sIHVzZU5hdmlnYXRlLCBjcmVhdGVQYXRoLCBVTlNBRkVfdXNlUm91dGVJZCwgVU5TQUZFX1JvdXRlQ29udGV4dCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGlvbiwgdXNlQmxvY2tlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQXdhaXQsIE1lbW9yeVJvdXRlciwgTmF2aWdhdGUsIE5hdmlnYXRpb25UeXBlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlcywgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LCBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBVTlNBRkVfUm91dGVDb250ZXh0LCBVTlNBRkVfdXNlUm91dGVJZCwgY3JlYXRlTWVtb3J5Um91dGVyLCBjcmVhdGVQYXRoLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cywgZGVmZXIsIGdlbmVyYXRlUGF0aCwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpzb24sIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlbmRlck1hdGNoZXMsIHJlc29sdmVQYXRoLCB1c2VBY3Rpb25EYXRhLCB1c2VBc3luY0Vycm9yLCB1c2VBc3luY1ZhbHVlLCB1c2VCbG9ja2VyLCB1c2VIcmVmLCB1c2VJblJvdXRlckNvbnRleHQsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGUsIHVzZU5hdmlnYXRpb24sIHVzZU5hdmlnYXRpb25UeXBlLCB1c2VPdXRsZXQsIHVzZU91dGxldENvbnRleHQsIHVzZVBhcmFtcywgdXNlUmVzb2x2ZWRQYXRoLCB1c2VSZXZhbGlkYXRvciwgdXNlUm91dGVFcnJvciwgdXNlUm91dGVMb2FkZXJEYXRhLCB1c2VSb3V0ZXMgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgc3RyaXBCYXNlbmFtZSwgVU5TQUZFX3dhcm5pbmcsIGNyZWF0ZVJvdXRlciwgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsIFVOU0FGRV9pbnZhcmlhbnQsIGpvaW5QYXRocywgSURMRV9GRVRDSEVSLCBtYXRjaFBhdGggfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG5jb25zdCBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG59XG5mdW5jdGlvbiBpc0Zvcm1FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xufVxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cbmZ1bmN0aW9uIHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkge1xuICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwICYmIChcbiAgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmXG4gIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gIDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGluaXRpYWxpemVyLlxuICpcbiAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGBuZXcgVVJMU2VhcmNoUGFyYW1zKGluaXQpYCBleGNlcHQgaXQgYWxzb1xuICogc3VwcG9ydHMgYXJyYXlzIGFzIHZhbHVlcyBpbiB0aGUgb2JqZWN0IGZvcm0gb2YgdGhlIGluaXRpYWxpemVyXG4gKiBpbnN0ZWFkIG9mIGp1c3Qgc3RyaW5ncy4gVGhpcyBpcyBjb252ZW5pZW50IHdoZW4geW91IG5lZWQgbXVsdGlwbGVcbiAqIHZhbHVlcyBmb3IgYSBnaXZlbiBrZXksIGJ1dCBkb24ndCB3YW50IHRvIHVzZSBhbiBhcnJheSBpbml0aWFsaXplci5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZjpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAqICAgICBbJ3NvcnQnLCAnbmFtZSddLFxuICogICAgIFsnc29ydCcsICdwcmljZSddXG4gKiAgIF0pO1xuICpcbiAqIHlvdSBjYW4gZG86XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHtcbiAqICAgICBzb3J0OiBbJ25hbWUnLCAncHJpY2UnXVxuICogICB9KTtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoaW5pdCkgfHwgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IGluaXQgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICByZXR1cm4gbWVtby5jb25jYXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXSk7XG4gIH0sIFtdKSk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcbiAgaWYgKGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgICAvLyBVc2UgYGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCguLi4pYCBoZXJlIGluc3RlYWQgb2YgaXRlcmF0aW5nIG9mXG4gICAgLy8gYGRlZmF1bHRTZWFyY2hQYXJhbXMua2V5cygpYCB0byB3b3JrLWFyb3VuZCBhIGJ1ZyBpbiBGaXJlZm94IHJlbGF0ZWQgdG9cbiAgICAvLyB3ZWIgZXh0ZW5zaW9ucy4gUmVsZXZhbnQgQnVnemlsbGEgdGlja2V0czpcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDE0NjAyXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyMzk4NFxuICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmdldEFsbChrZXkpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XG59XG4vLyBPbmUtdGltZSBjaGVjayBmb3Igc3VibWl0dGVyIHN1cHBvcnRcbmxldCBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IG51bGw7XG5mdW5jdGlvbiBpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkge1xuICBpZiAoX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZvcm1EYXRhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZiBGb3JtRGF0YSBzdXBwb3J0cyB0aGUgc3VibWl0dGVyIHBhcmFtZXRlciwgdGhpcyB3aWxsIHRocm93XG4gICAgICAwKTtcbiAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXI7XG59XG5jb25zdCBzdXBwb3J0ZWRGb3JtRW5jVHlwZXMgPSBuZXcgU2V0KFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdKTtcbmZ1bmN0aW9uIGdldEZvcm1FbmNUeXBlKGVuY1R5cGUpIHtcbiAgaWYgKGVuY1R5cGUgIT0gbnVsbCAmJiAhc3VwcG9ydGVkRm9ybUVuY1R5cGVzLmhhcyhlbmNUeXBlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIlxcXCJcIiArIGVuY1R5cGUgKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgYGVuY1R5cGVgIGZvciBgPEZvcm0+YC9gPGZldGNoZXIuRm9ybT5gIFwiICsgKFwiYW5kIHdpbGwgZGVmYXVsdCB0byBcXFwiXCIgKyBkZWZhdWx0RW5jVHlwZSArIFwiXFxcIlwiKSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVuY1R5cGU7XG59XG5mdW5jdGlvbiBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBiYXNlbmFtZSkge1xuICBsZXQgbWV0aG9kO1xuICBsZXQgYWN0aW9uO1xuICBsZXQgZW5jVHlwZTtcbiAgbGV0IGZvcm1EYXRhO1xuICBsZXQgYm9keTtcbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgLy8gcmUtcHJlZml4IGluIHRoZSByb3V0ZXJcbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSh0YXJnZXQpO1xuICB9IGVsc2UgaWYgKGlzQnV0dG9uRWxlbWVudCh0YXJnZXQpIHx8IGlzSW5wdXRFbGVtZW50KHRhcmdldCkgJiYgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcbiAgICBpZiAoZm9ybSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gb3IgPGlucHV0IHR5cGU9XFxcInN1Ym1pdFxcXCI+IHdpdGhvdXQgYSA8Zm9ybT5cIik7XG4gICAgfVxuICAgIC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxuICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgLy8gcmUtcHJlZml4IGluIHRoZSByb3V0ZXJcbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gZ2V0Rm9ybUVuY1R5cGUodGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpKSB8fCBnZXRGb3JtRW5jVHlwZShmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikpIHx8IGRlZmF1bHRFbmNUeXBlO1xuICAgIC8vIEJ1aWxkIGEgRm9ybURhdGEgb2JqZWN0IHBvcHVsYXRlZCBmcm9tIGEgZm9ybSBhbmQgc3VibWl0dGVyXG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSwgdGFyZ2V0KTtcbiAgICAvLyBJZiB0aGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBgRm9ybURhdGEoZWwsIHN1Ym1pdHRlcilgIGZvcm1hdCxcbiAgICAvLyB0aGVuIHRhY2sgb24gdGhlIHN1Ym1pdHRlciB2YWx1ZSBhdCB0aGUgZW5kLiAgVGhpcyBpcyBhIGxpZ2h0d2VpZ2h0XG4gICAgLy8gc29sdXRpb24gdGhhdCBpcyBub3QgMTAwJSBzcGVjIGNvbXBsaWFudC4gIEZvciBjb21wbGV0ZSBzdXBwb3J0IGluIG9sZGVyXG4gICAgLy8gYnJvd3NlcnMsIGNvbnNpZGVyIHVzaW5nIHRoZSBgZm9ybWRhdGEtc3VibWl0dGVyLXBvbHlmaWxsYCBwYWNrYWdlXG4gICAgaWYgKCFpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gdGFyZ2V0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBsZXQgcHJlZml4ID0gbmFtZSA/IG5hbWUgKyBcIi5cIiA6IFwiXCI7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChwcmVmaXggKyBcInhcIiwgXCIwXCIpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQocHJlZml4ICsgXCJ5XCIsIFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgXCIgKyBcIjxpbnB1dCB0eXBlPVxcXCJzdWJtaXR8aW1hZ2VcXFwiPlwiKTtcbiAgfSBlbHNlIHtcbiAgICBtZXRob2QgPSBkZWZhdWx0TWV0aG9kO1xuICAgIGFjdGlvbiA9IG51bGw7XG4gICAgZW5jVHlwZSA9IGRlZmF1bHRFbmNUeXBlO1xuICAgIGJvZHkgPSB0YXJnZXQ7XG4gIH1cbiAgLy8gU2VuZCBib2R5IGZvciA8Rm9ybSBlbmNUeXBlPVwidGV4dC9wbGFpblwiIHNvIHdlIGVuY29kZSBpdCBpbnRvIHRleHRcbiAgaWYgKGZvcm1EYXRhICYmIGVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgYm9keSA9IGZvcm1EYXRhO1xuICAgIGZvcm1EYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWN0aW9uLFxuICAgIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksXG4gICAgZW5jVHlwZSxcbiAgICBmb3JtRGF0YSxcbiAgICBib2R5XG4gIH07XG59XG5cbmNvbnN0IF9leGNsdWRlZCA9IFtcIm9uQ2xpY2tcIiwgXCJyZWxhdGl2ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwidGFyZ2V0XCIsIFwidG9cIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiwgXCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvblwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImFyaWEtY3VycmVudFwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJjbGFzc05hbWVcIiwgXCJlbmRcIiwgXCJzdHlsZVwiLCBcInRvXCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIiwgXCJjaGlsZHJlblwiXSxcbiAgX2V4Y2x1ZGVkMyA9IFtcImZldGNoZXJLZXlcIiwgXCJuYXZpZ2F0ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwibWV0aG9kXCIsIFwiYWN0aW9uXCIsIFwib25TdWJtaXRcIiwgXCJyZWxhdGl2ZVwiLCBcInByZXZlbnRTY3JvbGxSZXNldFwiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCJdO1xuLy8gSEVZIFlPVSEgRE9OJ1QgVE9VQ0ggVEhJUyBWQVJJQUJMRSFcbi8vXG4vLyBJdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBwcm9wZXIgdmVyc2lvbiBhdCBidWlsZCB0aW1lIHZpYSBhIGJhYmVsIHBsdWdpbiBpblxuLy8gdGhlIHJvbGx1cCBjb25maWcuXG4vL1xuLy8gRXhwb3J0IGEgZ2xvYmFsIHByb3BlcnR5IG9udG8gdGhlIHdpbmRvdyBmb3IgUmVhY3QgUm91dGVyIGRldGVjdGlvbiBieSB0aGVcbi8vIENvcmUgV2ViIFZpdGFscyBUZWNobm9sb2d5IFJlcG9ydC4gIFRoaXMgd2F5IHRoZXkgY2FuIGNvbmZpZ3VyZSB0aGUgYHdhcHBhbHl6ZXJgXG4vLyB0byBkZXRlY3QgYW5kIHByb3Blcmx5IGNsYXNzaWZ5IGxpdmUgd2Vic2l0ZXMgYXMgYmVpbmcgYnVpbHQgd2l0aCBSZWFjdCBSb3V0ZXI6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vSFRUUEFyY2hpdmUvd2FwcGFseXplci9ibG9iL21haW4vc3JjL3RlY2hub2xvZ2llcy9yLmpzb25cbmNvbnN0IFJFQUNUX1JPVVRFUl9WRVJTSU9OID0gXCI2XCI7XG50cnkge1xuICB3aW5kb3cuX19yZWFjdFJvdXRlclZlcnNpb24gPSBSRUFDVF9ST1VURVJfVkVSU0lPTjtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gbm8tb3Bcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVCcm93c2VySGlzdG9yeSh7XG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgdmFyIF93aW5kb3c7XG4gIGxldCBzdGF0ZSA9IChfd2luZG93ID0gd2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdy5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICAvLyBIZXkgeW91ISAgSWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UgY2hhbmdlIHRoZSBjb3JyZXNwb25kaW5nIGxvZ2ljIGluXG4gICAgLy8gc2VyaWFsaXplRXJyb3JzIGluIHJlYWN0LXJvdXRlci1kb20vc2VydmVyLnRzeCA6KVxuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCh2YWwuc3RhdHVzLCB2YWwuc3RhdHVzVGV4dCwgdmFsLmRhdGEsIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIHJlY29uc3RydWN0IHRoZSByaWdodCB0eXBlIG9mIEVycm9yIChpLmUuLCBSZWZlcmVuY2VFcnJvcilcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vLW9wIC0gZmFsbCB0aHJvdWdoIGFuZCBjcmVhdGUgYSBub3JtYWwgRXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuY29uc3QgVmlld1RyYW5zaXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgVmlld1RyYW5zaXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJWaWV3VHJhbnNpdGlvblwiO1xufVxuY29uc3QgRmV0Y2hlcnNDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobmV3IE1hcCgpKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIENvbXBvbmVudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAgV2VicGFjayArIFJlYWN0IDE3IGZhaWxzIHRvIGNvbXBpbGUgb24gYW55IG9mIHRoZSBmb2xsb3dpbmcgYmVjYXVzZSB3ZWJwYWNrXG4gIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdFtcInN0YXJ0VHJhbnNpdGlvblwiXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG4gICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIGluIFJlYWN0IDE4IHdoZXJlIG1pbmlmaWNhdGlvbi9vYmZ1c2NhdGlvbiBlbmRzIHVwIHJlbW92aW5nIHRoZSBjYWxsIG9mXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvMTA1NzlcbiovXG5jb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbmNvbnN0IHN0YXJ0VHJhbnNpdGlvbkltcGwgPSBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXTtcbmNvbnN0IEZMVVNIX1NZTkMgPSBcImZsdXNoU3luY1wiO1xuY29uc3QgZmx1c2hTeW5jSW1wbCA9IFJlYWN0RE9NW0ZMVVNIX1NZTkNdO1xuY29uc3QgVVNFX0lEID0gXCJ1c2VJZFwiO1xuY29uc3QgdXNlSWRJbXBsID0gUmVhY3RbVVNFX0lEXTtcbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpIHtcbiAgaWYgKHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICBzdGFydFRyYW5zaXRpb25JbXBsKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNTYWZlKGNiKSB7XG4gIGlmIChmbHVzaFN5bmNJbXBsKSB7XG4gICAgZmx1c2hTeW5jSW1wbChjYik7XG4gIH0gZWxzZSB7XG4gICAgY2IoKTtcbiAgfVxufVxuY2xhc3MgRGVmZXJyZWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZXNvbHZlZFwiO1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcbiAqL1xuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoX3JlZikge1xuICBsZXQge1xuICAgIGZhbGxiYWNrRWxlbWVudCxcbiAgICByb3V0ZXIsXG4gICAgZnV0dXJlXG4gIH0gPSBfcmVmO1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcbiAgbGV0IFtwZW5kaW5nU3RhdGUsIHNldFBlbmRpbmdTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBsZXQgW3Z0Q29udGV4dCwgc2V0VnRDb250ZXh0XSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gIH0pO1xuICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBbdHJhbnNpdGlvbiwgc2V0VHJhbnNpdGlvbl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBsZXQgW2ludGVycnVwdGlvbiwgc2V0SW50ZXJydXB0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0LnVzZVJlZihuZXcgTWFwKCkpO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgb3B0SW5TdGFydFRyYW5zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjayhjYiA9PiB7XG4gICAgaWYgKHY3X3N0YXJ0VHJhbnNpdGlvbikge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uU2FmZShjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9LCBbdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdTdGF0ZSwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgZGVsZXRlZEZldGNoZXJzLFxuICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IHZpZXdUcmFuc2l0aW9uT3B0c1xuICAgIH0gPSBfcmVmMjtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZm9yRWFjaChrZXkgPT4gZmV0Y2hlckRhdGEuY3VycmVudC5kZWxldGUoa2V5KSk7XG4gICAgbmV3U3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hlci5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZmV0Y2hlckRhdGEuY3VycmVudC5zZXQoa2V5LCBmZXRjaGVyLmRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBpc1ZpZXdUcmFuc2l0aW9uVW5hdmFpbGFibGUgPSByb3V0ZXIud2luZG93ID09IG51bGwgfHwgdHlwZW9mIHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbiAhPT0gXCJmdW5jdGlvblwiO1xuICAgIC8vIElmIHRoaXMgaXNuJ3QgYSB2aWV3IHRyYW5zaXRpb24gb3IgaXQncyBub3QgYXZhaWxhYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgICAvLyBqdXN0IHVwZGF0ZSBhbmQgYmUgZG9uZSB3aXRoIGl0XG4gICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlKSB7XG4gICAgICBpZiAoZmx1c2hTeW5jKSB7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRJblN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZmx1c2hTeW5jICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgIC8vIEZsdXNoIHRocm91Z2ggdGhlIGNvbnRleHQgdG8gbWFyayBET00gZWxlbWVudHMgYXMgdHJhbnNpdGlvbj1pbmdcbiAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4ge1xuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNpdGlvbnNcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZW5kZXJEZmQgJiYgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgICAgZmx1c2hTeW5jOiB0cnVlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgRE9NXG4gICAgICBsZXQgdCA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICB9KTtcbiAgICAgIC8vIENsZWFuIHVwIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgICB0LmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcbiAgICAgICAgICBzZXRSZW5kZXJEZmQodW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHN0YXJ0VHJhbnNpdGlvbiArIHN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgLy8gSW50ZXJydXB0aW5nIGFuIGluLXByb2dyZXNzIHRyYW5zaXRpb24sIGNhbmNlbCBhbmQgbGV0IGV2ZXJ5dGhpbmcgZmx1c2hcbiAgICAgIC8vIG91dCwgYW5kIHRoZW4ga2ljayBvZmYgYSBuZXcgdHJhbnNpdGlvbiBmcm9tIHRoZSBpbnRlcnJ1cHRpb24gc3RhdGVcbiAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgc2V0SW50ZXJydXB0aW9uKHtcbiAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbXBsZXRlZCBuYXZpZ2F0aW9uIHVwZGF0ZSB3aXRoIG9wdGVkLWluIHZpZXcgdHJhbnNpdGlvbnMsIGxldCAnZXIgcmlwXG4gICAgICBzZXRQZW5kaW5nU3RhdGUobmV3U3RhdGUpO1xuICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbcm91dGVyLndpbmRvdywgdHJhbnNpdGlvbiwgcmVuZGVyRGZkLCBmZXRjaGVyRGF0YSwgb3B0SW5TdGFydFRyYW5zaXRpb25dKTtcbiAgLy8gTmVlZCB0byB1c2UgYSBsYXlvdXQgZWZmZWN0IGhlcmUgc28gd2UgYXJlIHN1YnNjcmliZWQgZWFybHkgZW5vdWdoIHRvXG4gIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuICAvLyBXaGVuIHdlIHN0YXJ0IGEgdmlldyB0cmFuc2l0aW9uLCBjcmVhdGUgYSBEZWZlcnJlZCB3ZSBjYW4gdXNlIGZvciB0aGVcbiAgLy8gZXZlbnR1YWwgXCJjb21wbGV0ZWRcIiByZW5kZXJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiAhdnRDb250ZXh0LmZsdXNoU3luYykge1xuICAgICAgc2V0UmVuZGVyRGZkKG5ldyBEZWZlcnJlZCgpKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHRdKTtcbiAgLy8gT25jZSB0aGUgZGVmZXJyZWQgaXMgY3JlYXRlZCwga2ljayBvZmYgc3RhcnRWaWV3VHJhbnNpdGlvbigpIHRvIHVwZGF0ZSB0aGVcbiAgLy8gRE9NIGFuZCB0aGVuIHdhaXQgb24gdGhlIERlZmVycmVkIHRvIHJlc29sdmUgKGluZGljYXRpbmcgdGhlIERPTSB1cGRhdGUgaGFzXG4gIC8vIGhhcHBlbmVkKVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHJvdXRlci53aW5kb3cpIHtcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHBlbmRpbmdTdGF0ZTtcbiAgICAgIGxldCByZW5kZXJQcm9taXNlID0gcmVuZGVyRGZkLnByb21pc2U7XG4gICAgICBsZXQgdHJhbnNpdGlvbiA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIG9wdEluU3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICBhd2FpdCByZW5kZXJQcm9taXNlO1xuICAgICAgfSk7XG4gICAgICB0cmFuc2l0aW9uLmZpbmlzaGVkLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJEZmQodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgIH1cbiAgfSwgW29wdEluU3RhcnRUcmFuc2l0aW9uLCBwZW5kaW5nU3RhdGUsIHJlbmRlckRmZCwgcm91dGVyLndpbmRvd10pO1xuICAvLyBXaGVuIHRoZSBuZXcgbG9jYXRpb24gZmluYWxseSByZW5kZXJzIGFuZCBpcyBjb21taXR0ZWQgdG8gdGhlIERPTSwgdGhpc1xuICAvLyBlZmZlY3Qgd2lsbCBydW4gdG8gcmVzb2x2ZSB0aGUgdHJhbnNpdGlvblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xuICAgICAgcmVuZGVyRGZkLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcbiAgLy8gSWYgd2UgZ2V0IGludGVycnVwdGVkIHdpdGggYSBuZXcgbmF2aWdhdGlvbiBkdXJpbmcgYSB0cmFuc2l0aW9uLCB3ZSBza2lwXG4gIC8vIHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgbGV0IGl0IGNsZWFudXAsIHRoZW4ga2ljayBpdCBvZmYgYWdhaW4gaGVyZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiBpbnRlcnJ1cHRpb24pIHtcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShpbnRlcnJ1cHRpb24uc3RhdGUpO1xuICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGludGVycnVwdGlvbi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogaW50ZXJydXB0aW9uLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24odW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nLCBpbnRlcnJ1cHRpb25dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxsYmFja0VsZW1lbnQgPT0gbnVsbCB8fCAhcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uLCBcImA8Um91dGVyUHJvdmlkZXIgZmFsbGJhY2tFbGVtZW50PmAgaXMgZGVwcmVjYXRlZCB3aGVuIHVzaW5nIFwiICsgXCJgdjdfcGFydGlhbEh5ZHJhdGlvbmAsIHVzZSBhIGBIeWRyYXRlRmFsbGJhY2tgIGNvbXBvbmVudCBpbnN0ZWFkXCIpIDogdm9pZCAwO1xuICAgIC8vIE9ubHkgbG9nIHRoaXMgb25jZSBvbiBpbml0aWFsIG1vdW50XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIGxldCBuYXZpZ2F0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IG4gPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KSxcbiAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBmYWxzZSxcbiAgICBiYXNlbmFtZVxuICB9KSwgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV0pO1xuICAvLyBUaGUgZnJhZ21lbnQgYW5kIHtudWxsfSBoZXJlIGFyZSBpbXBvcnRhbnQhICBXZSBuZWVkIHRoZW0gdG8ga2VlcCBSZWFjdCAxOCdzXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAvLyB1c2VJZCByZWxpZXMgb24gdGhlIGNvbXBvbmVudCB0cmVlIHN0cnVjdHVyZSB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGlkJ3NcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdGF0ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGZXRjaGVyc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZmV0Y2hlckRhdGEuY3VycmVudFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWV3VHJhbnNpdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdnRDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IsXG4gICAgZnV0dXJlOiB7XG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogcm91dGVyLmZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgIH1cbiAgfSwgc3RhdGUuaW5pdGlhbGl6ZWQgfHwgcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pIDogZmFsbGJhY2tFbGVtZW50KSkpKSksIG51bGwpO1xufVxuZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMykge1xuICBsZXQge1xuICAgIHJvdXRlcyxcbiAgICBmdXR1cmUsXG4gICAgc3RhdGVcbiAgfSA9IF9yZWYzO1xuICByZXR1cm4gVU5TQUZFX3VzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlLCBmdXR1cmUpO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5mdW5jdGlvbiBCcm93c2VyUm91dGVyKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgZnV0dXJlLFxuICAgIHdpbmRvd1xuICB9ID0gX3JlZjQ7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgIGZ1dHVyZTogZnV0dXJlXG4gIH0pO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiBIYXNoUm91dGVyKF9yZWY1KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgZnV0dXJlLFxuICAgIHdpbmRvd1xuICB9ID0gX3JlZjU7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgIGZ1dHVyZTogZnV0dXJlXG4gIH0pO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcbiAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAqL1xuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcihfcmVmNikge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGZ1dHVyZSxcbiAgICBoaXN0b3J5XG4gIH0gPSBfcmVmNjtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXG4gICAgZnV0dXJlOiBmdXR1cmVcbiAgfSk7XG59XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIGA8YT5gLlxuICovXG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua1dpdGhSZWYoX3JlZjcsIHJlZikge1xuICBsZXQge1xuICAgICAgb25DbGljayxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgICByZXBsYWNlLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0byxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgfSA9IF9yZWY3LFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNywgX2V4Y2x1ZGVkKTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICAvLyBSZW5kZXJlZCBpbnRvIDxhIGhyZWY+IGZvciBhYnNvbHV0ZSBVUkxzXG4gIGxldCBhYnNvbHV0ZUhyZWY7XG4gIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodG8pKSB7XG4gICAgLy8gUmVuZGVyIHRoZSBhYnNvbHV0ZSBocmVmIHNlcnZlci0gYW5kIGNsaWVudC1zaWRlXG4gICAgYWJzb2x1dGVIcmVmID0gdG87XG4gICAgLy8gT25seSBjaGVjayBmb3IgZXh0ZXJuYWwgb3JpZ2lucyBjbGllbnQtc2lkZVxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgICAgICBpZiAodGFyZ2V0VXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgcGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gU3RyaXAgdGhlIHByb3RvY29sL29yaWdpbi9iYXNlbmFtZSBmb3Igc2FtZS1vcmlnaW4gYWJzb2x1dGUgVVJMc1xuICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0V4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBXZSBjYW4ndCBkbyBleHRlcm5hbCBVUkwgZGV0ZWN0aW9uIHdpdGhvdXQgYSB2YWxpZCBVUkxcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiPExpbmsgdG89XFxcIlwiICsgdG8gKyBcIlxcXCI+IGNvbnRhaW5zIGFuIGludmFsaWQgVVJMIHdoaWNoIHdpbGwgcHJvYmFibHkgYnJlYWsgXCIgKyBcIndoZW4gY2xpY2tlZCAtIHBsZWFzZSB1cGRhdGUgdG8gYSB2YWxpZCBVUkwgcGF0aC5cIikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIHJlbGF0aXZlIFVSTHNcbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICB0YXJnZXQsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlbGF0aXZlLFxuICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gIH0pO1xuICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaHJlZjogYWJzb2x1dGVIcmVmIHx8IGhyZWYsXG4gICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgcmVmOiByZWYsXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pKVxuICApO1xufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbn1cbi8qKlxuICogQSBgPExpbms+YCB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuY29uc3QgTmF2TGluayA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKF9yZWY4LCByZWYpIHtcbiAgbGV0IHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICAgIHRvLFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmOCxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjgsIF9leGNsdWRlZDIpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlOiByZXN0LnJlbGF0aXZlXG4gIH0pO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVyU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBuYXZpZ2F0b3IsXG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGlzVHJhbnNpdGlvbmluZyA9IHJvdXRlclN0YXRlICE9IG51bGwgJiZcbiAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcbiAgbGV0IHRvUGF0aG5hbWUgPSBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWUgOiBwYXRoLnBhdGhuYW1lO1xuICBsZXQgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcbiAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBpZiAobmV4dExvY2F0aW9uUGF0aG5hbWUgJiYgYmFzZW5hbWUpIHtcbiAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uUGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb25QYXRobmFtZTtcbiAgfVxuICAvLyBJZiB0aGUgYHRvYCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgbG9vayBhdCB0aGF0IGV4YWN0IHNwb3QuICBPdGhlcndpc2UsXG4gIC8vIHdlJ3JlIGxvb2tpbmcgZm9yIGEgc2xhc2ggX2FmdGVyXyB3aGF0J3MgaW4gYHRvYC4gIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyA8TmF2TGluayB0bz1cIi91c2Vyc1wiPiBhbmQgPE5hdkxpbmsgdG89XCIvdXNlcnMvXCI+XG4gIC8vIGJvdGggd2FudCB0byBsb29rIGZvciBhIC8gYXQgaW5kZXggNiB0byBtYXRjaCBVUkwgYC91c2Vycy9tYXR0YFxuICBjb25zdCBlbmRTbGFzaFBvc2l0aW9uID0gdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lLmxlbmd0aCAtIDEgOiB0b1BhdGhuYW1lLmxlbmd0aDtcbiAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XG4gIGxldCBpc1BlbmRpbmcgPSBuZXh0TG9jYXRpb25QYXRobmFtZSAhPSBudWxsICYmIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgaXNBY3RpdmUsXG4gICAgaXNQZW5kaW5nLFxuICAgIGlzVHJhbnNpdGlvbmluZ1xuICB9O1xuICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcbiAgbGV0IGNsYXNzTmFtZTtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHJlbmRlclByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgY2xhc3NOYW1lID0gW2NsYXNzTmFtZVByb3AsIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCwgaXNUcmFuc2l0aW9uaW5nID8gXCJ0cmFuc2l0aW9uaW5nXCIgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIH1cbiAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgcmVmOiByZWYsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRvOiB0byxcbiAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbjogdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgfSksIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW4pO1xufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cbi8qKlxuICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcbiAqIHRoYXQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqL1xuY29uc3QgRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChfcmVmOSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGxldCB7XG4gICAgICBmZXRjaGVyS2V5LFxuICAgICAgbmF2aWdhdGUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QsXG4gICAgICBhY3Rpb24sXG4gICAgICBvblN1Ym1pdCxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9ID0gX3JlZjksXG4gICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmOSwgX2V4Y2x1ZGVkMyk7XG4gIGxldCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgc3VibWl0SGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGxldCBzdWJtaXR0ZXIgPSBldmVudC5uYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgbGV0IHN1Ym1pdE1ldGhvZCA9IChzdWJtaXR0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpKSB8fCBtZXRob2Q7XG4gICAgc3VibWl0KHN1Ym1pdHRlciB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICBmZXRjaGVyS2V5LFxuICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJcbiAgfSwgcHJvcHMpKTtcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBGb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oX3JlZjEwKSB7XG4gIGxldCB7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSA9IF9yZWYxMDtcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oe1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgU2Nyb2xsUmVzdG9yYXRpb24uZGlzcGxheU5hbWUgPSBcIlNjcm9sbFJlc3RvcmF0aW9uXCI7XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSG9va3Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgRGF0YVJvdXRlckhvb2s7XG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlU3VibWl0XCJdID0gXCJ1c2VTdWJtaXRcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRGZXRjaGVyXCJdID0gXCJ1c2VTdWJtaXRGZXRjaGVyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlRmV0Y2hlclwiXSA9IFwidXNlRmV0Y2hlclwiO1xuICBEYXRhUm91dGVySG9va1tcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIl0gPSBcInVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcIjtcbn0pKERhdGFSb3V0ZXJIb29rIHx8IChEYXRhUm91dGVySG9vayA9IHt9KSk7XG52YXIgRGF0YVJvdXRlclN0YXRlSG9vaztcbihmdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlclwiXSA9IFwidXNlRmV0Y2hlclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlcnNcIl0gPSBcInVzZUZldGNoZXJzXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcbn0pKERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwgKERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSB7fSkpO1xuLy8gSW50ZXJuYWwgaG9va3NcbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCk7XG4gICFjdHggPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBzdGF0ZTtcbn1cbi8vIEV4dGVybmFsIGhvb2tzXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5mdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUgdW5sZXNzIHRoZSByZXBsYWNlIHByb3AgaXMgZXhwbGljaXRseSBzZXRcbiAgICAgIGxldCByZXBsYWNlID0gcmVwbGFjZVByb3AgIT09IHVuZGVmaW5lZCA/IHJlcGxhY2VQcm9wIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICBuYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHJlbGF0aXZlLCB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbl0pO1xufVxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5mdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcodHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIiwgXCJZb3UgY2Fubm90IHVzZSB0aGUgYHVzZVNlYXJjaFBhcmFtc2AgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBcIiArIFwic3VwcG9ydCB0aGUgVVJMU2VhcmNoUGFyYW1zIEFQSS4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBJbnRlcm5ldCBcIiArIFwiRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgXCIgKyBcImh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcblwiICsgXCJJZiB5b3UncmUgdW5zdXJlIGhvdyB0byBsb2FkIHBvbHlmaWxscywgd2UgcmVjb21tZW5kIHlvdSBjaGVjayBvdXQgXCIgKyBcImh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBcIiArIFwidG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IFwiICsgXCJ1c2VyLlwiKSA6IHZvaWQgMDtcbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG4gIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgc2VhcmNoUGFyYW1zID0gUmVhY3QudXNlTWVtbygoKSA9PlxuICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAvLyBPbmNlIHdlIGNhbGwgdGhhdCB3ZSB3YW50IHRob3NlIHRvIHRha2UgcHJlY2VkZW5jZSwgb3RoZXJ3aXNlIHlvdSBjYW4ndFxuICAvLyByZW1vdmUgYSBwYXJhbSB3aXRoIHNldFNlYXJjaFBhcmFtcyh7fSkgaWYgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWVcbiAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24obG9jYXRpb24uc2VhcmNoLCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQpLCBbbG9jYXRpb24uc2VhcmNoXSk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjaygobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdCk7XG4gICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICB9LCBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc10pO1xuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNhbGxpbmcgc3VibWl0IGR1cmluZyB0aGUgc2VydmVyIHJlbmRlci4gXCIgKyBcIlRyeSBjYWxsaW5nIHN1Ym1pdCB3aXRoaW4gYSBgdXNlRWZmZWN0YCBvciBjYWxsYmFjayBpbnN0ZWFkLlwiKTtcbiAgfVxufVxubGV0IGZldGNoZXJJZCA9IDA7XG5sZXQgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gXCJfX1wiICsgU3RyaW5nKCsrZmV0Y2hlcklkKSArIFwiX19cIjtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzdWJtaXQgYSBmb3JtIChvclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gdXNlU3VibWl0KCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU3VibWl0KTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgY3VycmVudFJvdXRlSWQgPSBVTlNBRkVfdXNlUm91dGVJZCgpO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpO1xuICAgIGxldCB7XG4gICAgICBhY3Rpb24sXG4gICAgICBtZXRob2QsXG4gICAgICBlbmNUeXBlLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBib2R5XG4gICAgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKTtcbiAgICBpZiAob3B0aW9ucy5uYXZpZ2F0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICByb3V0ZXIuZmV0Y2goa2V5LCBjdXJyZW50Um91dGVJZCwgb3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBib2R5LFxuICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZShvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXG4gICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgIHVuc3RhYmxlX2ZsdXNoU3luYzogb3B0aW9ucy51bnN0YWJsZV9mbHVzaFN5bmMsXG4gICAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uOiBvcHRpb25zLnVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBjdXJyZW50Um91dGVJZF0pO1xufVxuLy8gdjc6IEV2ZW50dWFsbHkgd2Ugc2hvdWxkIGRlcHJlY2F0ZSB0aGlzIGVudGlyZWx5IGluIGZhdm9yIG9mIHVzaW5nIHRoZVxuLy8gcm91dGVyIG1ldGhvZCBkaXJlY3RseT9cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRm9ybUFjdGlvbiBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBbbWF0Y2hdID0gcm91dGVDb250ZXh0Lm1hdGNoZXMuc2xpY2UoLTEpO1xuICAvLyBTaGFsbG93IGNsb25lIHBhdGggc28gd2UgY2FuIG1vZGlmeSBpdCBiZWxvdywgb3RoZXJ3aXNlIHdlIG1vZGlmeSB0aGVcbiAgLy8gb2JqZWN0IHJlZmVyZW5jZWQgYnkgdXNlTWVtbyBpbnNpZGUgdXNlUmVzb2x2ZWRQYXRoXG4gIGxldCBwYXRoID0gX2V4dGVuZHMoe30sIHVzZVJlc29sdmVkUGF0aChhY3Rpb24gPyBhY3Rpb24gOiBcIi5cIiwge1xuICAgIHJlbGF0aXZlXG4gIH0pKTtcbiAgLy8gSWYgbm8gYWN0aW9uIHdhcyBzcGVjaWZpZWQsIGJyb3dzZXJzIHdpbGwgcGVyc2lzdCBjdXJyZW50IHNlYXJjaCBwYXJhbXNcbiAgLy8gd2hlbiBkZXRlcm1pbmluZyB0aGUgcGF0aCwgc28gbWF0Y2ggdGhhdCBiZWhhdmlvclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlbWl4L2lzc3Vlcy85MjdcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgLy8gU2FmZSB0byB3cml0ZSB0byB0aGlzIGRpcmVjdGx5IGhlcmUgc2luY2UgaWYgYWN0aW9uIHdhcyB1bmRlZmluZWQsIHdlXG4gICAgLy8gd291bGQgaGF2ZSBjYWxsZWQgdXNlUmVzb2x2ZWRQYXRoKFwiLlwiKSB3aGljaCB3aWxsIG5ldmVyIGluY2x1ZGUgYSBzZWFyY2hcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICAvLyBXaGVuIGdyYWJiaW5nIHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUgVVJMLCByZW1vdmUgYW55IGluY2x1ZGVkID9pbmRleCBwYXJhbVxuICAgIC8vIHNpbmNlIGl0IG1pZ2h0IG5vdCBhcHBseSB0byBvdXIgY29udGV4dHVhbCByb3V0ZS4gIFdlIGFkZCBpdCBiYWNrIGJhc2VkXG4gICAgLy8gb24gbWF0Y2gucm91dGUuaW5kZXggYmVsb3dcbiAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgaWYgKHBhcmFtcy5oYXMoXCJpbmRleFwiKSAmJiBwYXJhbXMuZ2V0KFwiaW5kZXhcIikgPT09IFwiXCIpIHtcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcGFyYW1zLnRvU3RyaW5nKCkgPyBcIj9cIiArIHBhcmFtcy50b1N0cmluZygpIDogXCJcIjtcbiAgICB9XG4gIH1cbiAgaWYgKCghYWN0aW9uIHx8IGFjdGlvbiA9PT0gXCIuXCIpICYmIG1hdGNoLnJvdXRlLmluZGV4KSB7XG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xuICB9XG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxuICAvLyB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGVcbiAgLy8gcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGFjdGlvbnNcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuLy8gVE9ETzogKHY3KSBDaGFuZ2UgdGhlIHVzZUZldGNoZXIgZ2VuZXJpYyBkZWZhdWx0IGZyb20gYGFueWAgdG8gYHVua25vd25gXG4vKipcbiAqIEludGVyYWN0cyB3aXRoIHJvdXRlIGxvYWRlcnMgYW5kIGFjdGlvbnMgd2l0aG91dCBjYXVzaW5nIGEgbmF2aWdhdGlvbi4gR3JlYXRcbiAqIGZvciBhbnkgaW50ZXJhY3Rpb24gdGhhdCBzdGF5cyBvbiB0aGUgc2FtZSBwYWdlLlxuICovXG5mdW5jdGlvbiB1c2VGZXRjaGVyKF90ZW1wMykge1xuICB2YXIgX3JvdXRlJG1hdGNoZXM7XG4gIGxldCB7XG4gICAga2V5XG4gIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlRmV0Y2hlcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXIpO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdC51c2VDb250ZXh0KEZldGNoZXJzQ29udGV4dCk7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX1JvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZUlkID0gKF9yb3V0ZSRtYXRjaGVzID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlJG1hdGNoZXMucm91dGUuaWQ7XG4gICFmZXRjaGVyRGF0YSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgUm91dGVDb250ZXh0XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEocm91dGVJZCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAvLyBGZXRjaGVyIGtleSBoYW5kbGluZ1xuICAvLyBPSyB0byBjYWxsIGNvbmRpdGlvbmFsbHkgdG8gZmVhdHVyZSBkZXRlY3QgYHVzZUlkYFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgbGV0IGRlZmF1bHRLZXkgPSB1c2VJZEltcGwgPyB1c2VJZEltcGwoKSA6IFwiXCI7XG4gIGxldCBbZmV0Y2hlcktleSwgc2V0RmV0Y2hlcktleV0gPSBSZWFjdC51c2VTdGF0ZShrZXkgfHwgZGVmYXVsdEtleSk7XG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICB9IGVsc2UgaWYgKCFmZXRjaGVyS2V5KSB7XG4gICAgLy8gV2Ugd2lsbCBvbmx5IGZhbGwgdGhyb3VnaCBoZXJlIHdoZW4gYHVzZUlkYCBpcyBub3QgYXZhaWxhYmxlXG4gICAgc2V0RmV0Y2hlcktleShnZXRVbmlxdWVGZXRjaGVySWQoKSk7XG4gIH1cbiAgLy8gUmVnaXN0cmF0aW9uL2NsZWFudXBcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByb3V0ZXIuZ2V0RmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gVGVsbCB0aGUgcm91dGVyIHdlJ3ZlIHVubW91bnRlZCAtIGlmIHY3X2ZldGNoZXJQZXJzaXN0IGlzIGVuYWJsZWQgdGhpc1xuICAgICAgLy8gd2lsbCBub3QgZGVsZXRlIGltbWVkaWF0ZWx5IGJ1dCBpbnN0ZWFkIHF1ZXVlIHVwIGEgZGVsZXRlIGFmdGVyIHRoZVxuICAgICAgLy8gZmV0Y2hlciByZXR1cm5zIHRvIGFuIGBpZGxlYCBzdGF0ZVxuICAgICAgcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gICAgfTtcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xuICAvLyBGZXRjaGVyIGFkZGl0aW9uc1xuICBsZXQgbG9hZCA9IFJlYWN0LnVzZUNhbGxiYWNrKChocmVmLCBvcHRzKSA9PiB7XG4gICAgIXJvdXRlSWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCByb3V0ZUlkLCBocmVmLCBvcHRzKTtcbiAgfSwgW2ZldGNoZXJLZXksIHJvdXRlSWQsIHJvdXRlcl0pO1xuICBsZXQgc3VibWl0SW1wbCA9IHVzZVN1Ym1pdCgpO1xuICBsZXQgc3VibWl0ID0gUmVhY3QudXNlQ2FsbGJhY2soKHRhcmdldCwgb3B0cykgPT4ge1xuICAgIHN1Ym1pdEltcGwodGFyZ2V0LCBfZXh0ZW5kcyh7fSwgb3B0cywge1xuICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgZmV0Y2hlcktleVxuICAgIH0pKTtcbiAgfSwgW2ZldGNoZXJLZXksIHN1Ym1pdEltcGxdKTtcbiAgbGV0IEZldGNoZXJGb3JtID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IEZldGNoZXJGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgbmF2aWdhdGU6IGZhbHNlLFxuICAgICAgICBmZXRjaGVyS2V5OiBmZXRjaGVyS2V5LFxuICAgICAgICByZWY6IHJlZlxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIEZldGNoZXJGb3JtLmRpc3BsYXlOYW1lID0gXCJmZXRjaGVyLkZvcm1cIjtcbiAgICB9XG4gICAgcmV0dXJuIEZldGNoZXJGb3JtO1xuICB9LCBbZmV0Y2hlcktleV0pO1xuICAvLyBFeHBvc2VkIEZldGNoZXJXaXRoQ29tcG9uZW50c1xuICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChmZXRjaGVyS2V5KSB8fCBJRExFX0ZFVENIRVI7XG4gIGxldCBkYXRhID0gZmV0Y2hlckRhdGEuZ2V0KGZldGNoZXJLZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgRm9ybTogRmV0Y2hlckZvcm0sXG4gICAgc3VibWl0LFxuICAgIGxvYWRcbiAgfSwgZmV0Y2hlciwge1xuICAgIGRhdGFcbiAgfSksIFtGZXRjaGVyRm9ybSwgc3VibWl0LCBsb2FkLCBmZXRjaGVyLCBkYXRhXSk7XG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG4vKipcbiAqIFByb3ZpZGVzIGFsbCBmZXRjaGVycyBjdXJyZW50bHkgb24gdGhlIHBhZ2UuIFVzZWZ1bCBmb3IgbGF5b3V0cyBhbmQgcGFyZW50XG4gKiByb3V0ZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgcGVuZGluZy9vcHRpbWlzdGljIFVJIHJlZ2FyZGluZyB0aGUgZmV0Y2guXG4gKi9cbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVycyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHN0YXRlLmZldGNoZXJzLmVudHJpZXMoKSkubWFwKF9yZWYxMSA9PiB7XG4gICAgbGV0IFtrZXksIGZldGNoZXJdID0gX3JlZjExO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZmV0Y2hlciwge1xuICAgICAga2V5XG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xubGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zID0ge307XG4vKipcbiAqIFdoZW4gcmVuZGVyZWQgaW5zaWRlIGEgUm91dGVyUHJvdmlkZXIsIHdpbGwgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25zIG9uIG5hdmlnYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZVNjcm9sbFJlc3RvcmF0aW9uKF90ZW1wNCkge1xuICBsZXQge1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0gPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0O1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQge1xuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbixcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKTtcbiAgbGV0IG5hdmlnYXRpb24gPSB1c2VOYXZpZ2F0aW9uKCk7XG4gIC8vIFRyaWdnZXIgbWFudWFsIHNjcm9sbCByZXN0b3JhdGlvbiB3aGlsZSB3ZSdyZSBhY3RpdmVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfTtcbiAgfSwgW10pO1xuICAvLyBTYXZlIHBvc2l0aW9ucyBvbiBwYWdlaGlkZVxuICB1c2VQYWdlSGlkZShSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBsZXQga2V5ID0gKGdldEtleSA/IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcykgOiBudWxsKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzYXZlZFNjcm9sbFBvc2l0aW9ucykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoXCIgKyBlcnJvciArIFwiKS5cIikgOiB2b2lkIDA7XG4gICAgfVxuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gIH0sIFtzdG9yYWdlS2V5LCBnZXRLZXksIG5hdmlnYXRpb24uc3RhdGUsIGxvY2F0aW9uLCBtYXRjaGVzXSkpO1xuICAvLyBSZWFkIGluIGFueSBzYXZlZCBzY3JvbGwgbG9jYXRpb25zXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG4gICAgLy8gRW5hYmxlIHNjcm9sbCByZXN0b3JhdGlvbiBpbiB0aGUgcm91dGVyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBnZXRLZXlXaXRob3V0QmFzZW5hbWUgPSBnZXRLZXkgJiYgYmFzZW5hbWUgIT09IFwiL1wiID8gKGxvY2F0aW9uLCBtYXRjaGVzKSA9PiBnZXRLZXkoIC8vIFN0cmlwIHRoZSBiYXNlbmFtZSB0byBtYXRjaCB1c2VMb2NhdGlvbigpXG4gICAgICBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSksIG1hdGNoZXMpIDogZ2V0S2V5O1xuICAgICAgbGV0IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiA9IHJvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyLmVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHNhdmVkU2Nyb2xsUG9zaXRpb25zLCAoKSA9PiB3aW5kb3cuc2Nyb2xsWSwgZ2V0S2V5V2l0aG91dEJhc2VuYW1lKTtcbiAgICAgIHJldHVybiAoKSA9PiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24gJiYgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gICAgfSwgW3JvdXRlciwgYmFzZW5hbWUsIGdldEtleV0pO1xuICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gYmVlbiBoZXJlIGJlZm9yZSwgc2Nyb2xsIHRvIGl0XG4gICAgICBpZiAodHlwZW9mIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdHJ5IHRvIHNjcm9sbCB0byB0aGUgaGFzaFxuICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHJlc2V0IGlmIHRoaXMgbmF2aWdhdGlvbiBvcHRlZCBvdXRcbiAgICAgIGlmIChwcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbiwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLCBwcmV2ZW50U2Nyb2xsUmVzZXRdKTtcbiAgfVxufVxuLyoqXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5mdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBjYXB0dXJlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgY2FwdHVyZVxuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZVBhZ2VIaWRlKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGxldCB7XG4gICAgY2FwdHVyZVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgb3B0cyA9IGNhcHR1cmUgIT0gbnVsbCA/IHtcbiAgICAgIGNhcHR1cmVcbiAgICB9IDogdW5kZWZpbmVkO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbi8qKlxuICogV3JhcHBlciBhcm91bmQgdXNlQmxvY2tlciB0byBzaG93IGEgd2luZG93LmNvbmZpcm0gcHJvbXB0IHRvIHVzZXJzIGluc3RlYWRcbiAqIG9mIGJ1aWxkaW5nIGEgY3VzdG9tIFVJIHdpdGggdXNlQmxvY2tlci5cbiAqXG4gKiBXYXJuaW5nOiBUaGlzIGhhcyAqYSBsb3Qgb2Ygcm91Z2ggZWRnZXMqIGFuZCBiZWhhdmVzIHZlcnkgZGlmZmVyZW50bHkgKGFuZFxuICogdmVyeSBpbmNvcnJlY3RseSBpbiBzb21lIGNhc2VzKSBhY3Jvc3MgYnJvd3NlcnMgaWYgdXNlciBjbGljayBhZGRpdGlvblxuICogYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdoaWxlIHRoZSBjb25maXJtIGlzIG9wZW4uICBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAqL1xuZnVuY3Rpb24gdXNlUHJvbXB0KF9yZWYxMikge1xuICBsZXQge1xuICAgIHdoZW4sXG4gICAgbWVzc2FnZVxuICB9ID0gX3JlZjEyO1xuICBsZXQgYmxvY2tlciA9IHVzZUJsb2NrZXIod2hlbik7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiKSB7XG4gICAgICBsZXQgcHJvY2VlZCA9IHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpO1xuICAgICAgaWYgKHByb2NlZWQpIHtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IGlzIG5lZWRlZCB0byBhdm9pZCBhIHdlaXJkIFwicmFjZVwiIG9uIFBPUCBuYXZpZ2F0aW9uc1xuICAgICAgICAvLyBiZXR3ZWVuIHRoZSBgd2luZG93Lmhpc3RvcnlgIHJldmVydCBuYXZpZ2F0aW9uIGFuZCB0aGUgcmVzdWx0IG9mXG4gICAgICAgIC8vIGB3aW5kb3cuY29uZmlybWBcbiAgICAgICAgc2V0VGltZW91dChibG9ja2VyLnByb2NlZWQsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgIXdoZW4pIHtcbiAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICB9XG4gIH0sIFtibG9ja2VyLCB3aGVuXSk7XG59XG4vKipcbiAqIFJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgdmlldyB0cmFuc2l0aW9uIHRvIHRoZVxuICogZ2l2ZW4gaHJlZi4gIFlvdSBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gcmVuZGVyIENTUyBjbGFzc2VzIG9yIHZpZXdUcmFuc2l0aW9uTmFtZVxuICogc3R5bGVzIG9udG8geW91ciBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSBocmVmIFRoZSBkZXN0aW5hdGlvbiBocmVmXG4gKiBAcGFyYW0gW29wdHMucmVsYXRpdmVdIFJlbGF0aXZlIHJvdXRpbmcgdHlwZSAoXCJyb3V0ZVwiIHwgXCJwYXRoXCIpXG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUodG8sIG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICBsZXQgdnRDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChWaWV3VHJhbnNpdGlvbkNvbnRleHQpO1xuICAhKHZ0Q29udGV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiYHVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGVgIG11c3QgYmUgdXNlZCB3aXRoaW4gYHJlYWN0LXJvdXRlci1kb21gJ3MgYFJvdXRlclByb3ZpZGVyYC4gIFwiICsgXCJEaWQgeW91IGFjY2lkZW50YWxseSBpbXBvcnQgYFJvdXRlclByb3ZpZGVyYCBmcm9tIGByZWFjdC1yb3V0ZXJgP1wiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay51c2VWaWV3VHJhbnNpdGlvblN0YXRlKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZTogb3B0cy5yZWxhdGl2ZVxuICB9KTtcbiAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBjdXJyZW50UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWU7XG4gIC8vIFRyYW5zaXRpb24gaXMgYWN0aXZlIGlmIHdlJ3JlIGdvaW5nIHRvIG9yIGNvbWluZyBmcm9tIHRoZSBpbmRpY2F0ZWRcbiAgLy8gZGVzdGluYXRpb24uICBUaGlzIGVuc3VyZXMgdGhhdCBvdGhlciBQVVNIIG5hdmlnYXRpb25zIHRoYXQgcmV2ZXJzZVxuICAvLyBhbiBpbmRpY2F0ZWQgdHJhbnNpdGlvbiBhcHBseS4gIEkuZS4sIG9uIHRoZSBsaXN0IHZpZXcgeW91IGhhdmU6XG4gIC8vXG4gIC8vICAgPE5hdkxpbmsgdG89XCIvZGV0YWlscy8xXCIgdW5zdGFibGVfdmlld1RyYW5zaXRpb24+XG4gIC8vXG4gIC8vIElmIHlvdSBjbGljayB0aGUgYnJlYWRjcnVtYiBiYWNrIHRvIHRoZSBsaXN0IHZpZXc6XG4gIC8vXG4gIC8vICAgPE5hdkxpbmsgdG89XCIvbGlzdFwiIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uPlxuICAvL1xuICAvLyBXZSBzaG91bGQgYXBwbHkgdGhlIHRyYW5zaXRpb24gYmVjYXVzZSBpdCdzIGluZGljYXRlZCBhcyBhY3RpdmUgZ29pbmdcbiAgLy8gZnJvbSAvbGlzdCAtPiAvZGV0YWlscy8xIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIGFjdGl2ZSBvbiB0aGUgcmV2ZXJzZVxuICAvLyAoZXZlbiB0aG91Z2ggdGhpcyBpc24ndCBzdHJpY3RseSBhIFBPUCByZXZlcnNlKVxuICByZXR1cm4gbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIG5leHRQYXRoKSAhPSBudWxsIHx8IG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBjdXJyZW50UGF0aCkgIT0gbnVsbDtcbn1cbi8vI2VuZHJlZ2lvblxuXG5leHBvcnQgeyBCcm93c2VyUm91dGVyLCBGb3JtLCBIYXNoUm91dGVyLCBMaW5rLCBOYXZMaW5rLCBSb3V0ZXJQcm92aWRlciwgU2Nyb2xsUmVzdG9yYXRpb24sIEZldGNoZXJzQ29udGV4dCBhcyBVTlNBRkVfRmV0Y2hlcnNDb250ZXh0LCBWaWV3VHJhbnNpdGlvbkNvbnRleHQgYXMgVU5TQUZFX1ZpZXdUcmFuc2l0aW9uQ29udGV4dCwgdXNlU2Nyb2xsUmVzdG9yYXRpb24gYXMgVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uLCBjcmVhdGVCcm93c2VyUm91dGVyLCBjcmVhdGVIYXNoUm91dGVyLCBjcmVhdGVTZWFyY2hQYXJhbXMsIEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciwgdXNlUHJvbXB0IGFzIHVuc3RhYmxlX3VzZVByb21wdCwgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSBhcyB1bnN0YWJsZV91c2VWaWV3VHJhbnNpdGlvblN0YXRlLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMaW5rQ2xpY2tIYW5kbGVyLCB1c2VTZWFyY2hQYXJhbXMsIHVzZVN1Ym1pdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJSZWFjdERPTSIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIlJvdXRlciIsIlVOU0FGRV91c2VSb3V0ZXNJbXBsIiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwidXNlSHJlZiIsInVzZVJlc29sdmVkUGF0aCIsInVzZUxvY2F0aW9uIiwidXNlTmF2aWdhdGUiLCJjcmVhdGVQYXRoIiwiVU5TQUZFX3VzZVJvdXRlSWQiLCJVTlNBRkVfUm91dGVDb250ZXh0IiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRpb24iLCJ1c2VCbG9ja2VyIiwiQWJvcnRlZERlZmVycmVkRXJyb3IiLCJBd2FpdCIsIk1lbW9yeVJvdXRlciIsIk5hdmlnYXRlIiwiTmF2aWdhdGlvblR5cGUiLCJPdXRsZXQiLCJSb3V0ZSIsIlJvdXRlcyIsIlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMiLCJkZWZlciIsImdlbmVyYXRlUGF0aCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwianNvbiIsIm1hdGNoUGF0aCIsIm1hdGNoUm91dGVzIiwicGFyc2VQYXRoIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVuZGVyTWF0Y2hlcyIsInJlc29sdmVQYXRoIiwidXNlQWN0aW9uRGF0YSIsInVzZUFzeW5jRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwidXNlTG9hZGVyRGF0YSIsInVzZU1hdGNoIiwidXNlTmF2aWdhdGlvblR5cGUiLCJ1c2VPdXRsZXQiLCJ1c2VPdXRsZXRDb250ZXh0IiwidXNlUGFyYW1zIiwidXNlUmV2YWxpZGF0b3IiLCJ1c2VSb3V0ZUVycm9yIiwidXNlUm91dGVMb2FkZXJEYXRhIiwidXNlUm91dGVzIiwic3RyaXBCYXNlbmFtZSIsIlVOU0FGRV93YXJuaW5nIiwiY3JlYXRlUm91dGVyIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsIlVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCIsIlVOU0FGRV9pbnZhcmlhbnQiLCJqb2luUGF0aHMiLCJJRExFX0ZFVENIRVIiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwiZGVmYXVsdE1ldGhvZCIsImRlZmF1bHRFbmNUeXBlIiwiaXNIdG1sRWxlbWVudCIsIm9iamVjdCIsInRhZ05hbWUiLCJpc0J1dHRvbkVsZW1lbnQiLCJ0b0xvd2VyQ2FzZSIsImlzRm9ybUVsZW1lbnQiLCJpc0lucHV0RWxlbWVudCIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsInNob3VsZFByb2Nlc3NMaW5rQ2xpY2siLCJidXR0b24iLCJjcmVhdGVTZWFyY2hQYXJhbXMiLCJpbml0IiwiVVJMU2VhcmNoUGFyYW1zIiwiQXJyYXkiLCJpc0FycmF5IiwicmVkdWNlIiwibWVtbyIsInZhbHVlIiwiY29uY2F0IiwibWFwIiwidiIsImdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uIiwibG9jYXRpb25TZWFyY2giLCJkZWZhdWx0U2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiZm9yRWFjaCIsIl8iLCJoYXMiLCJnZXRBbGwiLCJhcHBlbmQiLCJfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciIsImlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQiLCJGb3JtRGF0YSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImUiLCJzdXBwb3J0ZWRGb3JtRW5jVHlwZXMiLCJTZXQiLCJnZXRGb3JtRW5jVHlwZSIsImVuY1R5cGUiLCJnZXRGb3JtU3VibWlzc2lvbkluZm8iLCJiYXNlbmFtZSIsIm1ldGhvZCIsImFjdGlvbiIsImZvcm1EYXRhIiwiYm9keSIsImF0dHIiLCJnZXRBdHRyaWJ1dGUiLCJ0eXBlIiwiZm9ybSIsIkVycm9yIiwibmFtZSIsInByZWZpeCIsInVuZGVmaW5lZCIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJfZXhjbHVkZWQzIiwiUkVBQ1RfUk9VVEVSX1ZFUlNJT04iLCJ3aW5kb3ciLCJfX3JlYWN0Um91dGVyVmVyc2lvbiIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJyb3V0ZXMiLCJvcHRzIiwiZnV0dXJlIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaGlzdG9yeSIsImh5ZHJhdGlvbkRhdGEiLCJwYXJzZUh5ZHJhdGlvbkRhdGEiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJpbml0aWFsaXplIiwiY3JlYXRlSGFzaFJvdXRlciIsIl93aW5kb3ciLCJzdGF0ZSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImVycm9ycyIsImRlc2VyaWFsaXplRXJyb3JzIiwiZW50cmllcyIsInNlcmlhbGl6ZWQiLCJ2YWwiLCJfX3R5cGUiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImludGVybmFsIiwiX19zdWJUeXBlIiwiRXJyb3JDb25zdHJ1Y3RvciIsImVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwiVmlld1RyYW5zaXRpb25Db250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImlzVHJhbnNpdGlvbmluZyIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsIkZldGNoZXJzQ29udGV4dCIsIk1hcCIsIlNUQVJUX1RSQU5TSVRJT04iLCJzdGFydFRyYW5zaXRpb25JbXBsIiwiRkxVU0hfU1lOQyIsImZsdXNoU3luY0ltcGwiLCJVU0VfSUQiLCJ1c2VJZEltcGwiLCJzdGFydFRyYW5zaXRpb25TYWZlIiwiY2IiLCJmbHVzaFN5bmNTYWZlIiwiRGVmZXJyZWQiLCJjb25zdHJ1Y3RvciIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYXNvbiIsIlJvdXRlclByb3ZpZGVyIiwiX3JlZiIsImZhbGxiYWNrRWxlbWVudCIsInJvdXRlciIsInNldFN0YXRlSW1wbCIsInVzZVN0YXRlIiwicGVuZGluZ1N0YXRlIiwic2V0UGVuZGluZ1N0YXRlIiwidnRDb250ZXh0Iiwic2V0VnRDb250ZXh0IiwicmVuZGVyRGZkIiwic2V0UmVuZGVyRGZkIiwidHJhbnNpdGlvbiIsInNldFRyYW5zaXRpb24iLCJpbnRlcnJ1cHRpb24iLCJzZXRJbnRlcnJ1cHRpb24iLCJmZXRjaGVyRGF0YSIsInVzZVJlZiIsInY3X3N0YXJ0VHJhbnNpdGlvbiIsIm9wdEluU3RhcnRUcmFuc2l0aW9uIiwidXNlQ2FsbGJhY2siLCJzZXRTdGF0ZSIsIm5ld1N0YXRlIiwiX3JlZjIiLCJkZWxldGVkRmV0Y2hlcnMiLCJ1bnN0YWJsZV9mbHVzaFN5bmMiLCJmbHVzaFN5bmMiLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHMiLCJ2aWV3VHJhbnNpdGlvbk9wdHMiLCJjdXJyZW50IiwiZGVsZXRlIiwiZmV0Y2hlcnMiLCJmZXRjaGVyIiwic2V0IiwiaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlIiwic3RhcnRWaWV3VHJhbnNpdGlvbiIsInNraXBUcmFuc2l0aW9uIiwiY3VycmVudExvY2F0aW9uIiwibmV4dExvY2F0aW9uIiwidCIsImZpbmlzaGVkIiwiZmluYWxseSIsInVzZUxheW91dEVmZmVjdCIsInN1YnNjcmliZSIsInVzZUVmZmVjdCIsInJlbmRlclByb21pc2UiLCJsb2NhdGlvbiIsInY3X3BhcnRpYWxIeWRyYXRpb24iLCJuYXZpZ2F0b3IiLCJ1c2VNZW1vIiwiY3JlYXRlSHJlZiIsImVuY29kZUxvY2F0aW9uIiwiZ28iLCJuIiwibmF2aWdhdGUiLCJwdXNoIiwidG8iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXBsYWNlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJzdGF0aWMiLCJGcmFnbWVudCIsIlByb3ZpZGVyIiwibmF2aWdhdGlvblR5cGUiLCJoaXN0b3J5QWN0aW9uIiwidjdfcmVsYXRpdmVTcGxhdFBhdGgiLCJpbml0aWFsaXplZCIsIkRhdGFSb3V0ZXMiLCJfcmVmMyIsIkJyb3dzZXJSb3V0ZXIiLCJfcmVmNCIsImNoaWxkcmVuIiwiaGlzdG9yeVJlZiIsInY1Q29tcGF0IiwibGlzdGVuIiwiSGFzaFJvdXRlciIsIl9yZWY1IiwiSGlzdG9yeVJvdXRlciIsIl9yZWY2IiwiaXNCcm93c2VyIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiTGluayIsImZvcndhcmRSZWYiLCJMaW5rV2l0aFJlZiIsIl9yZWY3IiwicmVmIiwib25DbGljayIsInJlbGF0aXZlIiwicmVsb2FkRG9jdW1lbnQiLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiIsInJlc3QiLCJ1c2VDb250ZXh0IiwiYWJzb2x1dGVIcmVmIiwiaXNFeHRlcm5hbCIsInRlc3QiLCJjdXJyZW50VXJsIiwiVVJMIiwiaHJlZiIsInRhcmdldFVybCIsInN0YXJ0c1dpdGgiLCJwcm90b2NvbCIsInBhdGgiLCJwYXRobmFtZSIsIm9yaWdpbiIsInNlYXJjaCIsImhhc2giLCJpbnRlcm5hbE9uQ2xpY2siLCJ1c2VMaW5rQ2xpY2tIYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwiTmF2TGluayIsIk5hdkxpbmtXaXRoUmVmIiwiX3JlZjgiLCJhcmlhQ3VycmVudFByb3AiLCJjYXNlU2Vuc2l0aXZlIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsImVuZCIsInN0eWxlIiwic3R5bGVQcm9wIiwicm91dGVyU3RhdGUiLCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlIiwidG9QYXRobmFtZSIsImxvY2F0aW9uUGF0aG5hbWUiLCJuZXh0TG9jYXRpb25QYXRobmFtZSIsIm5hdmlnYXRpb24iLCJlbmRTbGFzaFBvc2l0aW9uIiwiZW5kc1dpdGgiLCJpc0FjdGl2ZSIsImNoYXJBdCIsImlzUGVuZGluZyIsInJlbmRlclByb3BzIiwiYXJpYUN1cnJlbnQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIkZvcm0iLCJfcmVmOSIsImZvcndhcmRlZFJlZiIsImZldGNoZXJLZXkiLCJvblN1Ym1pdCIsInByb3BzIiwic3VibWl0IiwidXNlU3VibWl0IiwiZm9ybUFjdGlvbiIsInVzZUZvcm1BY3Rpb24iLCJmb3JtTWV0aG9kIiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0IiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmMTAiLCJnZXRLZXkiLCJzdG9yYWdlS2V5IiwidXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJEYXRhUm91dGVySG9vayIsIkRhdGFSb3V0ZXJTdGF0ZUhvb2siLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yIiwiaG9va05hbWUiLCJ1c2VEYXRhUm91dGVyQ29udGV4dCIsImN0eCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsIl90ZW1wIiwicmVwbGFjZVByb3AiLCJ1c2VTZWFyY2hQYXJhbXMiLCJkZWZhdWx0SW5pdCIsImRlZmF1bHRTZWFyY2hQYXJhbXNSZWYiLCJoYXNTZXRTZWFyY2hQYXJhbXNSZWYiLCJzZXRTZWFyY2hQYXJhbXMiLCJuZXh0SW5pdCIsIm5hdmlnYXRlT3B0aW9ucyIsIm5ld1NlYXJjaFBhcmFtcyIsInZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24iLCJmZXRjaGVySWQiLCJnZXRVbmlxdWVGZXRjaGVySWQiLCJTdHJpbmciLCJVc2VTdWJtaXQiLCJjdXJyZW50Um91dGVJZCIsIm9wdGlvbnMiLCJmZXRjaCIsImZvcm1FbmNUeXBlIiwiZnJvbVJvdXRlSWQiLCJfdGVtcDIiLCJyb3V0ZUNvbnRleHQiLCJtYXRjaCIsIm1hdGNoZXMiLCJzbGljZSIsInBhcmFtcyIsImdldCIsInRvU3RyaW5nIiwicm91dGUiLCJpbmRleCIsInVzZUZldGNoZXIiLCJfdGVtcDMiLCJfcm91dGUkbWF0Y2hlcyIsIlVzZUZldGNoZXIiLCJyb3V0ZUlkIiwiaWQiLCJkZWZhdWx0S2V5Iiwic2V0RmV0Y2hlcktleSIsImdldEZldGNoZXIiLCJkZWxldGVGZXRjaGVyIiwibG9hZCIsInN1Ym1pdEltcGwiLCJGZXRjaGVyRm9ybSIsImZldGNoZXJXaXRoQ29tcG9uZW50cyIsInVzZUZldGNoZXJzIiwiVXNlRmV0Y2hlcnMiLCJmcm9tIiwiX3JlZjExIiwiU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZIiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJfdGVtcDQiLCJVc2VTY3JvbGxSZXN0b3JhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlc3Npb25Qb3NpdGlvbnMiLCJnZXRJdGVtIiwicGFyc2UiLCJnZXRLZXlXaXRob3V0QmFzZW5hbWUiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsImRlY29kZVVSSUNvbXBvbmVudCIsInNjcm9sbEludG9WaWV3IiwidXNlQmVmb3JlVW5sb2FkIiwiY2FsbGJhY2siLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VQcm9tcHQiLCJfcmVmMTIiLCJ3aGVuIiwiYmxvY2tlciIsInByb2NlZWQiLCJjb25maXJtIiwic2V0VGltZW91dCIsInJlc2V0IiwiY3VycmVudFBhdGgiLCJuZXh0UGF0aCIsIlVOU0FGRV9GZXRjaGVyc0NvbnRleHQiLCJVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0IiwiVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uIiwidW5zdGFibGVfSGlzdG9yeVJvdXRlciIsInVuc3RhYmxlX3VzZVByb21wdCIsInVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/react-router-dom/dist/index.js\n");

/***/ })

};
;