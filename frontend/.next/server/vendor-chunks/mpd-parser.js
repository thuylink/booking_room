"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mpd-parser";
exports.ids = ["vendor-chunks/mpd-parser"];
exports.modules = {

/***/ "(ssr)/../node_modules/mpd-parser/dist/mpd-parser.es.js":
/*!********************************************************!*\
  !*** ../node_modules/mpd-parser/dist/mpd-parser.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   addSidxSegmentsToPlaylist: () => (/* binding */ addSidxSegmentsToPlaylist$1),\n/* harmony export */   generateSidxKey: () => (/* binding */ generateSidxKey),\n/* harmony export */   inheritAttributes: () => (/* binding */ inheritAttributes),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseUTCTiming: () => (/* binding */ parseUTCTiming),\n/* harmony export */   stringToMpdXml: () => (/* binding */ stringToMpdXml),\n/* harmony export */   toM3u8: () => (/* binding */ toM3u8),\n/* harmony export */   toPlaylists: () => (/* binding */ toPlaylists)\n/* harmony export */ });\n/* harmony import */ var _videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @videojs/vhs-utils/es/resolve-url */ \"(ssr)/../node_modules/@videojs/vhs-utils/es/resolve-url.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! global/window */ \"(ssr)/../node_modules/global/window.js\");\n/* harmony import */ var global_window__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(global_window__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _videojs_vhs_utils_es_media_groups__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @videojs/vhs-utils/es/media-groups */ \"(ssr)/../node_modules/@videojs/vhs-utils/es/media-groups.js\");\n/* harmony import */ var _videojs_vhs_utils_es_decode_b64_to_uint8_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @videojs/vhs-utils/es/decode-b64-to-uint8-array */ \"(ssr)/../node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js\");\n/* harmony import */ var _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/../node_modules/@xmldom/xmldom/lib/index.js\");\n/*! @name mpd-parser @version 0.22.1 @license Apache-2.0 */ \n\n\n\n\nvar version = \"0.22.1\";\nvar isObject = function isObject(obj) {\n    return !!obj && typeof obj === \"object\";\n};\nvar merge = function merge() {\n    for(var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++){\n        objects[_key] = arguments[_key];\n    }\n    return objects.reduce(function(result, source) {\n        if (typeof source !== \"object\") {\n            return result;\n        }\n        Object.keys(source).forEach(function(key) {\n            if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n                result[key] = result[key].concat(source[key]);\n            } else if (isObject(result[key]) && isObject(source[key])) {\n                result[key] = merge(result[key], source[key]);\n            } else {\n                result[key] = source[key];\n            }\n        });\n        return result;\n    }, {});\n};\nvar values = function values(o) {\n    return Object.keys(o).map(function(k) {\n        return o[k];\n    });\n};\nvar range = function range(start, end) {\n    var result = [];\n    for(var i = start; i < end; i++){\n        result.push(i);\n    }\n    return result;\n};\nvar flatten = function flatten(lists) {\n    return lists.reduce(function(x, y) {\n        return x.concat(y);\n    }, []);\n};\nvar from = function from(list) {\n    if (!list.length) {\n        return [];\n    }\n    var result = [];\n    for(var i = 0; i < list.length; i++){\n        result.push(list[i]);\n    }\n    return result;\n};\nvar findIndexes = function findIndexes(l, key) {\n    return l.reduce(function(a, e, i) {\n        if (e[key]) {\n            a.push(i);\n        }\n        return a;\n    }, []);\n};\n/**\n * Returns the first index that satisfies the matching function, or -1 if not found.\n *\n * Only necessary because of IE11 support.\n *\n * @param {Array} list - the list to search through\n * @param {Function} matchingFunction - the matching function\n *\n * @return {number} the matching index or -1 if not found\n */ var findIndex = function findIndex(list, matchingFunction) {\n    for(var i = 0; i < list.length; i++){\n        if (matchingFunction(list[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */ var union = function union(lists, keyFunction) {\n    return values(lists.reduce(function(acc, list) {\n        list.forEach(function(el) {\n            acc[keyFunction(el)] = el;\n        });\n        return acc;\n    }, {}));\n};\nvar errors = {\n    INVALID_NUMBER_OF_PERIOD: \"INVALID_NUMBER_OF_PERIOD\",\n    DASH_EMPTY_MANIFEST: \"DASH_EMPTY_MANIFEST\",\n    DASH_INVALID_XML: \"DASH_INVALID_XML\",\n    NO_BASE_URL: \"NO_BASE_URL\",\n    MISSING_SEGMENT_INFORMATION: \"MISSING_SEGMENT_INFORMATION\",\n    SEGMENT_TIME_UNSPECIFIED: \"SEGMENT_TIME_UNSPECIFIED\",\n    UNSUPPORTED_UTC_TIMING_SCHEME: \"UNSUPPORTED_UTC_TIMING_SCHEME\"\n};\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */ /**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */ var urlTypeToSegment = function urlTypeToSegment(_ref) {\n    var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? \"\" : _ref$baseUrl, _ref$source = _ref.source, source = _ref$source === void 0 ? \"\" : _ref$source, _ref$range = _ref.range, range = _ref$range === void 0 ? \"\" : _ref$range, _ref$indexRange = _ref.indexRange, indexRange = _ref$indexRange === void 0 ? \"\" : _ref$indexRange;\n    var segment = {\n        uri: source,\n        resolvedUri: (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(baseUrl || \"\", source)\n    };\n    if (range || indexRange) {\n        var rangeStr = range ? range : indexRange;\n        var ranges = rangeStr.split(\"-\"); // default to parsing this as a BigInt if possible\n        var startRange = (global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt) ? global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(ranges[0]) : parseInt(ranges[0], 10);\n        var endRange = (global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt) ? global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n        if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === \"bigint\") {\n            startRange = Number(startRange);\n        }\n        if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === \"bigint\") {\n            endRange = Number(endRange);\n        }\n        var length;\n        if (typeof endRange === \"bigint\" || typeof startRange === \"bigint\") {\n            length = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(endRange) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(startRange) + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n        } else {\n            length = endRange - startRange + 1;\n        }\n        if (typeof length === \"bigint\" && length < Number.MAX_SAFE_INTEGER) {\n            length = Number(length);\n        } // byterange should be inclusive according to\n        // RFC 2616, Clause 14.35.1\n        segment.byterange = {\n            length: length,\n            offset: startRange\n        };\n    }\n    return segment;\n};\nvar byteRangeToString = function byteRangeToString(byterange) {\n    // `endRange` is one less than `offset + length` because the HTTP range\n    // header uses inclusive ranges\n    var endRange;\n    if (typeof byterange.offset === \"bigint\" || typeof byterange.length === \"bigint\") {\n        endRange = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(byterange.offset) + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(byterange.length) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n    } else {\n        endRange = byterange.offset + byterange.length - 1;\n    }\n    return byterange.offset + \"-\" + endRange;\n};\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */ var parseEndNumber = function parseEndNumber(endNumber) {\n    if (endNumber && typeof endNumber !== \"number\") {\n        endNumber = parseInt(endNumber, 10);\n    }\n    if (isNaN(endNumber)) {\n        return null;\n    }\n    return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */ var segmentRange = {\n    /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */ static: function _static(attributes) {\n        var duration = attributes.duration, _attributes$timescale = attributes.timescale, timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale, sourceDuration = attributes.sourceDuration, periodDuration = attributes.periodDuration;\n        var endNumber = parseEndNumber(attributes.endNumber);\n        var segmentDuration = duration / timescale;\n        if (typeof endNumber === \"number\") {\n            return {\n                start: 0,\n                end: endNumber\n            };\n        }\n        if (typeof periodDuration === \"number\") {\n            return {\n                start: 0,\n                end: periodDuration / segmentDuration\n            };\n        }\n        return {\n            start: 0,\n            end: sourceDuration / segmentDuration\n        };\n    },\n    /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */ dynamic: function dynamic(attributes) {\n        var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime = attributes.availabilityStartTime, _attributes$timescale2 = attributes.timescale, timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, duration = attributes.duration, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp, _attributes$timeShift = attributes.timeShiftBufferDepth, timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n        var endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n        // after retrieving UTC server time.\n        var now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n        // Convert the period start time to EPOCH.\n        var periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n        var periodEndWC = now + minimumUpdatePeriod;\n        var periodDuration = periodEndWC - periodStartWC;\n        var segmentCount = Math.ceil(periodDuration * timescale / duration);\n        var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n        var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n        return {\n            start: Math.max(0, availableStart),\n            end: typeof endNumber === \"number\" ? endNumber : Math.min(segmentCount, availableEnd)\n        };\n    }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */ /**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */ var toSegments = function toSegments(attributes) {\n    return function(number) {\n        var duration = attributes.duration, _attributes$timescale3 = attributes.timescale, timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3, periodStart = attributes.periodStart, _attributes$startNumb = attributes.startNumber, startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n        return {\n            number: startNumber + number,\n            duration: duration / timescale,\n            timeline: periodStart,\n            time: number * duration\n        };\n    };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */ var parseByDuration = function parseByDuration(attributes) {\n    var type = attributes.type, duration = attributes.duration, _attributes$timescale4 = attributes.timescale, timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4, periodDuration = attributes.periodDuration, sourceDuration = attributes.sourceDuration;\n    var _segmentRange$type = segmentRange[type](attributes), start = _segmentRange$type.start, end = _segmentRange$type.end;\n    var segments = range(start, end).map(toSegments(attributes));\n    if (type === \"static\") {\n        var index = segments.length - 1; // section is either a period or the full source\n        var sectionDuration = typeof periodDuration === \"number\" ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n        segments[index].duration = sectionDuration - duration / timescale * index;\n    }\n    return segments;\n};\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */ var segmentsFromBase = function segmentsFromBase(attributes) {\n    var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ, sourceDuration = attributes.sourceDuration, _attributes$indexRang = attributes.indexRange, indexRange = _attributes$indexRang === void 0 ? \"\" : _attributes$indexRang, periodStart = attributes.periodStart, presentationTime = attributes.presentationTime, _attributes$number = attributes.number, number = _attributes$number === void 0 ? 0 : _attributes$number, duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n    if (!baseUrl) {\n        throw new Error(errors.NO_BASE_URL);\n    }\n    var initSegment = urlTypeToSegment({\n        baseUrl: baseUrl,\n        source: initialization.sourceURL,\n        range: initialization.range\n    });\n    var segment = urlTypeToSegment({\n        baseUrl: baseUrl,\n        source: baseUrl,\n        indexRange: indexRange\n    });\n    segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n    // (since SegmentBase is only for one total segment)\n    if (duration) {\n        var segmentTimeInfo = parseByDuration(attributes);\n        if (segmentTimeInfo.length) {\n            segment.duration = segmentTimeInfo[0].duration;\n            segment.timeline = segmentTimeInfo[0].timeline;\n        }\n    } else if (sourceDuration) {\n        segment.duration = sourceDuration;\n        segment.timeline = periodStart;\n    } // If presentation time is provided, these segments are being generated by SIDX\n    // references, and should use the time provided. For the general case of SegmentBase,\n    // there should only be one segment in the period, so its presentation time is the same\n    // as its period start.\n    segment.presentationTime = presentationTime || periodStart;\n    segment.number = number;\n    return [\n        segment\n    ];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */ var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {\n    // Retain init segment information\n    var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n    var sourceDuration = playlist.sidx.duration; // Retain source timeline\n    var timeline = playlist.timeline || 0;\n    var sidxByteRange = playlist.sidx.byterange;\n    var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n    var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n    var mediaReferences = sidx.references.filter(function(r) {\n        return r.referenceType !== 1;\n    });\n    var segments = [];\n    var type = playlist.endList ? \"static\" : \"dynamic\";\n    var periodStart = playlist.sidx.timeline;\n    var presentationTime = periodStart;\n    var number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n    var startIndex; // eslint-disable-next-line\n    if (typeof sidx.firstOffset === \"bigint\") {\n        startIndex = global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(sidxEnd) + sidx.firstOffset;\n    } else {\n        startIndex = sidxEnd + sidx.firstOffset;\n    }\n    for(var i = 0; i < mediaReferences.length; i++){\n        var reference = sidx.references[i]; // size of the referenced (sub)segment\n        var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n        // this will be converted to seconds when generating segments\n        var duration = reference.subsegmentDuration; // should be an inclusive range\n        var endIndex = void 0; // eslint-disable-next-line\n        if (typeof startIndex === \"bigint\") {\n            endIndex = startIndex + global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(size) - global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(1);\n        } else {\n            endIndex = startIndex + size - 1;\n        }\n        var indexRange = startIndex + \"-\" + endIndex;\n        var attributes = {\n            baseUrl: baseUrl,\n            timescale: timescale,\n            timeline: timeline,\n            periodStart: periodStart,\n            presentationTime: presentationTime,\n            number: number,\n            duration: duration,\n            sourceDuration: sourceDuration,\n            indexRange: indexRange,\n            type: type\n        };\n        var segment = segmentsFromBase(attributes)[0];\n        if (initSegment) {\n            segment.map = initSegment;\n        }\n        segments.push(segment);\n        if (typeof startIndex === \"bigint\") {\n            startIndex += global_window__WEBPACK_IMPORTED_MODULE_1___default().BigInt(size);\n        } else {\n            startIndex += size;\n        }\n        presentationTime += duration / timescale;\n        number++;\n    }\n    playlist.segments = segments;\n    return playlist;\n};\nvar SUPPORTED_MEDIA_TYPES = [\n    \"AUDIO\",\n    \"SUBTITLES\"\n]; // allow one 60fps frame as leniency (arbitrarily chosen)\nvar TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */ var getUniqueTimelineStarts = function getUniqueTimelineStarts(timelineStarts) {\n    return union(timelineStarts, function(_ref) {\n        var timeline = _ref.timeline;\n        return timeline;\n    }).sort(function(a, b) {\n        return a.timeline > b.timeline ? 1 : -1;\n    });\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */ var findPlaylistWithName = function findPlaylistWithName(playlists, name) {\n    for(var i = 0; i < playlists.length; i++){\n        if (playlists[i].attributes.NAME === name) {\n            return playlists[i];\n        }\n    }\n    return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */ var getMediaGroupPlaylists = function getMediaGroupPlaylists(manifest) {\n    var mediaGroupPlaylists = [];\n    (0,_videojs_vhs_utils_es_media_groups__WEBPACK_IMPORTED_MODULE_2__.forEachMediaGroup)(manifest, SUPPORTED_MEDIA_TYPES, function(properties, type, group, label) {\n        mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n    });\n    return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */ var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist(_ref2) {\n    var playlist = _ref2.playlist, mediaSequence = _ref2.mediaSequence;\n    playlist.mediaSequence = mediaSequence;\n    playlist.segments.forEach(function(segment, index) {\n        segment.number = playlist.mediaSequence + index;\n    });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */ var updateSequenceNumbers = function updateSequenceNumbers(_ref3) {\n    var oldPlaylists = _ref3.oldPlaylists, newPlaylists = _ref3.newPlaylists, timelineStarts = _ref3.timelineStarts;\n    newPlaylists.forEach(function(playlist) {\n        playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref4) {\n            var timeline = _ref4.timeline;\n            return timeline === playlist.timeline;\n        }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n        // (see ISO_23009-1-2012 5.3.5.2).\n        //\n        // If the same Representation existed in a prior Period, it will retain the same NAME.\n        var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n        if (!oldPlaylist) {\n            // Since this is a new playlist, the media sequence values can start from 0 without\n            // consequence.\n            return;\n        } // TODO better support for live SIDX\n        //\n        // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n        // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n        // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n        // not supported when the SIDX properties change on refreshes.\n        //\n        // In the future, if support needs to be added, the merging logic here can be called\n        // after SIDX references are resolved. For now, exit early to prevent exceptions being\n        // thrown due to undefined references.\n        if (playlist.sidx) {\n            return;\n        } // Since we don't yet support early available timelines, we don't need to support\n        // playlists with no segments.\n        var firstNewSegment = playlist.segments[0];\n        var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function(oldSegment) {\n            return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n        }); // No matching segment from the old playlist means the entire playlist was refreshed.\n        // In this case the media sequence should account for this update, and the new segments\n        // should be marked as discontinuous from the prior content, since the last prior\n        // timeline was removed.\n        if (oldMatchingSegmentIndex === -1) {\n            updateMediaSequenceForPlaylist({\n                playlist: playlist,\n                mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n            });\n            playlist.segments[0].discontinuity = true;\n            playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n            //\n            // If the new playlist's timeline is the same as the last seen segment's timeline,\n            // then a discontinuity can be added to identify that there's potentially missing\n            // content. If there's no missing content, the discontinuity should still be rather\n            // harmless. It's possible that if segment durations are accurate enough, that the\n            // existence of a gap can be determined using the presentation times and durations,\n            // but if the segment timing info is off, it may introduce more problems than simply\n            // adding the discontinuity.\n            //\n            // If the new playlist's timeline is different from the last seen segment's timeline,\n            // then a discontinuity can be added to identify that this is the first seen segment\n            // of a new timeline. However, the logic at the start of this function that\n            // determined the disconinuity sequence by timeline index is now off by one (the\n            // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n            // we added it), so the disconinuity sequence must be decremented.\n            //\n            // A period may also have a duration of zero, so the case of no segments is handled\n            // here even though we don't yet support early available periods.\n            if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n                playlist.discontinuitySequence--;\n            }\n            return;\n        } // If the first segment matched with a prior segment on a discontinuity (it's matching\n        // on the first segment of a period), then the discontinuitySequence shouldn't be the\n        // timeline's matching one, but instead should be the one prior, and the first segment\n        // of the new manifest should be marked with a discontinuity.\n        //\n        // The reason for this special case is that discontinuity sequence shows how many\n        // discontinuities have fallen off of the playlist, and discontinuities are marked on\n        // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n        // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n        // sequence, and that first segment is an indicator, but can be removed before that\n        // timeline is gone.\n        var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n        if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n            firstNewSegment.discontinuity = true;\n            playlist.discontinuityStarts.unshift(0);\n            playlist.discontinuitySequence--;\n        }\n        updateMediaSequenceForPlaylist({\n            playlist: playlist,\n            mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n        });\n    });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */ var positionManifestOnTimeline = function positionManifestOnTimeline(_ref5) {\n    var oldManifest = _ref5.oldManifest, newManifest = _ref5.newManifest;\n    // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n    //\n    // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n    //\n    // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n    //\n    // Because of this change, and the difficulty of supporting periods with changing start\n    // times, periods with changing start times are not supported. This makes the logic much\n    // simpler, since periods with the same start time can be considerred the same period\n    // across refreshes.\n    //\n    // To give an example as to the difficulty of handling periods where the start time may\n    // change, if a single period manifest is refreshed with another manifest with a single\n    // period, and both the start and end times are increased, then the only way to determine\n    // if it's a new period or an old one that has changed is to look through the segments of\n    // each playlist and determine the presentation time bounds to find a match. In addition,\n    // if the period start changed to exceed the old period end, then there would be no\n    // match, and it would not be possible to determine whether the refreshed period is a new\n    // one or the old one.\n    var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n    var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n    // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n    // of properties are saved for each seen Period. Even long running live streams won't\n    // generate too many Periods, unless the stream is watched for decades. In the future,\n    // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n    // but it may not become an issue, and the additional info can be useful for debugging.\n    newManifest.timelineStarts = getUniqueTimelineStarts([\n        oldManifest.timelineStarts,\n        newManifest.timelineStarts\n    ]);\n    updateSequenceNumbers({\n        oldPlaylists: oldPlaylists,\n        newPlaylists: newPlaylists,\n        timelineStarts: newManifest.timelineStarts\n    });\n    return newManifest;\n};\nvar generateSidxKey = function generateSidxKey(sidx) {\n    return sidx && sidx.uri + \"-\" + byteRangeToString(sidx.byterange);\n};\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n    var mergedPlaylists = values(playlists.reduce(function(acc, playlist) {\n        // assuming playlist IDs are the same across periods\n        // TODO: handle multiperiod where representation sets are not the same\n        // across periods\n        var name = playlist.attributes.id + (playlist.attributes.lang || \"\");\n        if (!acc[name]) {\n            // First Period\n            acc[name] = playlist;\n            acc[name].attributes.timelineStarts = [];\n        } else {\n            // Subsequent Periods\n            if (playlist.segments) {\n                var _acc$name$segments;\n                // first segment of subsequent periods signal a discontinuity\n                if (playlist.segments[0]) {\n                    playlist.segments[0].discontinuity = true;\n                }\n                (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);\n            } // bubble up contentProtection, this assumes all DRM content\n            // has the same contentProtection\n            if (playlist.attributes.contentProtection) {\n                acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n            }\n        }\n        acc[name].attributes.timelineStarts.push({\n            // Although they represent the same number, it's important to have both to make it\n            // compatible with HLS potentially having a similar attribute.\n            start: playlist.attributes.periodStart,\n            timeline: playlist.attributes.periodStart\n        });\n        return acc;\n    }, {}));\n    return mergedPlaylists.map(function(playlist) {\n        playlist.discontinuityStarts = findIndexes(playlist.segments || [], \"discontinuity\");\n        return playlist;\n    });\n};\nvar addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist(playlist, sidxMapping) {\n    var sidxKey = generateSidxKey(playlist.sidx);\n    var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n    if (sidxMatch) {\n        addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n    }\n    return playlist;\n};\nvar addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists(playlists, sidxMapping) {\n    if (sidxMapping === void 0) {\n        sidxMapping = {};\n    }\n    if (!Object.keys(sidxMapping).length) {\n        return playlists;\n    }\n    for(var i in playlists){\n        playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n    }\n    return playlists;\n};\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref, isAudioOnly) {\n    var _attributes;\n    var attributes = _ref.attributes, segments = _ref.segments, sidx = _ref.sidx, mediaSequence = _ref.mediaSequence, discontinuitySequence = _ref.discontinuitySequence, discontinuityStarts = _ref.discontinuityStarts;\n    var playlist = {\n        attributes: (_attributes = {\n            NAME: attributes.id,\n            BANDWIDTH: attributes.bandwidth,\n            CODECS: attributes.codecs\n        }, _attributes[\"PROGRAM-ID\"] = 1, _attributes),\n        uri: \"\",\n        endList: attributes.type === \"static\",\n        timeline: attributes.periodStart,\n        resolvedUri: \"\",\n        targetDuration: attributes.duration,\n        discontinuitySequence: discontinuitySequence,\n        discontinuityStarts: discontinuityStarts,\n        timelineStarts: attributes.timelineStarts,\n        mediaSequence: mediaSequence,\n        segments: segments\n    };\n    if (attributes.contentProtection) {\n        playlist.contentProtection = attributes.contentProtection;\n    }\n    if (sidx) {\n        playlist.sidx = sidx;\n    }\n    if (isAudioOnly) {\n        playlist.attributes.AUDIO = \"audio\";\n        playlist.attributes.SUBTITLES = \"subs\";\n    }\n    return playlist;\n};\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n    var _m3u8Attributes;\n    var attributes = _ref2.attributes, segments = _ref2.segments, mediaSequence = _ref2.mediaSequence, discontinuityStarts = _ref2.discontinuityStarts, discontinuitySequence = _ref2.discontinuitySequence;\n    if (typeof segments === \"undefined\") {\n        // vtt tracks may use single file in BaseURL\n        segments = [\n            {\n                uri: attributes.baseUrl,\n                timeline: attributes.periodStart,\n                resolvedUri: attributes.baseUrl || \"\",\n                duration: attributes.sourceDuration,\n                number: 0\n            }\n        ]; // targetDuration should be the same duration as the only segment\n        attributes.duration = attributes.sourceDuration;\n    }\n    var m3u8Attributes = (_m3u8Attributes = {\n        NAME: attributes.id,\n        BANDWIDTH: attributes.bandwidth\n    }, _m3u8Attributes[\"PROGRAM-ID\"] = 1, _m3u8Attributes);\n    if (attributes.codecs) {\n        m3u8Attributes.CODECS = attributes.codecs;\n    }\n    return {\n        attributes: m3u8Attributes,\n        uri: \"\",\n        endList: attributes.type === \"static\",\n        timeline: attributes.periodStart,\n        resolvedUri: attributes.baseUrl || \"\",\n        targetDuration: attributes.duration,\n        timelineStarts: attributes.timelineStarts,\n        discontinuityStarts: discontinuityStarts,\n        discontinuitySequence: discontinuitySequence,\n        mediaSequence: mediaSequence,\n        segments: segments\n    };\n};\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping, isAudioOnly) {\n    if (sidxMapping === void 0) {\n        sidxMapping = {};\n    }\n    if (isAudioOnly === void 0) {\n        isAudioOnly = false;\n    }\n    var mainPlaylist;\n    var formattedPlaylists = playlists.reduce(function(a, playlist) {\n        var role = playlist.attributes.role && playlist.attributes.role.value || \"\";\n        var language = playlist.attributes.lang || \"\";\n        var label = playlist.attributes.label || \"main\";\n        if (language && !playlist.attributes.label) {\n            var roleLabel = role ? \" (\" + role + \")\" : \"\";\n            label = \"\" + playlist.attributes.lang + roleLabel;\n        }\n        if (!a[label]) {\n            a[label] = {\n                language: language,\n                autoselect: true,\n                default: role === \"main\",\n                playlists: [],\n                uri: \"\"\n            };\n        }\n        var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n        a[label].playlists.push(formatted);\n        if (typeof mainPlaylist === \"undefined\" && role === \"main\") {\n            mainPlaylist = playlist;\n            mainPlaylist.default = true;\n        }\n        return a;\n    }, {}); // if no playlists have role \"main\", mark the first as main\n    if (!mainPlaylist) {\n        var firstLabel = Object.keys(formattedPlaylists)[0];\n        formattedPlaylists[firstLabel].default = true;\n    }\n    return formattedPlaylists;\n};\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\n    if (sidxMapping === void 0) {\n        sidxMapping = {};\n    }\n    return playlists.reduce(function(a, playlist) {\n        var label = playlist.attributes.lang || \"text\";\n        if (!a[label]) {\n            a[label] = {\n                language: label,\n                default: false,\n                autoselect: false,\n                playlists: [],\n                uri: \"\"\n            };\n        }\n        a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n        return a;\n    }, {});\n};\nvar organizeCaptionServices = function organizeCaptionServices(captionServices) {\n    return captionServices.reduce(function(svcObj, svc) {\n        if (!svc) {\n            return svcObj;\n        }\n        svc.forEach(function(service) {\n            var channel = service.channel, language = service.language;\n            svcObj[language] = {\n                autoselect: false,\n                default: false,\n                instreamId: channel,\n                language: language\n            };\n            if (service.hasOwnProperty(\"aspectRatio\")) {\n                svcObj[language].aspectRatio = service.aspectRatio;\n            }\n            if (service.hasOwnProperty(\"easyReader\")) {\n                svcObj[language].easyReader = service.easyReader;\n            }\n            if (service.hasOwnProperty(\"3D\")) {\n                svcObj[language][\"3D\"] = service[\"3D\"];\n            }\n        });\n        return svcObj;\n    }, {});\n};\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n    var _attributes2;\n    var attributes = _ref3.attributes, segments = _ref3.segments, sidx = _ref3.sidx, discontinuityStarts = _ref3.discontinuityStarts;\n    var playlist = {\n        attributes: (_attributes2 = {\n            NAME: attributes.id,\n            AUDIO: \"audio\",\n            SUBTITLES: \"subs\",\n            RESOLUTION: {\n                width: attributes.width,\n                height: attributes.height\n            },\n            CODECS: attributes.codecs,\n            BANDWIDTH: attributes.bandwidth\n        }, _attributes2[\"PROGRAM-ID\"] = 1, _attributes2),\n        uri: \"\",\n        endList: attributes.type === \"static\",\n        timeline: attributes.periodStart,\n        resolvedUri: \"\",\n        targetDuration: attributes.duration,\n        discontinuityStarts: discontinuityStarts,\n        timelineStarts: attributes.timelineStarts,\n        segments: segments\n    };\n    if (attributes.frameRate) {\n        playlist.attributes[\"FRAME-RATE\"] = attributes.frameRate;\n    }\n    if (attributes.contentProtection) {\n        playlist.contentProtection = attributes.contentProtection;\n    }\n    if (sidx) {\n        playlist.sidx = sidx;\n    }\n    return playlist;\n};\nvar videoOnly = function videoOnly(_ref4) {\n    var attributes = _ref4.attributes;\n    return attributes.mimeType === \"video/mp4\" || attributes.mimeType === \"video/webm\" || attributes.contentType === \"video\";\n};\nvar audioOnly = function audioOnly(_ref5) {\n    var attributes = _ref5.attributes;\n    return attributes.mimeType === \"audio/mp4\" || attributes.mimeType === \"audio/webm\" || attributes.contentType === \"audio\";\n};\nvar vttOnly = function vttOnly(_ref6) {\n    var attributes = _ref6.attributes;\n    return attributes.mimeType === \"text/vtt\" || attributes.contentType === \"text\";\n};\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */ /**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */ var addMediaSequenceValues = function addMediaSequenceValues(playlists, timelineStarts) {\n    // increment all segments sequentially\n    playlists.forEach(function(playlist) {\n        playlist.mediaSequence = 0;\n        playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref7) {\n            var timeline = _ref7.timeline;\n            return timeline === playlist.timeline;\n        });\n        if (!playlist.segments) {\n            return;\n        }\n        playlist.segments.forEach(function(segment, index) {\n            segment.number = index;\n        });\n    });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */ var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists(mediaGroupObject) {\n    if (!mediaGroupObject) {\n        return [];\n    }\n    return Object.keys(mediaGroupObject).reduce(function(acc, label) {\n        var labelContents = mediaGroupObject[label];\n        return acc.concat(labelContents.playlists);\n    }, []);\n};\nvar toM3u8 = function toM3u8(_ref8) {\n    var _mediaGroups;\n    var dashPlaylists = _ref8.dashPlaylists, locations = _ref8.locations, _ref8$sidxMapping = _ref8.sidxMapping, sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping, previousManifest = _ref8.previousManifest;\n    if (!dashPlaylists.length) {\n        return {};\n    } // grab all main manifest attributes\n    var _dashPlaylists$0$attr = dashPlaylists[0].attributes, duration = _dashPlaylists$0$attr.sourceDuration, type = _dashPlaylists$0$attr.type, suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay, minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;\n    var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n    var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n    var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n    var captions = dashPlaylists.map(function(playlist) {\n        return playlist.attributes.captionServices;\n    }).filter(Boolean);\n    var manifest = {\n        allowCache: true,\n        discontinuityStarts: [],\n        segments: [],\n        endList: true,\n        mediaGroups: (_mediaGroups = {\n            AUDIO: {},\n            VIDEO: {}\n        }, _mediaGroups[\"CLOSED-CAPTIONS\"] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n        uri: \"\",\n        duration: duration,\n        playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n    };\n    if (minimumUpdatePeriod >= 0) {\n        manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n    }\n    if (locations) {\n        manifest.locations = locations;\n    }\n    if (type === \"dynamic\") {\n        manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n    }\n    var isAudioOnly = manifest.playlists.length === 0;\n    var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n    var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n    var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n    var playlistTimelineStarts = formattedPlaylists.map(function(_ref9) {\n        var timelineStarts = _ref9.timelineStarts;\n        return timelineStarts;\n    });\n    manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n    addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n    if (organizedAudioGroup) {\n        manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n    }\n    if (organizedVttGroup) {\n        manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n    }\n    if (captions.length) {\n        manifest.mediaGroups[\"CLOSED-CAPTIONS\"].cc = organizeCaptionServices(captions);\n    }\n    if (previousManifest) {\n        return positionManifestOnTimeline({\n            oldManifest: previousManifest,\n            newManifest: manifest\n        });\n    }\n    return manifest;\n};\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */ var getLiveRValue = function getLiveRValue(attributes, time, duration) {\n    var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime = attributes.availabilityStartTime, _attributes$timescale = attributes.timescale, timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n    var now = (NOW + clientOffset) / 1000;\n    var periodStartWC = availabilityStartTime + periodStart;\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */ var parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n    var type = attributes.type, _attributes$minimumUp2 = attributes.minimumUpdatePeriod, minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2, _attributes$media = attributes.media, media = _attributes$media === void 0 ? \"\" : _attributes$media, sourceDuration = attributes.sourceDuration, _attributes$timescale2 = attributes.timescale, timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, _attributes$startNumb = attributes.startNumber, startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb, timeline = attributes.periodStart;\n    var segments = [];\n    var time = -1;\n    for(var sIndex = 0; sIndex < segmentTimeline.length; sIndex++){\n        var S = segmentTimeline[sIndex];\n        var duration = S.d;\n        var repeat = S.r || 0;\n        var segmentTime = S.t || 0;\n        if (time < 0) {\n            // first segment\n            time = segmentTime;\n        }\n        if (segmentTime && segmentTime > time) {\n            // discontinuity\n            // TODO: How to handle this type of discontinuity\n            // timeline++ here would treat it like HLS discontuity and content would\n            // get appended without gap\n            // E.G.\n            //  <S t=\"0\" d=\"1\" />\n            //  <S d=\"1\" />\n            //  <S d=\"1\" />\n            //  <S t=\"5\" d=\"1\" />\n            // would have $Time$ values of [0, 1, 2, 5]\n            // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n            // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n            // does the value of sourceDuration consider this when calculating arbitrary\n            // negative @r repeat value?\n            // E.G. Same elements as above with this added at the end\n            //  <S d=\"1\" r=\"-1\" />\n            //  with a sourceDuration of 10\n            // Would the 2 gaps be included in the time duration calculations resulting in\n            // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n            // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n            time = segmentTime;\n        }\n        var count = void 0;\n        if (repeat < 0) {\n            var nextS = sIndex + 1;\n            if (nextS === segmentTimeline.length) {\n                // last segment\n                if (type === \"dynamic\" && minimumUpdatePeriod > 0 && media.indexOf(\"$Number$\") > 0) {\n                    count = getLiveRValue(attributes, time, duration);\n                } else {\n                    // TODO: This may be incorrect depending on conclusion of TODO above\n                    count = (sourceDuration * timescale - time) / duration;\n                }\n            } else {\n                count = (segmentTimeline[nextS].t - time) / duration;\n            }\n        } else {\n            count = repeat + 1;\n        }\n        var end = startNumber + segments.length + count;\n        var number = startNumber + segments.length;\n        while(number < end){\n            segments.push({\n                number: number,\n                duration: duration / timescale,\n                time: time,\n                timeline: timeline\n            });\n            time += duration;\n            number++;\n        }\n    }\n    return segments;\n};\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */ /**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */ var identifierReplacement = function identifierReplacement(values) {\n    return function(match, identifier, format, width) {\n        if (match === \"$$\") {\n            // escape sequence\n            return \"$\";\n        }\n        if (typeof values[identifier] === \"undefined\") {\n            return match;\n        }\n        var value = \"\" + values[identifier];\n        if (identifier === \"RepresentationID\") {\n            // Format tag shall not be present with RepresentationID\n            return value;\n        }\n        if (!format) {\n            width = 1;\n        } else {\n            width = parseInt(width, 10);\n        }\n        if (value.length >= width) {\n            return value;\n        }\n        return \"\" + new Array(width - value.length + 1).join(\"0\") + value;\n    };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */ var constructTemplateUrl = function constructTemplateUrl(url, values) {\n    return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */ var parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n    if (!attributes.duration && !segmentTimeline) {\n        // if neither @duration or SegmentTimeline are present, then there shall be exactly\n        // one media segment\n        return [\n            {\n                number: attributes.startNumber || 1,\n                duration: attributes.sourceDuration,\n                time: 0,\n                timeline: attributes.periodStart\n            }\n        ];\n    }\n    if (attributes.duration) {\n        return parseByDuration(attributes);\n    }\n    return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */ var segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n    var templateValues = {\n        RepresentationID: attributes.id,\n        Bandwidth: attributes.bandwidth || 0\n    };\n    var _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {\n        sourceURL: \"\",\n        range: \"\"\n    } : _attributes$initializ;\n    var mapSegment = urlTypeToSegment({\n        baseUrl: attributes.baseUrl,\n        source: constructTemplateUrl(initialization.sourceURL, templateValues),\n        range: initialization.range\n    });\n    var segments = parseTemplateInfo(attributes, segmentTimeline);\n    return segments.map(function(segment) {\n        templateValues.Number = segment.number;\n        templateValues.Time = segment.time;\n        var uri = constructTemplateUrl(attributes.media || \"\", templateValues); // See DASH spec section 5.3.9.2.2\n        // - if timescale isn't present on any level, default to 1.\n        var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n        var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n        var presentationTime = // calculated in mpd-parser prior to this, so it's assumed to be available.\n        attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n        var map = {\n            uri: uri,\n            timeline: segment.timeline,\n            duration: segment.duration,\n            resolvedUri: (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(attributes.baseUrl || \"\", uri),\n            map: mapSegment,\n            number: segment.number,\n            presentationTime: presentationTime\n        };\n        return map;\n    });\n};\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */ var SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n    var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n    var initSegment = urlTypeToSegment({\n        baseUrl: baseUrl,\n        source: initialization.sourceURL,\n        range: initialization.range\n    });\n    var segment = urlTypeToSegment({\n        baseUrl: baseUrl,\n        source: segmentUrl.media,\n        range: segmentUrl.mediaRange\n    });\n    segment.map = initSegment;\n    return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */ var segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n    var duration = attributes.duration, _attributes$segmentUr = attributes.segmentUrls, segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr, periodStart = attributes.periodStart; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n    // if both SegmentTimeline and @duration are defined, it is outside of spec.\n    if (!duration && !segmentTimeline || duration && segmentTimeline) {\n        throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n    }\n    var segmentUrlMap = segmentUrls.map(function(segmentUrlObject) {\n        return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n    });\n    var segmentTimeInfo;\n    if (duration) {\n        segmentTimeInfo = parseByDuration(attributes);\n    }\n    if (segmentTimeline) {\n        segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n    }\n    var segments = segmentTimeInfo.map(function(segmentTime, index) {\n        if (segmentUrlMap[index]) {\n            var segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n            // - if timescale isn't present on any level, default to 1.\n            var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n            var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n            segment.timeline = segmentTime.timeline;\n            segment.duration = segmentTime.duration;\n            segment.number = segmentTime.number;\n            segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n            return segment;\n        } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n    }).filter(function(segment) {\n        return segment;\n    });\n    return segments;\n};\nvar generateSegments = function generateSegments(_ref) {\n    var attributes = _ref.attributes, segmentInfo = _ref.segmentInfo;\n    var segmentAttributes;\n    var segmentsFn;\n    if (segmentInfo.template) {\n        segmentsFn = segmentsFromTemplate;\n        segmentAttributes = merge(attributes, segmentInfo.template);\n    } else if (segmentInfo.base) {\n        segmentsFn = segmentsFromBase;\n        segmentAttributes = merge(attributes, segmentInfo.base);\n    } else if (segmentInfo.list) {\n        segmentsFn = segmentsFromList;\n        segmentAttributes = merge(attributes, segmentInfo.list);\n    }\n    var segmentsInfo = {\n        attributes: attributes\n    };\n    if (!segmentsFn) {\n        return segmentsInfo;\n    }\n    var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n    // must be in seconds. Since we've generated the segment list, we no longer need\n    // @duration to be in @timescale units, so we can convert it here.\n    if (segmentAttributes.duration) {\n        var _segmentAttributes = segmentAttributes, duration = _segmentAttributes.duration, _segmentAttributes$ti = _segmentAttributes.timescale, timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n        segmentAttributes.duration = duration / timescale;\n    } else if (segments.length) {\n        // if there is no @duration attribute, use the largest segment duration as\n        // as target duration\n        segmentAttributes.duration = segments.reduce(function(max, segment) {\n            return Math.max(max, Math.ceil(segment.duration));\n        }, 0);\n    } else {\n        segmentAttributes.duration = 0;\n    }\n    segmentsInfo.attributes = segmentAttributes;\n    segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n    if (segmentInfo.base && segmentAttributes.indexRange) {\n        segmentsInfo.sidx = segments[0];\n        segmentsInfo.segments = [];\n    }\n    return segmentsInfo;\n};\nvar toPlaylists = function toPlaylists(representations) {\n    return representations.map(generateSegments);\n};\nvar findChildren = function findChildren(element, name) {\n    return from(element.childNodes).filter(function(_ref) {\n        var tagName = _ref.tagName;\n        return tagName === name;\n    });\n};\nvar getContent = function getContent(element) {\n    return element.textContent.trim();\n};\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */ var parseDivisionValue = function parseDivisionValue(value) {\n    return parseFloat(value.split(\"/\").reduce(function(prev, current) {\n        return prev / current;\n    }));\n};\nvar parseDuration = function parseDuration(str) {\n    var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n    var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n    var SECONDS_IN_DAY = 24 * 60 * 60;\n    var SECONDS_IN_HOUR = 60 * 60;\n    var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n    var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n    var match = durationRegex.exec(str);\n    if (!match) {\n        return 0;\n    }\n    var _match$slice = match.slice(1), year = _match$slice[0], month = _match$slice[1], day = _match$slice[2], hour = _match$slice[3], minute = _match$slice[4], second = _match$slice[5];\n    return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nvar parseDate = function parseDate(str) {\n    // Date format without timezone according to ISO 8601\n    // YYY-MM-DDThh:mm:ss.ssssss\n    var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n    // expressed by ending with 'Z'\n    if (dateRegex.test(str)) {\n        str += \"Z\";\n    }\n    return Date.parse(str);\n};\nvar parsers = {\n    /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */ mediaPresentationDuration: function mediaPresentationDuration(value) {\n        return parseDuration(value);\n    },\n    /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */ availabilityStartTime: function availabilityStartTime(value) {\n        return parseDate(value) / 1000;\n    },\n    /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */ minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n        return parseDuration(value);\n    },\n    /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */ suggestedPresentationDelay: function suggestedPresentationDelay(value) {\n        return parseDuration(value);\n    },\n    /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */ type: function type(value) {\n        return value;\n    },\n    /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */ timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n        return parseDuration(value);\n    },\n    /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */ start: function start(value) {\n        return parseDuration(value);\n    },\n    /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */ width: function width(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */ height: function height(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */ bandwidth: function bandwidth(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */ frameRate: function frameRate(value) {\n        return parseDivisionValue(value);\n    },\n    /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */ startNumber: function startNumber(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */ timescale: function timescale(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */ presentationTimeOffset: function presentationTimeOffset(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */ duration: function duration(value) {\n        var parsedValue = parseInt(value, 10);\n        if (isNaN(parsedValue)) {\n            return parseDuration(value);\n        }\n        return parsedValue;\n    },\n    /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */ d: function d(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */ t: function t(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */ r: function r(value) {\n        return parseInt(value, 10);\n    },\n    /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */ DEFAULT: function DEFAULT(value) {\n        return value;\n    }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */ var parseAttributes = function parseAttributes(el) {\n    if (!(el && el.attributes)) {\n        return {};\n    }\n    return from(el.attributes).reduce(function(a, e) {\n        var parseFn = parsers[e.name] || parsers.DEFAULT;\n        a[e.name] = parseFn(e.value);\n        return a;\n    }, {});\n};\nvar keySystemsMap = {\n    \"urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b\": \"org.w3.clearkey\",\n    \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\": \"com.widevine.alpha\",\n    \"urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95\": \"com.microsoft.playready\",\n    \"urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb\": \"com.adobe.primetime\"\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */ var buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n    if (!baseUrlElements.length) {\n        return referenceUrls;\n    }\n    return flatten(referenceUrls.map(function(reference) {\n        return baseUrlElements.map(function(baseUrlElement) {\n            return (0,_videojs_vhs_utils_es_resolve_url__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(reference, getContent(baseUrlElement));\n        });\n    }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */ /**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */ var getSegmentInformation = function getSegmentInformation(adaptationSet) {\n    var segmentTemplate = findChildren(adaptationSet, \"SegmentTemplate\")[0];\n    var segmentList = findChildren(adaptationSet, \"SegmentList\")[0];\n    var segmentUrls = segmentList && findChildren(segmentList, \"SegmentURL\").map(function(s) {\n        return merge({\n            tag: \"SegmentURL\"\n        }, parseAttributes(s));\n    });\n    var segmentBase = findChildren(adaptationSet, \"SegmentBase\")[0];\n    var segmentTimelineParentNode = segmentList || segmentTemplate;\n    var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, \"SegmentTimeline\")[0];\n    var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n    var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, \"Initialization\")[0]; // SegmentTemplate is handled slightly differently, since it can have both\n    // @initialization and an <Initialization> node.  @initialization can be templated,\n    // while the node can have a url and range specified.  If the <SegmentTemplate> has\n    // both @initialization and an <Initialization> subelement we opt to override with\n    // the node, as this interaction is not defined in the spec.\n    var template = segmentTemplate && parseAttributes(segmentTemplate);\n    if (template && segmentInitialization) {\n        template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n    } else if (template && template.initialization) {\n        // If it is @initialization we convert it to an object since this is the format that\n        // later functions will rely on for the initialization segment.  This is only valid\n        // for <SegmentTemplate>\n        template.initialization = {\n            sourceURL: template.initialization\n        };\n    }\n    var segmentInfo = {\n        template: template,\n        segmentTimeline: segmentTimeline && findChildren(segmentTimeline, \"S\").map(function(s) {\n            return parseAttributes(s);\n        }),\n        list: segmentList && merge(parseAttributes(segmentList), {\n            segmentUrls: segmentUrls,\n            initialization: parseAttributes(segmentInitialization)\n        }),\n        base: segmentBase && merge(parseAttributes(segmentBase), {\n            initialization: parseAttributes(segmentInitialization)\n        })\n    };\n    Object.keys(segmentInfo).forEach(function(key) {\n        if (!segmentInfo[key]) {\n            delete segmentInfo[key];\n        }\n    });\n    return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */ /**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */ /**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */ var inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n    return function(representation) {\n        var repBaseUrlElements = findChildren(representation, \"BaseURL\");\n        var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n        var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n        var representationSegmentInfo = getSegmentInformation(representation);\n        return repBaseUrls.map(function(baseUrl) {\n            return {\n                segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n                attributes: merge(attributes, {\n                    baseUrl: baseUrl\n                })\n            };\n        });\n    };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */ var generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n    return contentProtectionNodes.reduce(function(acc, node) {\n        var attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n        // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n        // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n        // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n        if (attributes.schemeIdUri) {\n            attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n        }\n        var keySystem = keySystemsMap[attributes.schemeIdUri];\n        if (keySystem) {\n            acc[keySystem] = {\n                attributes: attributes\n            };\n            var psshNode = findChildren(node, \"cenc:pssh\")[0];\n            if (psshNode) {\n                var pssh = getContent(psshNode);\n                acc[keySystem].pssh = pssh && (0,_videojs_vhs_utils_es_decode_b64_to_uint8_array__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(pssh);\n            }\n        }\n        return acc;\n    }, {});\n}; // defined in ANSI_SCTE 214-1 2016\nvar parseCaptionServiceMetadata = function parseCaptionServiceMetadata(service) {\n    // 608 captions\n    if (service.schemeIdUri === \"urn:scte:dash:cc:cea-608:2015\") {\n        var values = typeof service.value !== \"string\" ? [] : service.value.split(\";\");\n        return values.map(function(value) {\n            var channel;\n            var language; // default language to value\n            language = value;\n            if (/^CC\\d=/.test(value)) {\n                var _value$split = value.split(\"=\");\n                channel = _value$split[0];\n                language = _value$split[1];\n            } else if (/^CC\\d$/.test(value)) {\n                channel = value;\n            }\n            return {\n                channel: channel,\n                language: language\n            };\n        });\n    } else if (service.schemeIdUri === \"urn:scte:dash:cc:cea-708:2015\") {\n        var _values = typeof service.value !== \"string\" ? [] : service.value.split(\";\");\n        return _values.map(function(value) {\n            var flags = {\n                // service or channel number 1-63\n                \"channel\": undefined,\n                // language is a 3ALPHA per ISO 639.2/B\n                // field is required\n                \"language\": undefined,\n                // BIT 1/0 or ?\n                // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n                \"aspectRatio\": 1,\n                // BIT 1/0\n                // easy reader flag indicated the text is tailed to the needs of beginning readers\n                // default 0, or off\n                \"easyReader\": 0,\n                // BIT 1/0\n                // If 3d metadata is present (CEA-708.1) then 1\n                // default 0\n                \"3D\": 0\n            };\n            if (/=/.test(value)) {\n                var _value$split2 = value.split(\"=\"), channel = _value$split2[0], _value$split2$ = _value$split2[1], opts = _value$split2$ === void 0 ? \"\" : _value$split2$;\n                flags.channel = channel;\n                flags.language = value;\n                opts.split(\",\").forEach(function(opt) {\n                    var _opt$split = opt.split(\":\"), name = _opt$split[0], val = _opt$split[1];\n                    if (name === \"lang\") {\n                        flags.language = val; // er for easyReadery\n                    } else if (name === \"er\") {\n                        flags.easyReader = Number(val); // war for wide aspect ratio\n                    } else if (name === \"war\") {\n                        flags.aspectRatio = Number(val);\n                    } else if (name === \"3D\") {\n                        flags[\"3D\"] = Number(val);\n                    }\n                });\n            } else {\n                flags.language = value;\n            }\n            if (flags.channel) {\n                flags.channel = \"SERVICE\" + flags.channel;\n            }\n            return flags;\n        });\n    }\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */ /**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */ var toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n    return function(adaptationSet) {\n        var adaptationSetAttributes = parseAttributes(adaptationSet);\n        var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, \"BaseURL\"));\n        var role = findChildren(adaptationSet, \"Role\")[0];\n        var roleAttributes = {\n            role: parseAttributes(role)\n        };\n        var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n        var accessibility = findChildren(adaptationSet, \"Accessibility\")[0];\n        var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n        if (captionServices) {\n            attrs = merge(attrs, {\n                captionServices: captionServices\n            });\n        }\n        var label = findChildren(adaptationSet, \"Label\")[0];\n        if (label && label.childNodes.length) {\n            var labelVal = label.childNodes[0].nodeValue.trim();\n            attrs = merge(attrs, {\n                label: labelVal\n            });\n        }\n        var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, \"ContentProtection\"));\n        if (Object.keys(contentProtection).length) {\n            attrs = merge(attrs, {\n                contentProtection: contentProtection\n            });\n        }\n        var segmentInfo = getSegmentInformation(adaptationSet);\n        var representations = findChildren(adaptationSet, \"Representation\");\n        var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n        return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n    };\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */ /**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */ /**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */ var toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n    return function(period, index) {\n        var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, \"BaseURL\"));\n        var periodAttributes = merge(mpdAttributes, {\n            periodStart: period.attributes.start\n        });\n        if (typeof period.attributes.duration === \"number\") {\n            periodAttributes.periodDuration = period.attributes.duration;\n        }\n        var adaptationSets = findChildren(period.node, \"AdaptationSet\");\n        var periodSegmentInfo = getSegmentInformation(period.node);\n        return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n    };\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */ var getPeriodStart = function getPeriodStart(_ref) {\n    var attributes = _ref.attributes, priorPeriodAttributes = _ref.priorPeriodAttributes, mpdType = _ref.mpdType;\n    // Summary of period start time calculation from DASH spec section 5.3.2.1\n    //\n    // A period's start is the first period's start + time elapsed after playing all\n    // prior periods to this one. Periods continue one after the other in time (without\n    // gaps) until the end of the presentation.\n    //\n    // The value of Period@start should be:\n    // 1. if Period@start is present: value of Period@start\n    // 2. if previous period exists and it has @duration: previous Period@start +\n    //    previous Period@duration\n    // 3. if this is first period and MPD@type is 'static': 0\n    // 4. in all other cases, consider the period an \"early available period\" (note: not\n    //    currently supported)\n    // (1)\n    if (typeof attributes.start === \"number\") {\n        return attributes.start;\n    } // (2)\n    if (priorPeriodAttributes && typeof priorPeriodAttributes.start === \"number\" && typeof priorPeriodAttributes.duration === \"number\") {\n        return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n    } // (3)\n    if (!priorPeriodAttributes && mpdType === \"static\") {\n        return 0;\n    } // (4)\n    // There is currently no logic for calculating the Period@start value if there is\n    // no Period@start or prior Period@start and Period@duration available. This is not made\n    // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n    // nothing about any other resolution strategies, it's implied. Thus, this case should\n    // be considered an early available period, or error, and null should suffice for both\n    // of those cases.\n    return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */ var inheritAttributes = function inheritAttributes(mpd, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$manifestUri = _options.manifestUri, manifestUri = _options$manifestUri === void 0 ? \"\" : _options$manifestUri, _options$NOW = _options.NOW, NOW = _options$NOW === void 0 ? Date.now() : _options$NOW, _options$clientOffset = _options.clientOffset, clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n    var periodNodes = findChildren(mpd, \"Period\");\n    if (!periodNodes.length) {\n        throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n    }\n    var locations = findChildren(mpd, \"Location\");\n    var mpdAttributes = parseAttributes(mpd);\n    var mpdBaseUrls = buildBaseUrls([\n        manifestUri\n    ], findChildren(mpd, \"BaseURL\")); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n    mpdAttributes.type = mpdAttributes.type || \"static\";\n    mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n    mpdAttributes.NOW = NOW;\n    mpdAttributes.clientOffset = clientOffset;\n    if (locations.length) {\n        mpdAttributes.locations = locations.map(getContent);\n    }\n    var periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n    // adding properties that require looking at prior periods is to parse attributes and add\n    // missing ones before toAdaptationSets is called. If more such properties are added, it\n    // may be better to refactor toAdaptationSets.\n    periodNodes.forEach(function(node, index) {\n        var attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n        // for this period.\n        var priorPeriod = periods[index - 1];\n        attributes.start = getPeriodStart({\n            attributes: attributes,\n            priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n            mpdType: mpdAttributes.type\n        });\n        periods.push({\n            node: node,\n            attributes: attributes\n        });\n    });\n    return {\n        locations: mpdAttributes.locations,\n        representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n    };\n};\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n    if (manifestString === \"\") {\n        throw new Error(errors.DASH_EMPTY_MANIFEST);\n    }\n    var parser = new _xmldom_xmldom__WEBPACK_IMPORTED_MODULE_4__.DOMParser();\n    var xml;\n    var mpd;\n    try {\n        xml = parser.parseFromString(manifestString, \"application/xml\");\n        mpd = xml && xml.documentElement.tagName === \"MPD\" ? xml.documentElement : null;\n    } catch (e) {}\n    if (!mpd || mpd && mpd.getElementsByTagName(\"parsererror\").length > 0) {\n        throw new Error(errors.DASH_INVALID_XML);\n    }\n    return mpd;\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */ var parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n    var UTCTimingNode = findChildren(mpd, \"UTCTiming\")[0];\n    if (!UTCTimingNode) {\n        return null;\n    }\n    var attributes = parseAttributes(UTCTimingNode);\n    switch(attributes.schemeIdUri){\n        case \"urn:mpeg:dash:utc:http-head:2014\":\n        case \"urn:mpeg:dash:utc:http-head:2012\":\n            attributes.method = \"HEAD\";\n            break;\n        case \"urn:mpeg:dash:utc:http-xsdate:2014\":\n        case \"urn:mpeg:dash:utc:http-iso:2014\":\n        case \"urn:mpeg:dash:utc:http-xsdate:2012\":\n        case \"urn:mpeg:dash:utc:http-iso:2012\":\n            attributes.method = \"GET\";\n            break;\n        case \"urn:mpeg:dash:utc:direct:2014\":\n        case \"urn:mpeg:dash:utc:direct:2012\":\n            attributes.method = \"DIRECT\";\n            attributes.value = Date.parse(attributes.value);\n            break;\n        case \"urn:mpeg:dash:utc:http-ntp:2014\":\n        case \"urn:mpeg:dash:utc:ntp:2014\":\n        case \"urn:mpeg:dash:utc:sntp:2014\":\n        default:\n            throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n    }\n    return attributes;\n};\nvar VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */ var parse = function parse(manifestString, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n    var playlists = toPlaylists(parsedManifestInfo.representationInfo);\n    return toM3u8({\n        dashPlaylists: playlists,\n        locations: parsedManifestInfo.locations,\n        sidxMapping: options.sidxMapping,\n        previousManifest: options.previousManifest\n    });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */ var parseUTCTiming = function parseUTCTiming(manifestString) {\n    return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL21wZC1wYXJzZXIvZGlzdC9tcGQtcGFyc2VyLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlEQUF5RCxHQUNFO0FBQ3hCO0FBQ29DO0FBQ2E7QUFDekM7QUFFM0MsSUFBSUssVUFBVTtBQUVkLElBQUlDLFdBQVcsU0FBU0EsU0FBU0MsR0FBRztJQUNsQyxPQUFPLENBQUMsQ0FBQ0EsT0FBTyxPQUFPQSxRQUFRO0FBQ2pDO0FBRUEsSUFBSUMsUUFBUSxTQUFTQTtJQUNuQixJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsVUFBVSxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7UUFDMUZGLE9BQU8sQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7SUFDakM7SUFFQSxPQUFPRixRQUFRRyxNQUFNLENBQUMsU0FBVUMsTUFBTSxFQUFFQyxNQUFNO1FBQzVDLElBQUksT0FBT0EsV0FBVyxVQUFVO1lBQzlCLE9BQU9EO1FBQ1Q7UUFFQUUsT0FBT0MsSUFBSSxDQUFDRixRQUFRRyxPQUFPLENBQUMsU0FBVUMsR0FBRztZQUN2QyxJQUFJUixNQUFNUyxPQUFPLENBQUNOLE1BQU0sQ0FBQ0ssSUFBSSxLQUFLUixNQUFNUyxPQUFPLENBQUNMLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHO2dCQUM1REwsTUFBTSxDQUFDSyxJQUFJLEdBQUdMLE1BQU0sQ0FBQ0ssSUFBSSxDQUFDRSxNQUFNLENBQUNOLE1BQU0sQ0FBQ0ksSUFBSTtZQUM5QyxPQUFPLElBQUlmLFNBQVNVLE1BQU0sQ0FBQ0ssSUFBSSxLQUFLZixTQUFTVyxNQUFNLENBQUNJLElBQUksR0FBRztnQkFDekRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHYixNQUFNUSxNQUFNLENBQUNLLElBQUksRUFBRUosTUFBTSxDQUFDSSxJQUFJO1lBQzlDLE9BQU87Z0JBQ0xMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFH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R0FBRztZQUNwQjtRQUVGLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDSGpYLFdBQVdpWCxNQUFNLEdBQUc7WUFDcEI7UUFFRixLQUFLO1FBQ0wsS0FBSztZQUNIalgsV0FBV2lYLE1BQU0sR0FBRztZQUNwQmpYLFdBQVc0SSxLQUFLLEdBQUc2SSxLQUFLQyxLQUFLLENBQUMxUixXQUFXNEksS0FBSztZQUM5QztRQUVGLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMO1lBQ0UsTUFBTSxJQUFJMUYsTUFBTXZGLE9BQU9PLDZCQUE2QjtJQUN4RDtJQUVBLE9BQU84QjtBQUNUO0FBRUEsSUFBSWtYLFVBQVVuYztBQUNkOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVELElBQUkyVyxRQUFRLFNBQVNBLE1BQU0rRSxjQUFjLEVBQUVYLE9BQU87SUFDaEQsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBRUEsSUFBSXFCLHFCQUFxQnZCLGtCQUFrQlksZUFBZUMsaUJBQWlCWDtJQUMzRSxJQUFJN1EsWUFBWXVLLFlBQVkySCxtQkFBbUJaLGtCQUFrQjtJQUNqRSxPQUFPeEwsT0FBTztRQUNaRyxlQUFlakc7UUFDZmtHLFdBQVdnTSxtQkFBbUJoTSxTQUFTO1FBQ3ZDNUQsYUFBYXVPLFFBQVF2TyxXQUFXO1FBQ2hDOEQsa0JBQWtCeUssUUFBUXpLLGdCQUFnQjtJQUM1QztBQUNGO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUdELElBQUkrTCxpQkFBaUIsU0FBU0EsZUFBZVgsY0FBYztJQUN6RCxPQUFPTSxxQkFBcUJQLGVBQWVDO0FBQzdDO0FBRTZLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnJlZXplLW5leHQvLi4vbm9kZV9tb2R1bGVzL21wZC1wYXJzZXIvZGlzdC9tcGQtcGFyc2VyLmVzLmpzPzBiNzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBuYW1lIG1wZC1wYXJzZXIgQHZlcnNpb24gMC4yMi4xIEBsaWNlbnNlIEFwYWNoZS0yLjAgKi9cbmltcG9ydCByZXNvbHZlVXJsIGZyb20gJ0B2aWRlb2pzL3Zocy11dGlscy9lcy9yZXNvbHZlLXVybCc7XG5pbXBvcnQgd2luZG93IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IHsgZm9yRWFjaE1lZGlhR3JvdXAgfSBmcm9tICdAdmlkZW9qcy92aHMtdXRpbHMvZXMvbWVkaWEtZ3JvdXBzJztcbmltcG9ydCBkZWNvZGVCNjRUb1VpbnQ4QXJyYXkgZnJvbSAnQHZpZGVvanMvdmhzLXV0aWxzL2VzL2RlY29kZS1iNjQtdG8tdWludDgtYXJyYXknO1xuaW1wb3J0IHsgRE9NUGFyc2VyIH0gZnJvbSAnQHhtbGRvbS94bWxkb20nO1xuXG52YXIgdmVyc2lvbiA9IFwiMC4yMi4xXCI7XG5cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9iamVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgb2JqZWN0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3RzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHJlc3VsdFtrZXldLmNvbmNhdChzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59O1xudmFyIHZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyhvKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gb1trXTtcbiAgfSk7XG59O1xuXG52YXIgcmFuZ2UgPSBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4obGlzdHMpIHtcbiAgcmV0dXJuIGxpc3RzLnJlZHVjZShmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB4LmNvbmNhdCh5KTtcbiAgfSwgW10pO1xufTtcbnZhciBmcm9tID0gZnVuY3Rpb24gZnJvbShsaXN0KSB7XG4gIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2gobGlzdFtpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBmaW5kSW5kZXhlcyA9IGZ1bmN0aW9uIGZpbmRJbmRleGVzKGwsIGtleSkge1xuICByZXR1cm4gbC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGUsIGkpIHtcbiAgICBpZiAoZVtrZXldKSB7XG4gICAgICBhLnB1c2goaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0sIFtdKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IHRoYXQgc2F0aXNmaWVzIHRoZSBtYXRjaGluZyBmdW5jdGlvbiwgb3IgLTEgaWYgbm90IGZvdW5kLlxuICpcbiAqIE9ubHkgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgSUUxMSBzdXBwb3J0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgLSB0aGUgbGlzdCB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWF0Y2hpbmdGdW5jdGlvbiAtIHRoZSBtYXRjaGluZyBmdW5jdGlvblxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG1hdGNoaW5nIGluZGV4IG9yIC0xIGlmIG5vdCBmb3VuZFxuICovXG5cbnZhciBmaW5kSW5kZXggPSBmdW5jdGlvbiBmaW5kSW5kZXgobGlzdCwgbWF0Y2hpbmdGdW5jdGlvbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWF0Y2hpbmdGdW5jdGlvbihsaXN0W2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogUmV0dXJucyBhIHVuaW9uIG9mIHRoZSBpbmNsdWRlZCBsaXN0cyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgY2FuIGJlIGlkZW50aWZpZWQgYnkgYSBrZXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGxpc3Qgb2YgbGlzdHMgdG8gZ2V0IHRoZSB1bmlvbiBvZlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5RnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gdXNlIGFzIGEga2V5IGZvciBlYWNoIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIHVuaW9uIG9mIHRoZSBhcnJheXNcbiAqL1xuXG52YXIgdW5pb24gPSBmdW5jdGlvbiB1bmlvbihsaXN0cywga2V5RnVuY3Rpb24pIHtcbiAgcmV0dXJuIHZhbHVlcyhsaXN0cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbGlzdCkge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGFjY1trZXlGdW5jdGlvbihlbCldID0gZWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pKTtcbn07XG5cbnZhciBlcnJvcnMgPSB7XG4gIElOVkFMSURfTlVNQkVSX09GX1BFUklPRDogJ0lOVkFMSURfTlVNQkVSX09GX1BFUklPRCcsXG4gIERBU0hfRU1QVFlfTUFOSUZFU1Q6ICdEQVNIX0VNUFRZX01BTklGRVNUJyxcbiAgREFTSF9JTlZBTElEX1hNTDogJ0RBU0hfSU5WQUxJRF9YTUwnLFxuICBOT19CQVNFX1VSTDogJ05PX0JBU0VfVVJMJyxcbiAgTUlTU0lOR19TRUdNRU5UX0lORk9STUFUSU9OOiAnTUlTU0lOR19TRUdNRU5UX0lORk9STUFUSU9OJyxcbiAgU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEOiAnU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEJyxcbiAgVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUU6ICdVTlNVUFBPUlRFRF9VVENfVElNSU5HX1NDSEVNRSdcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2luZ2xlVXJpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJpIC0gcmVsYXRpdmUgbG9jYXRpb24gb2Ygc2VnbWVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc29sdmVkVXJpIC0gcmVzb2x2ZWQgbG9jYXRpb24gb2Ygc2VnbWVudFxuICogQHByb3BlcnR5IHtPYmplY3R9IGJ5dGVyYW5nZSAtIE9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIG9uIGhvdyB0byBtYWtlIGJ5dGUgcmFuZ2VcbiAqICAgcmVxdWVzdHMgZm9sbG93aW5nIGJ5dGUtcmFuZ2Utc3BlYyBwZXIgUkZDMjYxNi5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBieXRlcmFuZ2UubGVuZ3RoIC0gbGVuZ3RoIG9mIHJhbmdlIHJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBieXRlcmFuZ2Uub2Zmc2V0IC0gYnl0ZSBvZmZzZXQgb2YgcmFuZ2UgcmVxdWVzdFxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMTQuaHRtbCNzZWMxNC4zNS4xXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVSTFR5cGUgbm9kZSAoNS4zLjkuMi4zIFRhYmxlIDEzKSB0byBhIHNlZ21lbnQgb2JqZWN0XG4gKiB0aGF0IGNvbmZvcm1zIHRvIGhvdyBtM3U4LXBhcnNlciBpcyBzdHJ1Y3R1cmVkXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy9tM3U4LXBhcnNlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gYmFzZVVybCBwcm92aWRlZCBieSA8QmFzZVVybD4gbm9kZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBzb3VyY2UgdXJsIGZvciBzZWdtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcmFuZ2UgLSBvcHRpb25hbCByYW5nZSB1c2VkIGZvciByYW5nZSBjYWxscyxcbiAqICAgZm9sbG93cyAgUkZDIDI2MTYsIENsYXVzZSAxNC4zNS4xXG4gKiBAcmV0dXJuIHtTaW5nbGVVcml9IGZ1bGwgc2VnbWVudCBpbmZvcm1hdGlvbiB0cmFuc2Zvcm1lZCBpbnRvIGEgZm9ybWF0IHNpbWlsYXJcbiAqICAgdG8gbTN1OC1wYXJzZXJcbiAqL1xuXG52YXIgdXJsVHlwZVRvU2VnbWVudCA9IGZ1bmN0aW9uIHVybFR5cGVUb1NlZ21lbnQoX3JlZikge1xuICB2YXIgX3JlZiRiYXNlVXJsID0gX3JlZi5iYXNlVXJsLFxuICAgICAgYmFzZVVybCA9IF9yZWYkYmFzZVVybCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGJhc2VVcmwsXG4gICAgICBfcmVmJHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZiRzb3VyY2UgPT09IHZvaWQgMCA/ICcnIDogX3JlZiRzb3VyY2UsXG4gICAgICBfcmVmJHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlID0gX3JlZiRyYW5nZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHJhbmdlLFxuICAgICAgX3JlZiRpbmRleFJhbmdlID0gX3JlZi5pbmRleFJhbmdlLFxuICAgICAgaW5kZXhSYW5nZSA9IF9yZWYkaW5kZXhSYW5nZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGluZGV4UmFuZ2U7XG4gIHZhciBzZWdtZW50ID0ge1xuICAgIHVyaTogc291cmNlLFxuICAgIHJlc29sdmVkVXJpOiByZXNvbHZlVXJsKGJhc2VVcmwgfHwgJycsIHNvdXJjZSlcbiAgfTtcblxuICBpZiAocmFuZ2UgfHwgaW5kZXhSYW5nZSkge1xuICAgIHZhciByYW5nZVN0ciA9IHJhbmdlID8gcmFuZ2UgOiBpbmRleFJhbmdlO1xuICAgIHZhciByYW5nZXMgPSByYW5nZVN0ci5zcGxpdCgnLScpOyAvLyBkZWZhdWx0IHRvIHBhcnNpbmcgdGhpcyBhcyBhIEJpZ0ludCBpZiBwb3NzaWJsZVxuXG4gICAgdmFyIHN0YXJ0UmFuZ2UgPSB3aW5kb3cuQmlnSW50ID8gd2luZG93LkJpZ0ludChyYW5nZXNbMF0pIDogcGFyc2VJbnQocmFuZ2VzWzBdLCAxMCk7XG4gICAgdmFyIGVuZFJhbmdlID0gd2luZG93LkJpZ0ludCA/IHdpbmRvdy5CaWdJbnQocmFuZ2VzWzFdKSA6IHBhcnNlSW50KHJhbmdlc1sxXSwgMTApOyAvLyBjb252ZXJ0IGJhY2sgdG8gYSBudW1iZXIgaWYgbGVzcyB0aGFuIE1BWF9TQUZFX0lOVEVHRVJcblxuICAgIGlmIChzdGFydFJhbmdlIDwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgdHlwZW9mIHN0YXJ0UmFuZ2UgPT09ICdiaWdpbnQnKSB7XG4gICAgICBzdGFydFJhbmdlID0gTnVtYmVyKHN0YXJ0UmFuZ2UpO1xuICAgIH1cblxuICAgIGlmIChlbmRSYW5nZSA8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIHR5cGVvZiBlbmRSYW5nZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIGVuZFJhbmdlID0gTnVtYmVyKGVuZFJhbmdlKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBlbmRSYW5nZSA9PT0gJ2JpZ2ludCcgfHwgdHlwZW9mIHN0YXJ0UmFuZ2UgPT09ICdiaWdpbnQnKSB7XG4gICAgICBsZW5ndGggPSB3aW5kb3cuQmlnSW50KGVuZFJhbmdlKSAtIHdpbmRvdy5CaWdJbnQoc3RhcnRSYW5nZSkgKyB3aW5kb3cuQmlnSW50KDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBlbmRSYW5nZSAtIHN0YXJ0UmFuZ2UgKyAxO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnYmlnaW50JyAmJiBsZW5ndGggPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG4gICAgfSAvLyBieXRlcmFuZ2Ugc2hvdWxkIGJlIGluY2x1c2l2ZSBhY2NvcmRpbmcgdG9cbiAgICAvLyBSRkMgMjYxNiwgQ2xhdXNlIDE0LjM1LjFcblxuXG4gICAgc2VnbWVudC5ieXRlcmFuZ2UgPSB7XG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIG9mZnNldDogc3RhcnRSYW5nZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2VnbWVudDtcbn07XG52YXIgYnl0ZVJhbmdlVG9TdHJpbmcgPSBmdW5jdGlvbiBieXRlUmFuZ2VUb1N0cmluZyhieXRlcmFuZ2UpIHtcbiAgLy8gYGVuZFJhbmdlYCBpcyBvbmUgbGVzcyB0aGFuIGBvZmZzZXQgKyBsZW5ndGhgIGJlY2F1c2UgdGhlIEhUVFAgcmFuZ2VcbiAgLy8gaGVhZGVyIHVzZXMgaW5jbHVzaXZlIHJhbmdlc1xuICB2YXIgZW5kUmFuZ2U7XG5cbiAgaWYgKHR5cGVvZiBieXRlcmFuZ2Uub2Zmc2V0ID09PSAnYmlnaW50JyB8fCB0eXBlb2YgYnl0ZXJhbmdlLmxlbmd0aCA9PT0gJ2JpZ2ludCcpIHtcbiAgICBlbmRSYW5nZSA9IHdpbmRvdy5CaWdJbnQoYnl0ZXJhbmdlLm9mZnNldCkgKyB3aW5kb3cuQmlnSW50KGJ5dGVyYW5nZS5sZW5ndGgpIC0gd2luZG93LkJpZ0ludCgxKTtcbiAgfSBlbHNlIHtcbiAgICBlbmRSYW5nZSA9IGJ5dGVyYW5nZS5vZmZzZXQgKyBieXRlcmFuZ2UubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIHJldHVybiBieXRlcmFuZ2Uub2Zmc2V0ICsgXCItXCIgKyBlbmRSYW5nZTtcbn07XG5cbi8qKlxuICogcGFyc2UgdGhlIGVuZCBudW1iZXIgYXR0cmlidWUgdGhhdCBjYW4gYmUgYSBzdHJpbmdcbiAqIG51bWJlciwgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnx1bmRlZmluZWR9IGVuZE51bWJlclxuICogICAgICAgIFRoZSBlbmQgbnVtYmVyIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAqICAgICAgICAgIFRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgZW5kIG51bWJlci5cbiAqL1xuXG52YXIgcGFyc2VFbmROdW1iZXIgPSBmdW5jdGlvbiBwYXJzZUVuZE51bWJlcihlbmROdW1iZXIpIHtcbiAgaWYgKGVuZE51bWJlciAmJiB0eXBlb2YgZW5kTnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgIGVuZE51bWJlciA9IHBhcnNlSW50KGVuZE51bWJlciwgMTApO1xuICB9XG5cbiAgaWYgKGlzTmFOKGVuZE51bWJlcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbmROdW1iZXI7XG59O1xuLyoqXG4gKiBGdW5jdGlvbnMgZm9yIGNhbGN1bGF0aW5nIHRoZSByYW5nZSBvZiBhdmFpbGFibGUgc2VnbWVudHMgaW4gc3RhdGljIGFuZCBkeW5hbWljXG4gKiBtYW5pZmVzdHMuXG4gKi9cblxuXG52YXIgc2VnbWVudFJhbmdlID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW50aXJlIHJhbmdlIG9mIGF2YWlsYWJsZSBzZWdtZW50cyBmb3IgYSBzdGF0aWMgTVBEXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqICAgICAgICBJbmhlcml0aWVkIE1QRCBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3sgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIgfX1cbiAgICogICAgICAgICBUaGUgc3RhcnQgYW5kIGVuZCBudW1iZXJzIGZvciBhdmFpbGFibGUgc2VnbWVudHNcbiAgICovXG4gIHN0YXRpYzogZnVuY3Rpb24gX3N0YXRpYyhhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICAgICAgX2F0dHJpYnV0ZXMkdGltZXNjYWxlID0gYXR0cmlidXRlcy50aW1lc2NhbGUsXG4gICAgICAgIHRpbWVzY2FsZSA9IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZSA9PT0gdm9pZCAwID8gMSA6IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZSxcbiAgICAgICAgc291cmNlRHVyYXRpb24gPSBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uLFxuICAgICAgICBwZXJpb2REdXJhdGlvbiA9IGF0dHJpYnV0ZXMucGVyaW9kRHVyYXRpb247XG4gICAgdmFyIGVuZE51bWJlciA9IHBhcnNlRW5kTnVtYmVyKGF0dHJpYnV0ZXMuZW5kTnVtYmVyKTtcbiAgICB2YXIgc2VnbWVudER1cmF0aW9uID0gZHVyYXRpb24gLyB0aW1lc2NhbGU7XG5cbiAgICBpZiAodHlwZW9mIGVuZE51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IGVuZE51bWJlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBlcmlvZER1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogcGVyaW9kRHVyYXRpb24gLyBzZWdtZW50RHVyYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiBzb3VyY2VEdXJhdGlvbiAvIHNlZ21lbnREdXJhdGlvblxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGl2ZSB3aW5kb3cgcmFuZ2Ugb2YgYXZhaWxhYmxlIHNlZ21lbnRzIGZvciBhIGR5bmFtaWMgTVBEXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqICAgICAgICBJbmhlcml0aWVkIE1QRCBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3sgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIgfX1cbiAgICogICAgICAgICBUaGUgc3RhcnQgYW5kIGVuZCBudW1iZXJzIGZvciBhdmFpbGFibGUgc2VnbWVudHNcbiAgICovXG4gIGR5bmFtaWM6IGZ1bmN0aW9uIGR5bmFtaWMoYXR0cmlidXRlcykge1xuICAgIHZhciBOT1cgPSBhdHRyaWJ1dGVzLk5PVyxcbiAgICAgICAgY2xpZW50T2Zmc2V0ID0gYXR0cmlidXRlcy5jbGllbnRPZmZzZXQsXG4gICAgICAgIGF2YWlsYWJpbGl0eVN0YXJ0VGltZSA9IGF0dHJpYnV0ZXMuYXZhaWxhYmlsaXR5U3RhcnRUaW1lLFxuICAgICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGUyID0gYXR0cmlidXRlcy50aW1lc2NhbGUsXG4gICAgICAgIHRpbWVzY2FsZSA9IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZTIgPT09IHZvaWQgMCA/IDEgOiBfYXR0cmlidXRlcyR0aW1lc2NhbGUyLFxuICAgICAgICBkdXJhdGlvbiA9IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgICAgIF9hdHRyaWJ1dGVzJHBlcmlvZFN0YSA9IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgICAgIHBlcmlvZFN0YXJ0ID0gX2F0dHJpYnV0ZXMkcGVyaW9kU3RhID09PSB2b2lkIDAgPyAwIDogX2F0dHJpYnV0ZXMkcGVyaW9kU3RhLFxuICAgICAgICBfYXR0cmlidXRlcyRtaW5pbXVtVXAgPSBhdHRyaWJ1dGVzLm1pbmltdW1VcGRhdGVQZXJpb2QsXG4gICAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSBfYXR0cmlidXRlcyRtaW5pbXVtVXAgPT09IHZvaWQgMCA/IDAgOiBfYXR0cmlidXRlcyRtaW5pbXVtVXAsXG4gICAgICAgIF9hdHRyaWJ1dGVzJHRpbWVTaGlmdCA9IGF0dHJpYnV0ZXMudGltZVNoaWZ0QnVmZmVyRGVwdGgsXG4gICAgICAgIHRpbWVTaGlmdEJ1ZmZlckRlcHRoID0gX2F0dHJpYnV0ZXMkdGltZVNoaWZ0ID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9hdHRyaWJ1dGVzJHRpbWVTaGlmdDtcbiAgICB2YXIgZW5kTnVtYmVyID0gcGFyc2VFbmROdW1iZXIoYXR0cmlidXRlcy5lbmROdW1iZXIpOyAvLyBjbGllbnRPZmZzZXQgaXMgcGFzc2VkIGluIGF0IHRoZSB0b3AgbGV2ZWwgb2YgbXBkLXBhcnNlciBhbmQgaXMgYW4gb2Zmc2V0IGNhbGN1bGF0ZWRcbiAgICAvLyBhZnRlciByZXRyaWV2aW5nIFVUQyBzZXJ2ZXIgdGltZS5cblxuICAgIHZhciBub3cgPSAoTk9XICsgY2xpZW50T2Zmc2V0KSAvIDEwMDA7IC8vIFdDIHN0YW5kcyBmb3IgV2FsbCBDbG9jay5cbiAgICAvLyBDb252ZXJ0IHRoZSBwZXJpb2Qgc3RhcnQgdGltZSB0byBFUE9DSC5cblxuICAgIHZhciBwZXJpb2RTdGFydFdDID0gYXZhaWxhYmlsaXR5U3RhcnRUaW1lICsgcGVyaW9kU3RhcnQ7IC8vIFBlcmlvZCBlbmQgaW4gRVBPQ0ggaXMgbWFuaWZlc3QncyByZXRyaWV2YWwgdGltZSArIHRpbWUgdW50aWwgbmV4dCB1cGRhdGUuXG5cbiAgICB2YXIgcGVyaW9kRW5kV0MgPSBub3cgKyBtaW5pbXVtVXBkYXRlUGVyaW9kO1xuICAgIHZhciBwZXJpb2REdXJhdGlvbiA9IHBlcmlvZEVuZFdDIC0gcGVyaW9kU3RhcnRXQztcbiAgICB2YXIgc2VnbWVudENvdW50ID0gTWF0aC5jZWlsKHBlcmlvZER1cmF0aW9uICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIHZhciBhdmFpbGFibGVTdGFydCA9IE1hdGguZmxvb3IoKG5vdyAtIHBlcmlvZFN0YXJ0V0MgLSB0aW1lU2hpZnRCdWZmZXJEZXB0aCkgKiB0aW1lc2NhbGUgLyBkdXJhdGlvbik7XG4gICAgdmFyIGF2YWlsYWJsZUVuZCA9IE1hdGguZmxvb3IoKG5vdyAtIHBlcmlvZFN0YXJ0V0MpICogdGltZXNjYWxlIC8gZHVyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogTWF0aC5tYXgoMCwgYXZhaWxhYmxlU3RhcnQpLFxuICAgICAgZW5kOiB0eXBlb2YgZW5kTnVtYmVyID09PSAnbnVtYmVyJyA/IGVuZE51bWJlciA6IE1hdGgubWluKHNlZ21lbnRDb3VudCwgYXZhaWxhYmxlRW5kKVxuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIE1hcHMgYSByYW5nZSBvZiBudW1iZXJzIHRvIG9iamVjdHMgd2l0aCBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gYnVpbGQgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIHNlZ21lbnQgbGlzdFxuICpcbiAqIEBuYW1lIHRvU2VnbWVudHNDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKiAgICAgICAgTnVtYmVyIG9mIHRoZSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqICAgICAgICBJbmRleCBvZiB0aGUgbnVtYmVyIGluIHRoZSByYW5nZSBsaXN0XG4gKiBAcmV0dXJuIHt7IG51bWJlcjogTnVtYmVyLCBkdXJhdGlvbjogTnVtYmVyLCB0aW1lbGluZTogTnVtYmVyLCB0aW1lOiBOdW1iZXIgfX1cbiAqICAgICAgICAgT2JqZWN0IHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBjYWxsYmFjayBmb3IgQXJyYXkucHJvdG90eXBlLm1hcCBmb3IgbWFwcGluZyBhIHJhbmdlIG9mIG51bWJlcnMgdG9cbiAqIGluZm9ybWF0aW9uIG5lZWRlZCB0byBidWlsZCB0aGUgc2VnbWVudCBsaXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgSW5oZXJpdGVkIE1QRCBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHt0b1NlZ21lbnRzQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbnZhciB0b1NlZ21lbnRzID0gZnVuY3Rpb24gdG9TZWdtZW50cyhhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICAgICAgX2F0dHJpYnV0ZXMkdGltZXNjYWxlMyA9IGF0dHJpYnV0ZXMudGltZXNjYWxlLFxuICAgICAgICB0aW1lc2NhbGUgPSBfYXR0cmlidXRlcyR0aW1lc2NhbGUzID09PSB2b2lkIDAgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlMyxcbiAgICAgICAgcGVyaW9kU3RhcnQgPSBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgICAgICBfYXR0cmlidXRlcyRzdGFydE51bWIgPSBhdHRyaWJ1dGVzLnN0YXJ0TnVtYmVyLFxuICAgICAgICBzdGFydE51bWJlciA9IF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYiA9PT0gdm9pZCAwID8gMSA6IF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYjtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyOiBzdGFydE51bWJlciArIG51bWJlcixcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgIHRpbWVsaW5lOiBwZXJpb2RTdGFydCxcbiAgICAgIHRpbWU6IG51bWJlciAqIGR1cmF0aW9uXG4gICAgfTtcbiAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBzZWdtZW50IHRpbWluZyBhbmQgZHVyYXRpb24gaW5mbyB1c2VkIGZvclxuICogYnVpbGRpbmcgdGhlIGxpc3Qgb2Ygc2VnbWVudHMuIFRoaXMgdXNlcyB0aGUgQGR1cmF0aW9uIGF0dHJpYnV0ZSBzcGVjaWZpZWRcbiAqIGluIHRoZSBNUEQgbWFuaWZlc3QgdG8gZGVyaXZlIHRoZSByYW5nZSBvZiBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIEluaGVyaXRlZCBNUEQgYXR0cmlidXRlc1xuICogQHJldHVybiB7e251bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHRpbWVsaW5lOiBudW1iZXJ9W119XG4gKiAgICAgICAgIExpc3Qgb2YgT2JqZWN0cyB3aXRoIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvXG4gKi9cblxudmFyIHBhcnNlQnlEdXJhdGlvbiA9IGZ1bmN0aW9uIHBhcnNlQnlEdXJhdGlvbihhdHRyaWJ1dGVzKSB7XG4gIHZhciB0eXBlID0gYXR0cmlidXRlcy50eXBlLFxuICAgICAgZHVyYXRpb24gPSBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgICAgX2F0dHJpYnV0ZXMkdGltZXNjYWxlNCA9IGF0dHJpYnV0ZXMudGltZXNjYWxlLFxuICAgICAgdGltZXNjYWxlID0gX2F0dHJpYnV0ZXMkdGltZXNjYWxlNCA9PT0gdm9pZCAwID8gMSA6IF9hdHRyaWJ1dGVzJHRpbWVzY2FsZTQsXG4gICAgICBwZXJpb2REdXJhdGlvbiA9IGF0dHJpYnV0ZXMucGVyaW9kRHVyYXRpb24sXG4gICAgICBzb3VyY2VEdXJhdGlvbiA9IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb247XG5cbiAgdmFyIF9zZWdtZW50UmFuZ2UkdHlwZSA9IHNlZ21lbnRSYW5nZVt0eXBlXShhdHRyaWJ1dGVzKSxcbiAgICAgIHN0YXJ0ID0gX3NlZ21lbnRSYW5nZSR0eXBlLnN0YXJ0LFxuICAgICAgZW5kID0gX3NlZ21lbnRSYW5nZSR0eXBlLmVuZDtcblxuICB2YXIgc2VnbWVudHMgPSByYW5nZShzdGFydCwgZW5kKS5tYXAodG9TZWdtZW50cyhhdHRyaWJ1dGVzKSk7XG5cbiAgaWYgKHR5cGUgPT09ICdzdGF0aWMnKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHMubGVuZ3RoIC0gMTsgLy8gc2VjdGlvbiBpcyBlaXRoZXIgYSBwZXJpb2Qgb3IgdGhlIGZ1bGwgc291cmNlXG5cbiAgICB2YXIgc2VjdGlvbkR1cmF0aW9uID0gdHlwZW9mIHBlcmlvZER1cmF0aW9uID09PSAnbnVtYmVyJyA/IHBlcmlvZER1cmF0aW9uIDogc291cmNlRHVyYXRpb247IC8vIGZpbmFsIHNlZ21lbnQgbWF5IGJlIGxlc3MgdGhhbiBmdWxsIHNlZ21lbnQgZHVyYXRpb25cblxuICAgIHNlZ21lbnRzW2luZGV4XS5kdXJhdGlvbiA9IHNlY3Rpb25EdXJhdGlvbiAtIGR1cmF0aW9uIC8gdGltZXNjYWxlICogaW5kZXg7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgU2VnbWVudEJhc2UgaW50byBhIHNldCBvZiBzZWdtZW50cy5cbiAqIChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG5cbnZhciBzZWdtZW50c0Zyb21CYXNlID0gZnVuY3Rpb24gc2VnbWVudHNGcm9tQmFzZShhdHRyaWJ1dGVzKSB7XG4gIHZhciBiYXNlVXJsID0gYXR0cmlidXRlcy5iYXNlVXJsLFxuICAgICAgX2F0dHJpYnV0ZXMkaW5pdGlhbGl6ID0gYXR0cmlidXRlcy5pbml0aWFsaXphdGlvbixcbiAgICAgIGluaXRpYWxpemF0aW9uID0gX2F0dHJpYnV0ZXMkaW5pdGlhbGl6ID09PSB2b2lkIDAgPyB7fSA6IF9hdHRyaWJ1dGVzJGluaXRpYWxpeixcbiAgICAgIHNvdXJjZUR1cmF0aW9uID0gYXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbixcbiAgICAgIF9hdHRyaWJ1dGVzJGluZGV4UmFuZyA9IGF0dHJpYnV0ZXMuaW5kZXhSYW5nZSxcbiAgICAgIGluZGV4UmFuZ2UgPSBfYXR0cmlidXRlcyRpbmRleFJhbmcgPT09IHZvaWQgMCA/ICcnIDogX2F0dHJpYnV0ZXMkaW5kZXhSYW5nLFxuICAgICAgcGVyaW9kU3RhcnQgPSBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgICAgcHJlc2VudGF0aW9uVGltZSA9IGF0dHJpYnV0ZXMucHJlc2VudGF0aW9uVGltZSxcbiAgICAgIF9hdHRyaWJ1dGVzJG51bWJlciA9IGF0dHJpYnV0ZXMubnVtYmVyLFxuICAgICAgbnVtYmVyID0gX2F0dHJpYnV0ZXMkbnVtYmVyID09PSB2b2lkIDAgPyAwIDogX2F0dHJpYnV0ZXMkbnVtYmVyLFxuICAgICAgZHVyYXRpb24gPSBhdHRyaWJ1dGVzLmR1cmF0aW9uOyAvLyBiYXNlIHVybCBpcyByZXF1aXJlZCBmb3IgU2VnbWVudEJhc2UgdG8gd29yaywgcGVyIHNwZWMgKFNlY3Rpb24gNS4zLjkuMi4xKVxuXG4gIGlmICghYmFzZVVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuTk9fQkFTRV9VUkwpO1xuICB9XG5cbiAgdmFyIGluaXRTZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybDogYmFzZVVybCxcbiAgICBzb3VyY2U6IGluaXRpYWxpemF0aW9uLnNvdXJjZVVSTCxcbiAgICByYW5nZTogaW5pdGlhbGl6YXRpb24ucmFuZ2VcbiAgfSk7XG4gIHZhciBzZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybDogYmFzZVVybCxcbiAgICBzb3VyY2U6IGJhc2VVcmwsXG4gICAgaW5kZXhSYW5nZTogaW5kZXhSYW5nZVxuICB9KTtcbiAgc2VnbWVudC5tYXAgPSBpbml0U2VnbWVudDsgLy8gSWYgdGhlcmUgaXMgYSBkdXJhdGlvbiwgdXNlIGl0LCBvdGhlcndpc2UgdXNlIHRoZSBnaXZlbiBkdXJhdGlvbiBvZiB0aGUgc291cmNlXG4gIC8vIChzaW5jZSBTZWdtZW50QmFzZSBpcyBvbmx5IGZvciBvbmUgdG90YWwgc2VnbWVudClcblxuICBpZiAoZHVyYXRpb24pIHtcbiAgICB2YXIgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuXG4gICAgaWYgKHNlZ21lbnRUaW1lSW5mby5sZW5ndGgpIHtcbiAgICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzZWdtZW50VGltZUluZm9bMF0uZHVyYXRpb247XG4gICAgICBzZWdtZW50LnRpbWVsaW5lID0gc2VnbWVudFRpbWVJbmZvWzBdLnRpbWVsaW5lO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2VEdXJhdGlvbikge1xuICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzb3VyY2VEdXJhdGlvbjtcbiAgICBzZWdtZW50LnRpbWVsaW5lID0gcGVyaW9kU3RhcnQ7XG4gIH0gLy8gSWYgcHJlc2VudGF0aW9uIHRpbWUgaXMgcHJvdmlkZWQsIHRoZXNlIHNlZ21lbnRzIGFyZSBiZWluZyBnZW5lcmF0ZWQgYnkgU0lEWFxuICAvLyByZWZlcmVuY2VzLCBhbmQgc2hvdWxkIHVzZSB0aGUgdGltZSBwcm92aWRlZC4gRm9yIHRoZSBnZW5lcmFsIGNhc2Ugb2YgU2VnbWVudEJhc2UsXG4gIC8vIHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBzZWdtZW50IGluIHRoZSBwZXJpb2QsIHNvIGl0cyBwcmVzZW50YXRpb24gdGltZSBpcyB0aGUgc2FtZVxuICAvLyBhcyBpdHMgcGVyaW9kIHN0YXJ0LlxuXG5cbiAgc2VnbWVudC5wcmVzZW50YXRpb25UaW1lID0gcHJlc2VudGF0aW9uVGltZSB8fCBwZXJpb2RTdGFydDtcbiAgc2VnbWVudC5udW1iZXIgPSBudW1iZXI7XG4gIHJldHVybiBbc2VnbWVudF07XG59O1xuLyoqXG4gKiBHaXZlbiBhIHBsYXlsaXN0LCBhIHNpZHggYm94LCBhbmQgYSBiYXNlVXJsLCB1cGRhdGUgdGhlIHNlZ21lbnQgbGlzdCBvZiB0aGUgcGxheWxpc3RcbiAqIGFjY29yZGluZyB0byB0aGUgc2lkeCBpbmZvcm1hdGlvbiBnaXZlbi5cbiAqXG4gKiBwbGF5bGlzdC5zaWR4IGhhcyBtZXRhZGFkYXRhIGFib3V0IHRoZSBzaWR4IHdoZXJlLWFzIHRoZSBzaWR4IHBhcmFtXG4gKiBpcyB0aGUgcGFyc2VkIHNpZHggYm94IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIHBsYXlsaXN0IHRvIHVwZGF0ZSB0aGUgc2lkeCBpbmZvcm1hdGlvbiBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWR4IHRoZSBwYXJzZWQgc2lkeCBib3hcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBsYXlsaXN0IG9iamVjdCB3aXRoIHRoZSB1cGRhdGVkIHNpZHggaW5mb3JtYXRpb25cbiAqL1xuXG52YXIgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCQxID0gZnVuY3Rpb24gYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdChwbGF5bGlzdCwgc2lkeCwgYmFzZVVybCkge1xuICAvLyBSZXRhaW4gaW5pdCBzZWdtZW50IGluZm9ybWF0aW9uXG4gIHZhciBpbml0U2VnbWVudCA9IHBsYXlsaXN0LnNpZHgubWFwID8gcGxheWxpc3Quc2lkeC5tYXAgOiBudWxsOyAvLyBSZXRhaW4gc291cmNlIGR1cmF0aW9uIGZyb20gaW5pdGlhbCBtYWluIG1hbmlmZXN0IHBhcnNpbmdcblxuICB2YXIgc291cmNlRHVyYXRpb24gPSBwbGF5bGlzdC5zaWR4LmR1cmF0aW9uOyAvLyBSZXRhaW4gc291cmNlIHRpbWVsaW5lXG5cbiAgdmFyIHRpbWVsaW5lID0gcGxheWxpc3QudGltZWxpbmUgfHwgMDtcbiAgdmFyIHNpZHhCeXRlUmFuZ2UgPSBwbGF5bGlzdC5zaWR4LmJ5dGVyYW5nZTtcbiAgdmFyIHNpZHhFbmQgPSBzaWR4Qnl0ZVJhbmdlLm9mZnNldCArIHNpZHhCeXRlUmFuZ2UubGVuZ3RoOyAvLyBSZXRhaW4gdGltZXNjYWxlIG9mIHRoZSBwYXJzZWQgc2lkeFxuXG4gIHZhciB0aW1lc2NhbGUgPSBzaWR4LnRpbWVzY2FsZTsgLy8gcmVmZXJlbmNlVHlwZSAxIHJlZmVycyB0byBvdGhlciBzaWR4IGJveGVzXG5cbiAgdmFyIG1lZGlhUmVmZXJlbmNlcyA9IHNpZHgucmVmZXJlbmNlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gci5yZWZlcmVuY2VUeXBlICE9PSAxO1xuICB9KTtcbiAgdmFyIHNlZ21lbnRzID0gW107XG4gIHZhciB0eXBlID0gcGxheWxpc3QuZW5kTGlzdCA/ICdzdGF0aWMnIDogJ2R5bmFtaWMnO1xuICB2YXIgcGVyaW9kU3RhcnQgPSBwbGF5bGlzdC5zaWR4LnRpbWVsaW5lO1xuICB2YXIgcHJlc2VudGF0aW9uVGltZSA9IHBlcmlvZFN0YXJ0O1xuICB2YXIgbnVtYmVyID0gcGxheWxpc3QubWVkaWFTZXF1ZW5jZSB8fCAwOyAvLyBmaXJzdE9mZnNldCBpcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgc2lkeCBib3hcblxuICB2YXIgc3RhcnRJbmRleDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgaWYgKHR5cGVvZiBzaWR4LmZpcnN0T2Zmc2V0ID09PSAnYmlnaW50Jykge1xuICAgIHN0YXJ0SW5kZXggPSB3aW5kb3cuQmlnSW50KHNpZHhFbmQpICsgc2lkeC5maXJzdE9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEluZGV4ID0gc2lkeEVuZCArIHNpZHguZmlyc3RPZmZzZXQ7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhUmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWZlcmVuY2UgPSBzaWR4LnJlZmVyZW5jZXNbaV07IC8vIHNpemUgb2YgdGhlIHJlZmVyZW5jZWQgKHN1YilzZWdtZW50XG5cbiAgICB2YXIgc2l6ZSA9IHJlZmVyZW5jZS5yZWZlcmVuY2VkU2l6ZTsgLy8gZHVyYXRpb24gb2YgdGhlIHJlZmVyZW5jZWQgKHN1YilzZWdtZW50LCBpbiAgdGhlICB0aW1lc2NhbGVcbiAgICAvLyB0aGlzIHdpbGwgYmUgY29udmVydGVkIHRvIHNlY29uZHMgd2hlbiBnZW5lcmF0aW5nIHNlZ21lbnRzXG5cbiAgICB2YXIgZHVyYXRpb24gPSByZWZlcmVuY2Uuc3Vic2VnbWVudER1cmF0aW9uOyAvLyBzaG91bGQgYmUgYW4gaW5jbHVzaXZlIHJhbmdlXG5cbiAgICB2YXIgZW5kSW5kZXggPSB2b2lkIDA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAnYmlnaW50Jykge1xuICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgd2luZG93LkJpZ0ludChzaXplKSAtIHdpbmRvdy5CaWdJbnQoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHNpemUgLSAxO1xuICAgIH1cblxuICAgIHZhciBpbmRleFJhbmdlID0gc3RhcnRJbmRleCArIFwiLVwiICsgZW5kSW5kZXg7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICB0aW1lbGluZTogdGltZWxpbmUsXG4gICAgICBwZXJpb2RTdGFydDogcGVyaW9kU3RhcnQsXG4gICAgICBwcmVzZW50YXRpb25UaW1lOiBwcmVzZW50YXRpb25UaW1lLFxuICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBzb3VyY2VEdXJhdGlvbjogc291cmNlRHVyYXRpb24sXG4gICAgICBpbmRleFJhbmdlOiBpbmRleFJhbmdlLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c0Zyb21CYXNlKGF0dHJpYnV0ZXMpWzBdO1xuXG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBzZWdtZW50Lm1hcCA9IGluaXRTZWdtZW50O1xuICAgIH1cblxuICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cbiAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICdiaWdpbnQnKSB7XG4gICAgICBzdGFydEluZGV4ICs9IHdpbmRvdy5CaWdJbnQoc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggKz0gc2l6ZTtcbiAgICB9XG5cbiAgICBwcmVzZW50YXRpb25UaW1lICs9IGR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgIG51bWJlcisrO1xuICB9XG5cbiAgcGxheWxpc3Quc2VnbWVudHMgPSBzZWdtZW50cztcbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcblxudmFyIFNVUFBPUlRFRF9NRURJQV9UWVBFUyA9IFsnQVVESU8nLCAnU1VCVElUTEVTJ107IC8vIGFsbG93IG9uZSA2MGZwcyBmcmFtZSBhcyBsZW5pZW5jeSAoYXJiaXRyYXJpbHkgY2hvc2VuKVxuXG52YXIgVElNRV9GVURHRSA9IDEgLyA2MDtcbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIHRpbWVsaW5lU3RhcnRzLCBjb21iaW5lcywgZGVkdXBlcywgYW5kIHNvcnRzIHRoZW0uXG4gKlxuICogQHBhcmFtIHtUaW1lbGluZVN0YXJ0W119IHRpbWVsaW5lU3RhcnRzIC0gbGlzdCBvZiB0aW1lbGluZSBzdGFydHNcbiAqXG4gKiBAcmV0dXJuIHtUaW1lbGluZVN0YXJ0W119IHRoZSBjb21iaW5lZCBhbmQgZGVkdXBlZCB0aW1lbGluZSBzdGFydHNcbiAqL1xuXG52YXIgZ2V0VW5pcXVlVGltZWxpbmVTdGFydHMgPSBmdW5jdGlvbiBnZXRVbmlxdWVUaW1lbGluZVN0YXJ0cyh0aW1lbGluZVN0YXJ0cykge1xuICByZXR1cm4gdW5pb24odGltZWxpbmVTdGFydHMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHRpbWVsaW5lID0gX3JlZi50aW1lbGluZTtcbiAgICByZXR1cm4gdGltZWxpbmU7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS50aW1lbGluZSA+IGIudGltZWxpbmUgPyAxIDogLTE7XG4gIH0pO1xufTtcbi8qKlxuICogRmluZHMgdGhlIHBsYXlsaXN0IHdpdGggdGhlIG1hdGNoaW5nIE5BTUUgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBsYXlsaXN0cyAtIHBsYXlsaXN0cyB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgTkFNRSBhdHRyaWJ1dGUgdG8gc2VhcmNoIGZvclxuICpcbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSB0aGUgbWF0Y2hpbmcgcGxheWxpc3Qgb2JqZWN0LCBvciBudWxsXG4gKi9cblxudmFyIGZpbmRQbGF5bGlzdFdpdGhOYW1lID0gZnVuY3Rpb24gZmluZFBsYXlsaXN0V2l0aE5hbWUocGxheWxpc3RzLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxheWxpc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBsYXlsaXN0c1tpXS5hdHRyaWJ1dGVzLk5BTUUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBwbGF5bGlzdHNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBHZXRzIGEgZmxhdHRlbmVkIGFycmF5IG9mIG1lZGlhIGdyb3VwIHBsYXlsaXN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuaWZlc3QgLSB0aGUgbWFpbiBtYW5pZmVzdCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIG1lZGlhIGdyb3VwIHBsYXlsaXN0c1xuICovXG5cbnZhciBnZXRNZWRpYUdyb3VwUGxheWxpc3RzID0gZnVuY3Rpb24gZ2V0TWVkaWFHcm91cFBsYXlsaXN0cyhtYW5pZmVzdCkge1xuICB2YXIgbWVkaWFHcm91cFBsYXlsaXN0cyA9IFtdO1xuICBmb3JFYWNoTWVkaWFHcm91cChtYW5pZmVzdCwgU1VQUE9SVEVEX01FRElBX1RZUEVTLCBmdW5jdGlvbiAocHJvcGVydGllcywgdHlwZSwgZ3JvdXAsIGxhYmVsKSB7XG4gICAgbWVkaWFHcm91cFBsYXlsaXN0cyA9IG1lZGlhR3JvdXBQbGF5bGlzdHMuY29uY2F0KHByb3BlcnRpZXMucGxheWxpc3RzIHx8IFtdKTtcbiAgfSk7XG4gIHJldHVybiBtZWRpYUdyb3VwUGxheWxpc3RzO1xufTtcbi8qKlxuICogVXBkYXRlcyB0aGUgcGxheWxpc3QncyBtZWRpYSBzZXF1ZW5jZSBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5wbGF5bGlzdCAtIHRoZSBwbGF5bGlzdCB0byB1cGRhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcubWVkaWFTZXF1ZW5jZSAtIHRoZSBtZWRpYVNlcXVlbmNlIG51bWJlciB0byBzdGFydCB3aXRoXG4gKi9cblxudmFyIHVwZGF0ZU1lZGlhU2VxdWVuY2VGb3JQbGF5bGlzdCA9IGZ1bmN0aW9uIHVwZGF0ZU1lZGlhU2VxdWVuY2VGb3JQbGF5bGlzdChfcmVmMikge1xuICB2YXIgcGxheWxpc3QgPSBfcmVmMi5wbGF5bGlzdCxcbiAgICAgIG1lZGlhU2VxdWVuY2UgPSBfcmVmMi5tZWRpYVNlcXVlbmNlO1xuICBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlID0gbWVkaWFTZXF1ZW5jZTtcbiAgcGxheWxpc3Quc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCwgaW5kZXgpIHtcbiAgICBzZWdtZW50Lm51bWJlciA9IHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgKyBpbmRleDtcbiAgfSk7XG59O1xuLyoqXG4gKiBVcGRhdGVzIHRoZSBtZWRpYSBhbmQgZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXJzIG9mIG5ld1BsYXlsaXN0cyBnaXZlbiBvbGRQbGF5bGlzdHNcbiAqIGFuZCBhIGNvbXBsZXRlIGxpc3Qgb2YgdGltZWxpbmUgc3RhcnRzLlxuICpcbiAqIElmIG5vIG1hdGNoaW5nIHBsYXlsaXN0IGlzIGZvdW5kLCBvbmx5IHRoZSBkaXNjb250aW51aXR5IHNlcXVlbmNlIG51bWJlciBvZiB0aGUgcGxheWxpc3RcbiAqIHdpbGwgYmUgdXBkYXRlZC5cbiAqXG4gKiBTaW5jZSBlYXJseSBhdmFpbGFibGUgdGltZWxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkLCBhdCBsZWFzdCBvbmUgc2VnbWVudCBtdXN0IGJlIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBvbGRQbGF5bGlzdHMgLSB0aGUgb2xkIHBsYXlsaXN0cyB0byB1c2UgYXMgYSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7T2JqZWN0W119IG5ld1BsYXlsaXN0cyAtIHRoZSBuZXcgcGxheWxpc3RzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHRpbWVsaW5lU3RhcnRzIC0gYWxsIHRpbWVsaW5lU3RhcnRzIHNlZW4gaW4gdGhlIHN0cmVhbSB0byB0aGlzIHBvaW50XG4gKi9cblxudmFyIHVwZGF0ZVNlcXVlbmNlTnVtYmVycyA9IGZ1bmN0aW9uIHVwZGF0ZVNlcXVlbmNlTnVtYmVycyhfcmVmMykge1xuICB2YXIgb2xkUGxheWxpc3RzID0gX3JlZjMub2xkUGxheWxpc3RzLFxuICAgICAgbmV3UGxheWxpc3RzID0gX3JlZjMubmV3UGxheWxpc3RzLFxuICAgICAgdGltZWxpbmVTdGFydHMgPSBfcmVmMy50aW1lbGluZVN0YXJ0cztcbiAgbmV3UGxheWxpc3RzLmZvckVhY2goZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlID0gZmluZEluZGV4KHRpbWVsaW5lU3RhcnRzLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgIHZhciB0aW1lbGluZSA9IF9yZWY0LnRpbWVsaW5lO1xuICAgICAgcmV0dXJuIHRpbWVsaW5lID09PSBwbGF5bGlzdC50aW1lbGluZTtcbiAgICB9KTsgLy8gUGxheWxpc3RzIE5BTUVzIGNvbWUgZnJvbSBEQVNIIFJlcHJlc2VudGF0aW9uIElEcywgd2hpY2ggYXJlIG1hbmRhdG9yeVxuICAgIC8vIChzZWUgSVNPXzIzMDA5LTEtMjAxMiA1LjMuNS4yKS5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBzYW1lIFJlcHJlc2VudGF0aW9uIGV4aXN0ZWQgaW4gYSBwcmlvciBQZXJpb2QsIGl0IHdpbGwgcmV0YWluIHRoZSBzYW1lIE5BTUUuXG5cbiAgICB2YXIgb2xkUGxheWxpc3QgPSBmaW5kUGxheWxpc3RXaXRoTmFtZShvbGRQbGF5bGlzdHMsIHBsYXlsaXN0LmF0dHJpYnV0ZXMuTkFNRSk7XG5cbiAgICBpZiAoIW9sZFBsYXlsaXN0KSB7XG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgbmV3IHBsYXlsaXN0LCB0aGUgbWVkaWEgc2VxdWVuY2UgdmFsdWVzIGNhbiBzdGFydCBmcm9tIDAgd2l0aG91dFxuICAgICAgLy8gY29uc2VxdWVuY2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUT0RPIGJldHRlciBzdXBwb3J0IGZvciBsaXZlIFNJRFhcbiAgICAvL1xuICAgIC8vIEFzIG9mIHRoaXMgd3JpdGluZywgbXBkLXBhcnNlciBkb2VzIG5vdCBzdXBwb3J0IG11bHRpcGVyaW9kIFNJRFggKGluIGxpdmUgb3IgVk9EKS5cbiAgICAvLyBUaGlzIGlzIGV2aWRlbnQgYnkgYSBwbGF5bGlzdCBvbmx5IGhhdmluZyBhIHNpbmdsZSBTSURYIHJlZmVyZW5jZS4gSW4gYSBtdWx0aXBlcmlvZFxuICAgIC8vIHBsYXlsaXN0IHRoZXJlIHdvdWxkIG5lZWQgdG8gYmUgbXVsdGlwbGUgU0lEWCByZWZlcmVuY2VzLiBJbiBhZGRpdGlvbiwgbGl2ZSBTSURYIGlzXG4gICAgLy8gbm90IHN1cHBvcnRlZCB3aGVuIHRoZSBTSURYIHByb3BlcnRpZXMgY2hhbmdlIG9uIHJlZnJlc2hlcy5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBmdXR1cmUsIGlmIHN1cHBvcnQgbmVlZHMgdG8gYmUgYWRkZWQsIHRoZSBtZXJnaW5nIGxvZ2ljIGhlcmUgY2FuIGJlIGNhbGxlZFxuICAgIC8vIGFmdGVyIFNJRFggcmVmZXJlbmNlcyBhcmUgcmVzb2x2ZWQuIEZvciBub3csIGV4aXQgZWFybHkgdG8gcHJldmVudCBleGNlcHRpb25zIGJlaW5nXG4gICAgLy8gdGhyb3duIGR1ZSB0byB1bmRlZmluZWQgcmVmZXJlbmNlcy5cblxuXG4gICAgaWYgKHBsYXlsaXN0LnNpZHgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNpbmNlIHdlIGRvbid0IHlldCBzdXBwb3J0IGVhcmx5IGF2YWlsYWJsZSB0aW1lbGluZXMsIHdlIGRvbid0IG5lZWQgdG8gc3VwcG9ydFxuICAgIC8vIHBsYXlsaXN0cyB3aXRoIG5vIHNlZ21lbnRzLlxuXG5cbiAgICB2YXIgZmlyc3ROZXdTZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbMF07XG4gICAgdmFyIG9sZE1hdGNoaW5nU2VnbWVudEluZGV4ID0gZmluZEluZGV4KG9sZFBsYXlsaXN0LnNlZ21lbnRzLCBmdW5jdGlvbiAob2xkU2VnbWVudCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKG9sZFNlZ21lbnQucHJlc2VudGF0aW9uVGltZSAtIGZpcnN0TmV3U2VnbWVudC5wcmVzZW50YXRpb25UaW1lKSA8IFRJTUVfRlVER0U7XG4gICAgfSk7IC8vIE5vIG1hdGNoaW5nIHNlZ21lbnQgZnJvbSB0aGUgb2xkIHBsYXlsaXN0IG1lYW5zIHRoZSBlbnRpcmUgcGxheWxpc3Qgd2FzIHJlZnJlc2hlZC5cbiAgICAvLyBJbiB0aGlzIGNhc2UgdGhlIG1lZGlhIHNlcXVlbmNlIHNob3VsZCBhY2NvdW50IGZvciB0aGlzIHVwZGF0ZSwgYW5kIHRoZSBuZXcgc2VnbWVudHNcbiAgICAvLyBzaG91bGQgYmUgbWFya2VkIGFzIGRpc2NvbnRpbnVvdXMgZnJvbSB0aGUgcHJpb3IgY29udGVudCwgc2luY2UgdGhlIGxhc3QgcHJpb3JcbiAgICAvLyB0aW1lbGluZSB3YXMgcmVtb3ZlZC5cblxuICAgIGlmIChvbGRNYXRjaGluZ1NlZ21lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHVwZGF0ZU1lZGlhU2VxdWVuY2VGb3JQbGF5bGlzdCh7XG4gICAgICAgIHBsYXlsaXN0OiBwbGF5bGlzdCxcbiAgICAgICAgbWVkaWFTZXF1ZW5jZTogb2xkUGxheWxpc3QubWVkaWFTZXF1ZW5jZSArIG9sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBwbGF5bGlzdC5zZWdtZW50c1swXS5kaXNjb250aW51aXR5ID0gdHJ1ZTtcbiAgICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMudW5zaGlmdCgwKTsgLy8gTm8gbWF0Y2hpbmcgc2VnbWVudCBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoZXJlJ3MgbWlzc2luZyBjb250ZW50LlxuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBuZXcgcGxheWxpc3QncyB0aW1lbGluZSBpcyB0aGUgc2FtZSBhcyB0aGUgbGFzdCBzZWVuIHNlZ21lbnQncyB0aW1lbGluZSxcbiAgICAgIC8vIHRoZW4gYSBkaXNjb250aW51aXR5IGNhbiBiZSBhZGRlZCB0byBpZGVudGlmeSB0aGF0IHRoZXJlJ3MgcG90ZW50aWFsbHkgbWlzc2luZ1xuICAgICAgLy8gY29udGVudC4gSWYgdGhlcmUncyBubyBtaXNzaW5nIGNvbnRlbnQsIHRoZSBkaXNjb250aW51aXR5IHNob3VsZCBzdGlsbCBiZSByYXRoZXJcbiAgICAgIC8vIGhhcm1sZXNzLiBJdCdzIHBvc3NpYmxlIHRoYXQgaWYgc2VnbWVudCBkdXJhdGlvbnMgYXJlIGFjY3VyYXRlIGVub3VnaCwgdGhhdCB0aGVcbiAgICAgIC8vIGV4aXN0ZW5jZSBvZiBhIGdhcCBjYW4gYmUgZGV0ZXJtaW5lZCB1c2luZyB0aGUgcHJlc2VudGF0aW9uIHRpbWVzIGFuZCBkdXJhdGlvbnMsXG4gICAgICAvLyBidXQgaWYgdGhlIHNlZ21lbnQgdGltaW5nIGluZm8gaXMgb2ZmLCBpdCBtYXkgaW50cm9kdWNlIG1vcmUgcHJvYmxlbXMgdGhhbiBzaW1wbHlcbiAgICAgIC8vIGFkZGluZyB0aGUgZGlzY29udGludWl0eS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbmV3IHBsYXlsaXN0J3MgdGltZWxpbmUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3Qgc2VlbiBzZWdtZW50J3MgdGltZWxpbmUsXG4gICAgICAvLyB0aGVuIGEgZGlzY29udGludWl0eSBjYW4gYmUgYWRkZWQgdG8gaWRlbnRpZnkgdGhhdCB0aGlzIGlzIHRoZSBmaXJzdCBzZWVuIHNlZ21lbnRcbiAgICAgIC8vIG9mIGEgbmV3IHRpbWVsaW5lLiBIb3dldmVyLCB0aGUgbG9naWMgYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb24gdGhhdFxuICAgICAgLy8gZGV0ZXJtaW5lZCB0aGUgZGlzY29uaW51aXR5IHNlcXVlbmNlIGJ5IHRpbWVsaW5lIGluZGV4IGlzIG5vdyBvZmYgYnkgb25lICh0aGVcbiAgICAgIC8vIGRpc2NvbnRpbnVpdHkgb2YgdGhlIG5ld2VzdCB0aW1lbGluZSBoYXNuJ3QgeWV0IGZhbGxlbiBvZmYgdGhlIG1hbmlmZXN0Li4uc2luY2VcbiAgICAgIC8vIHdlIGFkZGVkIGl0KSwgc28gdGhlIGRpc2NvbmludWl0eSBzZXF1ZW5jZSBtdXN0IGJlIGRlY3JlbWVudGVkLlxuICAgICAgLy9cbiAgICAgIC8vIEEgcGVyaW9kIG1heSBhbHNvIGhhdmUgYSBkdXJhdGlvbiBvZiB6ZXJvLCBzbyB0aGUgY2FzZSBvZiBubyBzZWdtZW50cyBpcyBoYW5kbGVkXG4gICAgICAvLyBoZXJlIGV2ZW4gdGhvdWdoIHdlIGRvbid0IHlldCBzdXBwb3J0IGVhcmx5IGF2YWlsYWJsZSBwZXJpb2RzLlxuXG4gICAgICBpZiAoIW9sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAmJiBwbGF5bGlzdC50aW1lbGluZSA+IG9sZFBsYXlsaXN0LnRpbWVsaW5lIHx8IG9sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAmJiBwbGF5bGlzdC50aW1lbGluZSA+IG9sZFBsYXlsaXN0LnNlZ21lbnRzW29sZFBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAtIDFdLnRpbWVsaW5lKSB7XG4gICAgICAgIHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZS0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgZmlyc3Qgc2VnbWVudCBtYXRjaGVkIHdpdGggYSBwcmlvciBzZWdtZW50IG9uIGEgZGlzY29udGludWl0eSAoaXQncyBtYXRjaGluZ1xuICAgIC8vIG9uIHRoZSBmaXJzdCBzZWdtZW50IG9mIGEgcGVyaW9kKSwgdGhlbiB0aGUgZGlzY29udGludWl0eVNlcXVlbmNlIHNob3VsZG4ndCBiZSB0aGVcbiAgICAvLyB0aW1lbGluZSdzIG1hdGNoaW5nIG9uZSwgYnV0IGluc3RlYWQgc2hvdWxkIGJlIHRoZSBvbmUgcHJpb3IsIGFuZCB0aGUgZmlyc3Qgc2VnbWVudFxuICAgIC8vIG9mIHRoZSBuZXcgbWFuaWZlc3Qgc2hvdWxkIGJlIG1hcmtlZCB3aXRoIGEgZGlzY29udGludWl0eS5cbiAgICAvL1xuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgc3BlY2lhbCBjYXNlIGlzIHRoYXQgZGlzY29udGludWl0eSBzZXF1ZW5jZSBzaG93cyBob3cgbWFueVxuICAgIC8vIGRpc2NvbnRpbnVpdGllcyBoYXZlIGZhbGxlbiBvZmYgb2YgdGhlIHBsYXlsaXN0LCBhbmQgZGlzY29udGludWl0aWVzIGFyZSBtYXJrZWQgb25cbiAgICAvLyB0aGUgZmlyc3Qgc2VnbWVudCBvZiBhIG5ldyBcInRpbWVsaW5lLlwiIEJlY2F1c2Ugb2YgdGhpcywgd2hpbGUgREFTSCB3aWxsIHJldGFpbiB0aGF0XG4gICAgLy8gUGVyaW9kIHdoaWxlIHRoZSBcInRpbWVsaW5lXCIgZXhpc3RzLCBITFMga2VlcHMgdHJhY2sgb2YgaXQgdmlhIHRoZSBkaXNjb250aW51aXR5XG4gICAgLy8gc2VxdWVuY2UsIGFuZCB0aGF0IGZpcnN0IHNlZ21lbnQgaXMgYW4gaW5kaWNhdG9yLCBidXQgY2FuIGJlIHJlbW92ZWQgYmVmb3JlIHRoYXRcbiAgICAvLyB0aW1lbGluZSBpcyBnb25lLlxuXG5cbiAgICB2YXIgb2xkTWF0Y2hpbmdTZWdtZW50ID0gb2xkUGxheWxpc3Quc2VnbWVudHNbb2xkTWF0Y2hpbmdTZWdtZW50SW5kZXhdO1xuXG4gICAgaWYgKG9sZE1hdGNoaW5nU2VnbWVudC5kaXNjb250aW51aXR5ICYmICFmaXJzdE5ld1NlZ21lbnQuZGlzY29udGludWl0eSkge1xuICAgICAgZmlyc3ROZXdTZWdtZW50LmRpc2NvbnRpbnVpdHkgPSB0cnVlO1xuICAgICAgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy51bnNoaWZ0KDApO1xuICAgICAgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlLS07XG4gICAgfVxuXG4gICAgdXBkYXRlTWVkaWFTZXF1ZW5jZUZvclBsYXlsaXN0KHtcbiAgICAgIHBsYXlsaXN0OiBwbGF5bGlzdCxcbiAgICAgIG1lZGlhU2VxdWVuY2U6IG9sZFBsYXlsaXN0LnNlZ21lbnRzW29sZE1hdGNoaW5nU2VnbWVudEluZGV4XS5udW1iZXJcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBHaXZlbiBhbiBvbGQgcGFyc2VkIG1hbmlmZXN0IG9iamVjdCBhbmQgYSBuZXcgcGFyc2VkIG1hbmlmZXN0IG9iamVjdCwgdXBkYXRlcyB0aGVcbiAqIHNlcXVlbmNlIGFuZCB0aW1pbmcgdmFsdWVzIHdpdGhpbiB0aGUgbmV3IG1hbmlmZXN0IHRvIGVuc3VyZSB0aGF0IGl0IGxpbmVzIHVwIHdpdGggdGhlXG4gKiBvbGQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb2xkTWFuaWZlc3QgLSB0aGUgb2xkIG1haW4gbWFuaWZlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBuZXdNYW5pZmVzdCAtIHRoZSBuZXcgbWFpbiBtYW5pZmVzdCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB1cGRhdGVkIG5ldyBtYW5pZmVzdCBvYmplY3RcbiAqL1xuXG52YXIgcG9zaXRpb25NYW5pZmVzdE9uVGltZWxpbmUgPSBmdW5jdGlvbiBwb3NpdGlvbk1hbmlmZXN0T25UaW1lbGluZShfcmVmNSkge1xuICB2YXIgb2xkTWFuaWZlc3QgPSBfcmVmNS5vbGRNYW5pZmVzdCxcbiAgICAgIG5ld01hbmlmZXN0ID0gX3JlZjUubmV3TWFuaWZlc3Q7XG4gIC8vIFN0YXJ0aW5nIGZyb20gdjQuMS4yIG9mIHRoZSBJT1AsIHNlY3Rpb24gNC40LjMuMyBzdGF0ZXM6XG4gIC8vXG4gIC8vIFwiTVBEQGF2YWlsYWJpbGl0eVN0YXJ0VGltZSBhbmQgUGVyaW9kQHN0YXJ0IHNoYWxsIG5vdCBiZSBjaGFuZ2VkIG92ZXIgTVBEIHVwZGF0ZXMuXCJcbiAgLy9cbiAgLy8gVGhpcyB3YXMgYWRkZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9EQVNILUlGLUlPUC9pc3N1ZXMvMTYwXG4gIC8vXG4gIC8vIEJlY2F1c2Ugb2YgdGhpcyBjaGFuZ2UsIGFuZCB0aGUgZGlmZmljdWx0eSBvZiBzdXBwb3J0aW5nIHBlcmlvZHMgd2l0aCBjaGFuZ2luZyBzdGFydFxuICAvLyB0aW1lcywgcGVyaW9kcyB3aXRoIGNoYW5naW5nIHN0YXJ0IHRpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLiBUaGlzIG1ha2VzIHRoZSBsb2dpYyBtdWNoXG4gIC8vIHNpbXBsZXIsIHNpbmNlIHBlcmlvZHMgd2l0aCB0aGUgc2FtZSBzdGFydCB0aW1lIGNhbiBiZSBjb25zaWRlcnJlZCB0aGUgc2FtZSBwZXJpb2RcbiAgLy8gYWNyb3NzIHJlZnJlc2hlcy5cbiAgLy9cbiAgLy8gVG8gZ2l2ZSBhbiBleGFtcGxlIGFzIHRvIHRoZSBkaWZmaWN1bHR5IG9mIGhhbmRsaW5nIHBlcmlvZHMgd2hlcmUgdGhlIHN0YXJ0IHRpbWUgbWF5XG4gIC8vIGNoYW5nZSwgaWYgYSBzaW5nbGUgcGVyaW9kIG1hbmlmZXN0IGlzIHJlZnJlc2hlZCB3aXRoIGFub3RoZXIgbWFuaWZlc3Qgd2l0aCBhIHNpbmdsZVxuICAvLyBwZXJpb2QsIGFuZCBib3RoIHRoZSBzdGFydCBhbmQgZW5kIHRpbWVzIGFyZSBpbmNyZWFzZWQsIHRoZW4gdGhlIG9ubHkgd2F5IHRvIGRldGVybWluZVxuICAvLyBpZiBpdCdzIGEgbmV3IHBlcmlvZCBvciBhbiBvbGQgb25lIHRoYXQgaGFzIGNoYW5nZWQgaXMgdG8gbG9vayB0aHJvdWdoIHRoZSBzZWdtZW50cyBvZlxuICAvLyBlYWNoIHBsYXlsaXN0IGFuZCBkZXRlcm1pbmUgdGhlIHByZXNlbnRhdGlvbiB0aW1lIGJvdW5kcyB0byBmaW5kIGEgbWF0Y2guIEluIGFkZGl0aW9uLFxuICAvLyBpZiB0aGUgcGVyaW9kIHN0YXJ0IGNoYW5nZWQgdG8gZXhjZWVkIHRoZSBvbGQgcGVyaW9kIGVuZCwgdGhlbiB0aGVyZSB3b3VsZCBiZSBub1xuICAvLyBtYXRjaCwgYW5kIGl0IHdvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgcmVmcmVzaGVkIHBlcmlvZCBpcyBhIG5ld1xuICAvLyBvbmUgb3IgdGhlIG9sZCBvbmUuXG4gIHZhciBvbGRQbGF5bGlzdHMgPSBvbGRNYW5pZmVzdC5wbGF5bGlzdHMuY29uY2F0KGdldE1lZGlhR3JvdXBQbGF5bGlzdHMob2xkTWFuaWZlc3QpKTtcbiAgdmFyIG5ld1BsYXlsaXN0cyA9IG5ld01hbmlmZXN0LnBsYXlsaXN0cy5jb25jYXQoZ2V0TWVkaWFHcm91cFBsYXlsaXN0cyhuZXdNYW5pZmVzdCkpOyAvLyBTYXZlIGFsbCBzZWVuIHRpbWVsaW5lU3RhcnRzIHRvIHRoZSBuZXcgbWFuaWZlc3QuIEFsdGhvdWdoIHRoaXMgcG90ZW50aWFsbHkgbWVhbnMgdGhhdFxuICAvLyB0aGVyZSdzIGEgXCJtZW1vcnkgbGVha1wiIGluIHRoYXQgaXQgd2lsbCBuZXZlciBzdG9wIGdyb3dpbmcsIGluIHJlYWxpdHksIG9ubHkgYSBjb3VwbGVcbiAgLy8gb2YgcHJvcGVydGllcyBhcmUgc2F2ZWQgZm9yIGVhY2ggc2VlbiBQZXJpb2QuIEV2ZW4gbG9uZyBydW5uaW5nIGxpdmUgc3RyZWFtcyB3b24ndFxuICAvLyBnZW5lcmF0ZSB0b28gbWFueSBQZXJpb2RzLCB1bmxlc3MgdGhlIHN0cmVhbSBpcyB3YXRjaGVkIGZvciBkZWNhZGVzLiBJbiB0aGUgZnV0dXJlLFxuICAvLyB0aGlzIGNhbiBiZSBvcHRpbWl6ZWQgYnkgbWFwcGluZyB0byBkaXNjb250aW51aXR5IHNlcXVlbmNlIG51bWJlcnMgZm9yIGVhY2ggdGltZWxpbmUsXG4gIC8vIGJ1dCBpdCBtYXkgbm90IGJlY29tZSBhbiBpc3N1ZSwgYW5kIHRoZSBhZGRpdGlvbmFsIGluZm8gY2FuIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuXG4gIG5ld01hbmlmZXN0LnRpbWVsaW5lU3RhcnRzID0gZ2V0VW5pcXVlVGltZWxpbmVTdGFydHMoW29sZE1hbmlmZXN0LnRpbWVsaW5lU3RhcnRzLCBuZXdNYW5pZmVzdC50aW1lbGluZVN0YXJ0c10pO1xuICB1cGRhdGVTZXF1ZW5jZU51bWJlcnMoe1xuICAgIG9sZFBsYXlsaXN0czogb2xkUGxheWxpc3RzLFxuICAgIG5ld1BsYXlsaXN0czogbmV3UGxheWxpc3RzLFxuICAgIHRpbWVsaW5lU3RhcnRzOiBuZXdNYW5pZmVzdC50aW1lbGluZVN0YXJ0c1xuICB9KTtcbiAgcmV0dXJuIG5ld01hbmlmZXN0O1xufTtcblxudmFyIGdlbmVyYXRlU2lkeEtleSA9IGZ1bmN0aW9uIGdlbmVyYXRlU2lkeEtleShzaWR4KSB7XG4gIHJldHVybiBzaWR4ICYmIHNpZHgudXJpICsgJy0nICsgYnl0ZVJhbmdlVG9TdHJpbmcoc2lkeC5ieXRlcmFuZ2UpO1xufTtcblxudmFyIG1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyA9IGZ1bmN0aW9uIG1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyhwbGF5bGlzdHMpIHtcbiAgdmFyIG1lcmdlZFBsYXlsaXN0cyA9IHZhbHVlcyhwbGF5bGlzdHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYXlsaXN0KSB7XG4gICAgLy8gYXNzdW1pbmcgcGxheWxpc3QgSURzIGFyZSB0aGUgc2FtZSBhY3Jvc3MgcGVyaW9kc1xuICAgIC8vIFRPRE86IGhhbmRsZSBtdWx0aXBlcmlvZCB3aGVyZSByZXByZXNlbnRhdGlvbiBzZXRzIGFyZSBub3QgdGhlIHNhbWVcbiAgICAvLyBhY3Jvc3MgcGVyaW9kc1xuICAgIHZhciBuYW1lID0gcGxheWxpc3QuYXR0cmlidXRlcy5pZCArIChwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJycpO1xuXG4gICAgaWYgKCFhY2NbbmFtZV0pIHtcbiAgICAgIC8vIEZpcnN0IFBlcmlvZFxuICAgICAgYWNjW25hbWVdID0gcGxheWxpc3Q7XG4gICAgICBhY2NbbmFtZV0uYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdWJzZXF1ZW50IFBlcmlvZHNcbiAgICAgIGlmIChwbGF5bGlzdC5zZWdtZW50cykge1xuICAgICAgICB2YXIgX2FjYyRuYW1lJHNlZ21lbnRzO1xuXG4gICAgICAgIC8vIGZpcnN0IHNlZ21lbnQgb2Ygc3Vic2VxdWVudCBwZXJpb2RzIHNpZ25hbCBhIGRpc2NvbnRpbnVpdHlcbiAgICAgICAgaWYgKHBsYXlsaXN0LnNlZ21lbnRzWzBdKSB7XG4gICAgICAgICAgcGxheWxpc3Quc2VnbWVudHNbMF0uZGlzY29udGludWl0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAoX2FjYyRuYW1lJHNlZ21lbnRzID0gYWNjW25hbWVdLnNlZ21lbnRzKS5wdXNoLmFwcGx5KF9hY2MkbmFtZSRzZWdtZW50cywgcGxheWxpc3Quc2VnbWVudHMpO1xuICAgICAgfSAvLyBidWJibGUgdXAgY29udGVudFByb3RlY3Rpb24sIHRoaXMgYXNzdW1lcyBhbGwgRFJNIGNvbnRlbnRcbiAgICAgIC8vIGhhcyB0aGUgc2FtZSBjb250ZW50UHJvdGVjdGlvblxuXG5cbiAgICAgIGlmIChwbGF5bGlzdC5hdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uKSB7XG4gICAgICAgIGFjY1tuYW1lXS5hdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uID0gcGxheWxpc3QuYXR0cmlidXRlcy5jb250ZW50UHJvdGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY2NbbmFtZV0uYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cy5wdXNoKHtcbiAgICAgIC8vIEFsdGhvdWdoIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIG51bWJlciwgaXQncyBpbXBvcnRhbnQgdG8gaGF2ZSBib3RoIHRvIG1ha2UgaXRcbiAgICAgIC8vIGNvbXBhdGlibGUgd2l0aCBITFMgcG90ZW50aWFsbHkgaGF2aW5nIGEgc2ltaWxhciBhdHRyaWJ1dGUuXG4gICAgICBzdGFydDogcGxheWxpc3QuYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICAgIHRpbWVsaW5lOiBwbGF5bGlzdC5hdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pKTtcbiAgcmV0dXJuIG1lcmdlZFBsYXlsaXN0cy5tYXAoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cyA9IGZpbmRJbmRleGVzKHBsYXlsaXN0LnNlZ21lbnRzIHx8IFtdLCAnZGlzY29udGludWl0eScpO1xuICAgIHJldHVybiBwbGF5bGlzdDtcbiAgfSk7XG59O1xuXG52YXIgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCA9IGZ1bmN0aW9uIGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3QocGxheWxpc3QsIHNpZHhNYXBwaW5nKSB7XG4gIHZhciBzaWR4S2V5ID0gZ2VuZXJhdGVTaWR4S2V5KHBsYXlsaXN0LnNpZHgpO1xuICB2YXIgc2lkeE1hdGNoID0gc2lkeEtleSAmJiBzaWR4TWFwcGluZ1tzaWR4S2V5XSAmJiBzaWR4TWFwcGluZ1tzaWR4S2V5XS5zaWR4O1xuXG4gIGlmIChzaWR4TWF0Y2gpIHtcbiAgICBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0JDEocGxheWxpc3QsIHNpZHhNYXRjaCwgcGxheWxpc3Quc2lkeC5yZXNvbHZlZFVyaSk7XG4gIH1cblxuICByZXR1cm4gcGxheWxpc3Q7XG59O1xudmFyIGFkZFNpZHhTZWdtZW50c1RvUGxheWxpc3RzID0gZnVuY3Rpb24gYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdHMocGxheWxpc3RzLCBzaWR4TWFwcGluZykge1xuICBpZiAoc2lkeE1hcHBpbmcgPT09IHZvaWQgMCkge1xuICAgIHNpZHhNYXBwaW5nID0ge307XG4gIH1cblxuICBpZiAoIU9iamVjdC5rZXlzKHNpZHhNYXBwaW5nKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGxheWxpc3RzO1xuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBwbGF5bGlzdHMpIHtcbiAgICBwbGF5bGlzdHNbaV0gPSBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0KHBsYXlsaXN0c1tpXSwgc2lkeE1hcHBpbmcpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0cztcbn07XG52YXIgZm9ybWF0QXVkaW9QbGF5bGlzdCA9IGZ1bmN0aW9uIGZvcm1hdEF1ZGlvUGxheWxpc3QoX3JlZiwgaXNBdWRpb09ubHkpIHtcbiAgdmFyIF9hdHRyaWJ1dGVzO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgc2VnbWVudHMgPSBfcmVmLnNlZ21lbnRzLFxuICAgICAgc2lkeCA9IF9yZWYuc2lkeCxcbiAgICAgIG1lZGlhU2VxdWVuY2UgPSBfcmVmLm1lZGlhU2VxdWVuY2UsXG4gICAgICBkaXNjb250aW51aXR5U2VxdWVuY2UgPSBfcmVmLmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSxcbiAgICAgIGRpc2NvbnRpbnVpdHlTdGFydHMgPSBfcmVmLmRpc2NvbnRpbnVpdHlTdGFydHM7XG4gIHZhciBwbGF5bGlzdCA9IHtcbiAgICBhdHRyaWJ1dGVzOiAoX2F0dHJpYnV0ZXMgPSB7XG4gICAgICBOQU1FOiBhdHRyaWJ1dGVzLmlkLFxuICAgICAgQkFORFdJRFRIOiBhdHRyaWJ1dGVzLmJhbmR3aWR0aCxcbiAgICAgIENPREVDUzogYXR0cmlidXRlcy5jb2RlY3NcbiAgICB9LCBfYXR0cmlidXRlc1snUFJPR1JBTS1JRCddID0gMSwgX2F0dHJpYnV0ZXMpLFxuICAgIHVyaTogJycsXG4gICAgZW5kTGlzdDogYXR0cmlidXRlcy50eXBlID09PSAnc3RhdGljJyxcbiAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICByZXNvbHZlZFVyaTogJycsXG4gICAgdGFyZ2V0RHVyYXRpb246IGF0dHJpYnV0ZXMuZHVyYXRpb24sXG4gICAgZGlzY29udGludWl0eVNlcXVlbmNlOiBkaXNjb250aW51aXR5U2VxdWVuY2UsXG4gICAgZGlzY29udGludWl0eVN0YXJ0czogZGlzY29udGludWl0eVN0YXJ0cyxcbiAgICB0aW1lbGluZVN0YXJ0czogYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyxcbiAgICBtZWRpYVNlcXVlbmNlOiBtZWRpYVNlcXVlbmNlLFxuICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uKSB7XG4gICAgcGxheWxpc3QuY29udGVudFByb3RlY3Rpb24gPSBhdHRyaWJ1dGVzLmNvbnRlbnRQcm90ZWN0aW9uO1xuICB9XG5cbiAgaWYgKHNpZHgpIHtcbiAgICBwbGF5bGlzdC5zaWR4ID0gc2lkeDtcbiAgfVxuXG4gIGlmIChpc0F1ZGlvT25seSkge1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMuQVVESU8gPSAnYXVkaW8nO1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMuU1VCVElUTEVTID0gJ3N1YnMnO1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcbnZhciBmb3JtYXRWdHRQbGF5bGlzdCA9IGZ1bmN0aW9uIGZvcm1hdFZ0dFBsYXlsaXN0KF9yZWYyKSB7XG4gIHZhciBfbTN1OEF0dHJpYnV0ZXM7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmMi5hdHRyaWJ1dGVzLFxuICAgICAgc2VnbWVudHMgPSBfcmVmMi5zZWdtZW50cyxcbiAgICAgIG1lZGlhU2VxdWVuY2UgPSBfcmVmMi5tZWRpYVNlcXVlbmNlLFxuICAgICAgZGlzY29udGludWl0eVN0YXJ0cyA9IF9yZWYyLmRpc2NvbnRpbnVpdHlTdGFydHMsXG4gICAgICBkaXNjb250aW51aXR5U2VxdWVuY2UgPSBfcmVmMi5kaXNjb250aW51aXR5U2VxdWVuY2U7XG5cbiAgaWYgKHR5cGVvZiBzZWdtZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyB2dHQgdHJhY2tzIG1heSB1c2Ugc2luZ2xlIGZpbGUgaW4gQmFzZVVSTFxuICAgIHNlZ21lbnRzID0gW3tcbiAgICAgIHVyaTogYXR0cmlidXRlcy5iYXNlVXJsLFxuICAgICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgICByZXNvbHZlZFVyaTogYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLFxuICAgICAgZHVyYXRpb246IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICBudW1iZXI6IDBcbiAgICB9XTsgLy8gdGFyZ2V0RHVyYXRpb24gc2hvdWxkIGJlIHRoZSBzYW1lIGR1cmF0aW9uIGFzIHRoZSBvbmx5IHNlZ21lbnRcblxuICAgIGF0dHJpYnV0ZXMuZHVyYXRpb24gPSBhdHRyaWJ1dGVzLnNvdXJjZUR1cmF0aW9uO1xuICB9XG5cbiAgdmFyIG0zdThBdHRyaWJ1dGVzID0gKF9tM3U4QXR0cmlidXRlcyA9IHtcbiAgICBOQU1FOiBhdHRyaWJ1dGVzLmlkLFxuICAgIEJBTkRXSURUSDogYXR0cmlidXRlcy5iYW5kd2lkdGhcbiAgfSwgX20zdThBdHRyaWJ1dGVzWydQUk9HUkFNLUlEJ10gPSAxLCBfbTN1OEF0dHJpYnV0ZXMpO1xuXG4gIGlmIChhdHRyaWJ1dGVzLmNvZGVjcykge1xuICAgIG0zdThBdHRyaWJ1dGVzLkNPREVDUyA9IGF0dHJpYnV0ZXMuY29kZWNzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzOiBtM3U4QXR0cmlidXRlcyxcbiAgICB1cmk6ICcnLFxuICAgIGVuZExpc3Q6IGF0dHJpYnV0ZXMudHlwZSA9PT0gJ3N0YXRpYycsXG4gICAgdGltZWxpbmU6IGF0dHJpYnV0ZXMucGVyaW9kU3RhcnQsXG4gICAgcmVzb2x2ZWRVcmk6IGF0dHJpYnV0ZXMuYmFzZVVybCB8fCAnJyxcbiAgICB0YXJnZXREdXJhdGlvbjogYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICB0aW1lbGluZVN0YXJ0czogYXR0cmlidXRlcy50aW1lbGluZVN0YXJ0cyxcbiAgICBkaXNjb250aW51aXR5U3RhcnRzOiBkaXNjb250aW51aXR5U3RhcnRzLFxuICAgIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZTogZGlzY29udGludWl0eVNlcXVlbmNlLFxuICAgIG1lZGlhU2VxdWVuY2U6IG1lZGlhU2VxdWVuY2UsXG4gICAgc2VnbWVudHM6IHNlZ21lbnRzXG4gIH07XG59O1xudmFyIG9yZ2FuaXplQXVkaW9QbGF5bGlzdHMgPSBmdW5jdGlvbiBvcmdhbml6ZUF1ZGlvUGxheWxpc3RzKHBsYXlsaXN0cywgc2lkeE1hcHBpbmcsIGlzQXVkaW9Pbmx5KSB7XG4gIGlmIChzaWR4TWFwcGluZyA9PT0gdm9pZCAwKSB7XG4gICAgc2lkeE1hcHBpbmcgPSB7fTtcbiAgfVxuXG4gIGlmIChpc0F1ZGlvT25seSA9PT0gdm9pZCAwKSB7XG4gICAgaXNBdWRpb09ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYWluUGxheWxpc3Q7XG4gIHZhciBmb3JtYXR0ZWRQbGF5bGlzdHMgPSBwbGF5bGlzdHMucmVkdWNlKGZ1bmN0aW9uIChhLCBwbGF5bGlzdCkge1xuICAgIHZhciByb2xlID0gcGxheWxpc3QuYXR0cmlidXRlcy5yb2xlICYmIHBsYXlsaXN0LmF0dHJpYnV0ZXMucm9sZS52YWx1ZSB8fCAnJztcbiAgICB2YXIgbGFuZ3VhZ2UgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgfHwgJyc7XG4gICAgdmFyIGxhYmVsID0gcGxheWxpc3QuYXR0cmlidXRlcy5sYWJlbCB8fCAnbWFpbic7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgIXBsYXlsaXN0LmF0dHJpYnV0ZXMubGFiZWwpIHtcbiAgICAgIHZhciByb2xlTGFiZWwgPSByb2xlID8gXCIgKFwiICsgcm9sZSArIFwiKVwiIDogJyc7XG4gICAgICBsYWJlbCA9IFwiXCIgKyBwbGF5bGlzdC5hdHRyaWJ1dGVzLmxhbmcgKyByb2xlTGFiZWw7XG4gICAgfVxuXG4gICAgaWYgKCFhW2xhYmVsXSkge1xuICAgICAgYVtsYWJlbF0gPSB7XG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgYXV0b3NlbGVjdDogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDogcm9sZSA9PT0gJ21haW4nLFxuICAgICAgICBwbGF5bGlzdHM6IFtdLFxuICAgICAgICB1cmk6ICcnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0ZWQgPSBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0KGZvcm1hdEF1ZGlvUGxheWxpc3QocGxheWxpc3QsIGlzQXVkaW9Pbmx5KSwgc2lkeE1hcHBpbmcpO1xuICAgIGFbbGFiZWxdLnBsYXlsaXN0cy5wdXNoKGZvcm1hdHRlZCk7XG5cbiAgICBpZiAodHlwZW9mIG1haW5QbGF5bGlzdCA9PT0gJ3VuZGVmaW5lZCcgJiYgcm9sZSA9PT0gJ21haW4nKSB7XG4gICAgICBtYWluUGxheWxpc3QgPSBwbGF5bGlzdDtcbiAgICAgIG1haW5QbGF5bGlzdC5kZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfSwge30pOyAvLyBpZiBubyBwbGF5bGlzdHMgaGF2ZSByb2xlIFwibWFpblwiLCBtYXJrIHRoZSBmaXJzdCBhcyBtYWluXG5cbiAgaWYgKCFtYWluUGxheWxpc3QpIHtcbiAgICB2YXIgZmlyc3RMYWJlbCA9IE9iamVjdC5rZXlzKGZvcm1hdHRlZFBsYXlsaXN0cylbMF07XG4gICAgZm9ybWF0dGVkUGxheWxpc3RzW2ZpcnN0TGFiZWxdLmRlZmF1bHQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdHRlZFBsYXlsaXN0cztcbn07XG52YXIgb3JnYW5pemVWdHRQbGF5bGlzdHMgPSBmdW5jdGlvbiBvcmdhbml6ZVZ0dFBsYXlsaXN0cyhwbGF5bGlzdHMsIHNpZHhNYXBwaW5nKSB7XG4gIGlmIChzaWR4TWFwcGluZyA9PT0gdm9pZCAwKSB7XG4gICAgc2lkeE1hcHBpbmcgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBwbGF5bGlzdHMucmVkdWNlKGZ1bmN0aW9uIChhLCBwbGF5bGlzdCkge1xuICAgIHZhciBsYWJlbCA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMubGFuZyB8fCAndGV4dCc7XG5cbiAgICBpZiAoIWFbbGFiZWxdKSB7XG4gICAgICBhW2xhYmVsXSA9IHtcbiAgICAgICAgbGFuZ3VhZ2U6IGxhYmVsLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgIHBsYXlsaXN0czogW10sXG4gICAgICAgIHVyaTogJydcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYVtsYWJlbF0ucGxheWxpc3RzLnB1c2goYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdChmb3JtYXRWdHRQbGF5bGlzdChwbGF5bGlzdCksIHNpZHhNYXBwaW5nKSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn07XG5cbnZhciBvcmdhbml6ZUNhcHRpb25TZXJ2aWNlcyA9IGZ1bmN0aW9uIG9yZ2FuaXplQ2FwdGlvblNlcnZpY2VzKGNhcHRpb25TZXJ2aWNlcykge1xuICByZXR1cm4gY2FwdGlvblNlcnZpY2VzLnJlZHVjZShmdW5jdGlvbiAoc3ZjT2JqLCBzdmMpIHtcbiAgICBpZiAoIXN2Yykge1xuICAgICAgcmV0dXJuIHN2Y09iajtcbiAgICB9XG5cbiAgICBzdmMuZm9yRWFjaChmdW5jdGlvbiAoc2VydmljZSkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBzZXJ2aWNlLmNoYW5uZWwsXG4gICAgICAgICAgbGFuZ3VhZ2UgPSBzZXJ2aWNlLmxhbmd1YWdlO1xuICAgICAgc3ZjT2JqW2xhbmd1YWdlXSA9IHtcbiAgICAgICAgYXV0b3NlbGVjdDogZmFsc2UsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICBpbnN0cmVhbUlkOiBjaGFubmVsLFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZXJ2aWNlLmhhc093blByb3BlcnR5KCdhc3BlY3RSYXRpbycpKSB7XG4gICAgICAgIHN2Y09ialtsYW5ndWFnZV0uYXNwZWN0UmF0aW8gPSBzZXJ2aWNlLmFzcGVjdFJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VydmljZS5oYXNPd25Qcm9wZXJ0eSgnZWFzeVJlYWRlcicpKSB7XG4gICAgICAgIHN2Y09ialtsYW5ndWFnZV0uZWFzeVJlYWRlciA9IHNlcnZpY2UuZWFzeVJlYWRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcnZpY2UuaGFzT3duUHJvcGVydHkoJzNEJykpIHtcbiAgICAgICAgc3ZjT2JqW2xhbmd1YWdlXVsnM0QnXSA9IHNlcnZpY2VbJzNEJ107XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN2Y09iajtcbiAgfSwge30pO1xufTtcblxudmFyIGZvcm1hdFZpZGVvUGxheWxpc3QgPSBmdW5jdGlvbiBmb3JtYXRWaWRlb1BsYXlsaXN0KF9yZWYzKSB7XG4gIHZhciBfYXR0cmlidXRlczI7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmMy5hdHRyaWJ1dGVzLFxuICAgICAgc2VnbWVudHMgPSBfcmVmMy5zZWdtZW50cyxcbiAgICAgIHNpZHggPSBfcmVmMy5zaWR4LFxuICAgICAgZGlzY29udGludWl0eVN0YXJ0cyA9IF9yZWYzLmRpc2NvbnRpbnVpdHlTdGFydHM7XG4gIHZhciBwbGF5bGlzdCA9IHtcbiAgICBhdHRyaWJ1dGVzOiAoX2F0dHJpYnV0ZXMyID0ge1xuICAgICAgTkFNRTogYXR0cmlidXRlcy5pZCxcbiAgICAgIEFVRElPOiAnYXVkaW8nLFxuICAgICAgU1VCVElUTEVTOiAnc3VicycsXG4gICAgICBSRVNPTFVUSU9OOiB7XG4gICAgICAgIHdpZHRoOiBhdHRyaWJ1dGVzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGF0dHJpYnV0ZXMuaGVpZ2h0XG4gICAgICB9LFxuICAgICAgQ09ERUNTOiBhdHRyaWJ1dGVzLmNvZGVjcyxcbiAgICAgIEJBTkRXSURUSDogYXR0cmlidXRlcy5iYW5kd2lkdGhcbiAgICB9LCBfYXR0cmlidXRlczJbJ1BST0dSQU0tSUQnXSA9IDEsIF9hdHRyaWJ1dGVzMiksXG4gICAgdXJpOiAnJyxcbiAgICBlbmRMaXN0OiBhdHRyaWJ1dGVzLnR5cGUgPT09ICdzdGF0aWMnLFxuICAgIHRpbWVsaW5lOiBhdHRyaWJ1dGVzLnBlcmlvZFN0YXJ0LFxuICAgIHJlc29sdmVkVXJpOiAnJyxcbiAgICB0YXJnZXREdXJhdGlvbjogYXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICBkaXNjb250aW51aXR5U3RhcnRzOiBkaXNjb250aW51aXR5U3RhcnRzLFxuICAgIHRpbWVsaW5lU3RhcnRzOiBhdHRyaWJ1dGVzLnRpbWVsaW5lU3RhcnRzLFxuICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICB9O1xuXG4gIGlmIChhdHRyaWJ1dGVzLmZyYW1lUmF0ZSkge1xuICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXNbJ0ZSQU1FLVJBVEUnXSA9IGF0dHJpYnV0ZXMuZnJhbWVSYXRlO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb24pIHtcbiAgICBwbGF5bGlzdC5jb250ZW50UHJvdGVjdGlvbiA9IGF0dHJpYnV0ZXMuY29udGVudFByb3RlY3Rpb247XG4gIH1cblxuICBpZiAoc2lkeCkge1xuICAgIHBsYXlsaXN0LnNpZHggPSBzaWR4O1xuICB9XG5cbiAgcmV0dXJuIHBsYXlsaXN0O1xufTtcblxudmFyIHZpZGVvT25seSA9IGZ1bmN0aW9uIHZpZGVvT25seShfcmVmNCkge1xuICB2YXIgYXR0cmlidXRlcyA9IF9yZWY0LmF0dHJpYnV0ZXM7XG4gIHJldHVybiBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAndmlkZW8vbXA0JyB8fCBhdHRyaWJ1dGVzLm1pbWVUeXBlID09PSAndmlkZW8vd2VibScgfHwgYXR0cmlidXRlcy5jb250ZW50VHlwZSA9PT0gJ3ZpZGVvJztcbn07XG5cbnZhciBhdWRpb09ubHkgPSBmdW5jdGlvbiBhdWRpb09ubHkoX3JlZjUpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmNS5hdHRyaWJ1dGVzO1xuICByZXR1cm4gYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ2F1ZGlvL21wNCcgfHwgYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ2F1ZGlvL3dlYm0nIHx8IGF0dHJpYnV0ZXMuY29udGVudFR5cGUgPT09ICdhdWRpbyc7XG59O1xuXG52YXIgdnR0T25seSA9IGZ1bmN0aW9uIHZ0dE9ubHkoX3JlZjYpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBfcmVmNi5hdHRyaWJ1dGVzO1xuICByZXR1cm4gYXR0cmlidXRlcy5taW1lVHlwZSA9PT0gJ3RleHQvdnR0JyB8fCBhdHRyaWJ1dGVzLmNvbnRlbnRUeXBlID09PSAndGV4dCc7XG59O1xuLyoqXG4gKiBDb250YWlucyBzdGFydCBhbmQgdGltZWxpbmUgcHJvcGVydGllcyBkZW5vdGluZyBhIHRpbWVsaW5lIHN0YXJ0LiBGb3IgREFTSCwgdGhlc2Ugd2lsbFxuICogYmUgdGhlIHNhbWUgbnVtYmVyLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVsaW5lU3RhcnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydCAtIHRoZSBzdGFydCB0aW1lIG9mIHRoZSB0aW1lbGluZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVsaW5lIC0gdGhlIHRpbWVsaW5lIG51bWJlclxuICovXG5cbi8qKlxuICogQWRkcyBhcHByb3ByaWF0ZSBtZWRpYSBhbmQgZGlzY29udGludWl0eSBzZXF1ZW5jZSB2YWx1ZXMgdG8gdGhlIHNlZ21lbnRzIGFuZCBwbGF5bGlzdHMuXG4gKlxuICogVGhyb3VnaG91dCBtcGQtcGFyc2VyLCB0aGUgYG51bWJlcmAgYXR0cmlidXRlIGlzIHVzZWQgaW4gcmVsYXRpb24gdG8gYHN0YXJ0TnVtYmVyYCwgYVxuICogREFTSCBzcGVjaWZpYyBhdHRyaWJ1dGUgdXNlZCBpbiBjb25zdHJ1Y3Rpbmcgc2VnbWVudCBVUkkncyBmcm9tIHRlbXBsYXRlcy4gSG93ZXZlciwgZnJvbVxuICogYW4gSExTIHBlcnNwZWN0aXZlLCB0aGUgYG51bWJlcmAgYXR0cmlidXRlIG9uIGEgc2VnbWVudCB3b3VsZCBiZSBpdHMgYG1lZGlhU2VxdWVuY2VgXG4gKiB2YWx1ZSwgd2hpY2ggc2hvdWxkIHN0YXJ0IGF0IHRoZSBvcmlnaW5hbCBtZWRpYSBzZXF1ZW5jZSB2YWx1ZSAob3IgMCkgYW5kIGluY3JlbWVudCBieSAxXG4gKiBmb3IgZWFjaCBzZWdtZW50IHRoZXJlYWZ0ZXIuIFNpbmNlIERBU0gncyBgc3RhcnROdW1iZXJgIHZhbHVlcyBhcmUgaW5kZXBlbmRlbnQgcGVyXG4gKiBwZXJpb2QsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byB1c2UgaXQgZm9yIGBudW1iZXJgLiBJbnN0ZWFkLCBhc3N1bWUgZXZlcnl0aGluZyBzdGFydHNcbiAqIGZyb20gYSAwIG1lZGlhU2VxdWVuY2UgdmFsdWUgYW5kIGluY3JlbWVudCBmcm9tIHRoZXJlLlxuICpcbiAqIE5vdGUgdGhhdCBWSFMgY3VycmVudGx5IGRvZXNuJ3QgdXNlIHRoZSBgbnVtYmVyYCBwcm9wZXJ0eSwgYnV0IGl0IGNhbiBiZSBoZWxwZnVsIGZvclxuICogZGVidWdnaW5nIGFuZCBtYWtpbmcgc2Vuc2Ugb2YgdGhlIG1hbmlmZXN0LlxuICpcbiAqIEZvciBsaXZlIHBsYXlsaXN0cywgdG8gYWNjb3VudCBmb3IgdmFsdWVzIGluY3JlYXNpbmcgaW4gbWFuaWZlc3RzIHdoZW4gcGVyaW9kcyBhcmVcbiAqIHJlbW92ZWQgb24gcmVmcmVzaGVzLCBtZXJnaW5nIGxvZ2ljIHNob3VsZCBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgbnVtYmVycyB0byB0aGVpclxuICogYXBwcm9wcmlhdGUgdmFsdWVzICh0byBlbnN1cmUgdGhleSdyZSBzZXF1ZW50aWFsIGFuZCBpbmNyZWFzaW5nKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdFtdfSBwbGF5bGlzdHMgLSB0aGUgcGxheWxpc3RzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtUaW1lbGluZVN0YXJ0W119IHRpbWVsaW5lU3RhcnRzIC0gdGhlIHRpbWVsaW5lIHN0YXJ0cyBmb3IgdGhlIG1hbmlmZXN0XG4gKi9cblxuXG52YXIgYWRkTWVkaWFTZXF1ZW5jZVZhbHVlcyA9IGZ1bmN0aW9uIGFkZE1lZGlhU2VxdWVuY2VWYWx1ZXMocGxheWxpc3RzLCB0aW1lbGluZVN0YXJ0cykge1xuICAvLyBpbmNyZW1lbnQgYWxsIHNlZ21lbnRzIHNlcXVlbnRpYWxseVxuICBwbGF5bGlzdHMuZm9yRWFjaChmdW5jdGlvbiAocGxheWxpc3QpIHtcbiAgICBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlID0gMDtcbiAgICBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgPSBmaW5kSW5kZXgodGltZWxpbmVTdGFydHMsIGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgdmFyIHRpbWVsaW5lID0gX3JlZjcudGltZWxpbmU7XG4gICAgICByZXR1cm4gdGltZWxpbmUgPT09IHBsYXlsaXN0LnRpbWVsaW5lO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwbGF5bGlzdC5zZWdtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsYXlsaXN0LnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQsIGluZGV4KSB7XG4gICAgICBzZWdtZW50Lm51bWJlciA9IGluZGV4O1xuICAgIH0pO1xuICB9KTtcbn07XG4vKipcbiAqIEdpdmVuIGEgbWVkaWEgZ3JvdXAgb2JqZWN0LCBmbGF0dGVucyBhbGwgcGxheWxpc3RzIHdpdGhpbiB0aGUgbWVkaWEgZ3JvdXAgaW50byBhIHNpbmdsZVxuICogYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lZGlhR3JvdXBPYmplY3QgLSB0aGUgbWVkaWEgZ3JvdXAgb2JqZWN0XG4gKlxuICogQHJldHVybiB7T2JqZWN0W119XG4gKiAgICAgICAgIFRoZSBtZWRpYSBncm91cCBwbGF5bGlzdHNcbiAqL1xuXG52YXIgZmxhdHRlbk1lZGlhR3JvdXBQbGF5bGlzdHMgPSBmdW5jdGlvbiBmbGF0dGVuTWVkaWFHcm91cFBsYXlsaXN0cyhtZWRpYUdyb3VwT2JqZWN0KSB7XG4gIGlmICghbWVkaWFHcm91cE9iamVjdCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZWRpYUdyb3VwT2JqZWN0KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbGFiZWwpIHtcbiAgICB2YXIgbGFiZWxDb250ZW50cyA9IG1lZGlhR3JvdXBPYmplY3RbbGFiZWxdO1xuICAgIHJldHVybiBhY2MuY29uY2F0KGxhYmVsQ29udGVudHMucGxheWxpc3RzKTtcbiAgfSwgW10pO1xufTtcbnZhciB0b00zdTggPSBmdW5jdGlvbiB0b00zdTgoX3JlZjgpIHtcbiAgdmFyIF9tZWRpYUdyb3VwcztcblxuICB2YXIgZGFzaFBsYXlsaXN0cyA9IF9yZWY4LmRhc2hQbGF5bGlzdHMsXG4gICAgICBsb2NhdGlvbnMgPSBfcmVmOC5sb2NhdGlvbnMsXG4gICAgICBfcmVmOCRzaWR4TWFwcGluZyA9IF9yZWY4LnNpZHhNYXBwaW5nLFxuICAgICAgc2lkeE1hcHBpbmcgPSBfcmVmOCRzaWR4TWFwcGluZyA9PT0gdm9pZCAwID8ge30gOiBfcmVmOCRzaWR4TWFwcGluZyxcbiAgICAgIHByZXZpb3VzTWFuaWZlc3QgPSBfcmVmOC5wcmV2aW91c01hbmlmZXN0O1xuXG4gIGlmICghZGFzaFBsYXlsaXN0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge307XG4gIH0gLy8gZ3JhYiBhbGwgbWFpbiBtYW5pZmVzdCBhdHRyaWJ1dGVzXG5cblxuICB2YXIgX2Rhc2hQbGF5bGlzdHMkMCRhdHRyID0gZGFzaFBsYXlsaXN0c1swXS5hdHRyaWJ1dGVzLFxuICAgICAgZHVyYXRpb24gPSBfZGFzaFBsYXlsaXN0cyQwJGF0dHIuc291cmNlRHVyYXRpb24sXG4gICAgICB0eXBlID0gX2Rhc2hQbGF5bGlzdHMkMCRhdHRyLnR5cGUsXG4gICAgICBzdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheSA9IF9kYXNoUGxheWxpc3RzJDAkYXR0ci5zdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheSxcbiAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSBfZGFzaFBsYXlsaXN0cyQwJGF0dHIubWluaW11bVVwZGF0ZVBlcmlvZDtcbiAgdmFyIHZpZGVvUGxheWxpc3RzID0gbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzKGRhc2hQbGF5bGlzdHMuZmlsdGVyKHZpZGVvT25seSkpLm1hcChmb3JtYXRWaWRlb1BsYXlsaXN0KTtcbiAgdmFyIGF1ZGlvUGxheWxpc3RzID0gbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzKGRhc2hQbGF5bGlzdHMuZmlsdGVyKGF1ZGlvT25seSkpO1xuICB2YXIgdnR0UGxheWxpc3RzID0gbWVyZ2VEaXNjb250aWd1b3VzUGxheWxpc3RzKGRhc2hQbGF5bGlzdHMuZmlsdGVyKHZ0dE9ubHkpKTtcbiAgdmFyIGNhcHRpb25zID0gZGFzaFBsYXlsaXN0cy5tYXAoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuIHBsYXlsaXN0LmF0dHJpYnV0ZXMuY2FwdGlvblNlcnZpY2VzO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIHZhciBtYW5pZmVzdCA9IHtcbiAgICBhbGxvd0NhY2hlOiB0cnVlLFxuICAgIGRpc2NvbnRpbnVpdHlTdGFydHM6IFtdLFxuICAgIHNlZ21lbnRzOiBbXSxcbiAgICBlbmRMaXN0OiB0cnVlLFxuICAgIG1lZGlhR3JvdXBzOiAoX21lZGlhR3JvdXBzID0ge1xuICAgICAgQVVESU86IHt9LFxuICAgICAgVklERU86IHt9XG4gICAgfSwgX21lZGlhR3JvdXBzWydDTE9TRUQtQ0FQVElPTlMnXSA9IHt9LCBfbWVkaWFHcm91cHMuU1VCVElUTEVTID0ge30sIF9tZWRpYUdyb3VwcyksXG4gICAgdXJpOiAnJyxcbiAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgcGxheWxpc3RzOiBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0cyh2aWRlb1BsYXlsaXN0cywgc2lkeE1hcHBpbmcpXG4gIH07XG5cbiAgaWYgKG1pbmltdW1VcGRhdGVQZXJpb2QgPj0gMCkge1xuICAgIG1hbmlmZXN0Lm1pbmltdW1VcGRhdGVQZXJpb2QgPSBtaW5pbXVtVXBkYXRlUGVyaW9kICogMTAwMDtcbiAgfVxuXG4gIGlmIChsb2NhdGlvbnMpIHtcbiAgICBtYW5pZmVzdC5sb2NhdGlvbnMgPSBsb2NhdGlvbnM7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgbWFuaWZlc3Quc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXkgPSBzdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheTtcbiAgfVxuXG4gIHZhciBpc0F1ZGlvT25seSA9IG1hbmlmZXN0LnBsYXlsaXN0cy5sZW5ndGggPT09IDA7XG4gIHZhciBvcmdhbml6ZWRBdWRpb0dyb3VwID0gYXVkaW9QbGF5bGlzdHMubGVuZ3RoID8gb3JnYW5pemVBdWRpb1BsYXlsaXN0cyhhdWRpb1BsYXlsaXN0cywgc2lkeE1hcHBpbmcsIGlzQXVkaW9Pbmx5KSA6IG51bGw7XG4gIHZhciBvcmdhbml6ZWRWdHRHcm91cCA9IHZ0dFBsYXlsaXN0cy5sZW5ndGggPyBvcmdhbml6ZVZ0dFBsYXlsaXN0cyh2dHRQbGF5bGlzdHMsIHNpZHhNYXBwaW5nKSA6IG51bGw7XG4gIHZhciBmb3JtYXR0ZWRQbGF5bGlzdHMgPSB2aWRlb1BsYXlsaXN0cy5jb25jYXQoZmxhdHRlbk1lZGlhR3JvdXBQbGF5bGlzdHMob3JnYW5pemVkQXVkaW9Hcm91cCksIGZsYXR0ZW5NZWRpYUdyb3VwUGxheWxpc3RzKG9yZ2FuaXplZFZ0dEdyb3VwKSk7XG4gIHZhciBwbGF5bGlzdFRpbWVsaW5lU3RhcnRzID0gZm9ybWF0dGVkUGxheWxpc3RzLm1hcChmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICB2YXIgdGltZWxpbmVTdGFydHMgPSBfcmVmOS50aW1lbGluZVN0YXJ0cztcbiAgICByZXR1cm4gdGltZWxpbmVTdGFydHM7XG4gIH0pO1xuICBtYW5pZmVzdC50aW1lbGluZVN0YXJ0cyA9IGdldFVuaXF1ZVRpbWVsaW5lU3RhcnRzKHBsYXlsaXN0VGltZWxpbmVTdGFydHMpO1xuICBhZGRNZWRpYVNlcXVlbmNlVmFsdWVzKGZvcm1hdHRlZFBsYXlsaXN0cywgbWFuaWZlc3QudGltZWxpbmVTdGFydHMpO1xuXG4gIGlmIChvcmdhbml6ZWRBdWRpb0dyb3VwKSB7XG4gICAgbWFuaWZlc3QubWVkaWFHcm91cHMuQVVESU8uYXVkaW8gPSBvcmdhbml6ZWRBdWRpb0dyb3VwO1xuICB9XG5cbiAgaWYgKG9yZ2FuaXplZFZ0dEdyb3VwKSB7XG4gICAgbWFuaWZlc3QubWVkaWFHcm91cHMuU1VCVElUTEVTLnN1YnMgPSBvcmdhbml6ZWRWdHRHcm91cDtcbiAgfVxuXG4gIGlmIChjYXB0aW9ucy5sZW5ndGgpIHtcbiAgICBtYW5pZmVzdC5tZWRpYUdyb3Vwc1snQ0xPU0VELUNBUFRJT05TJ10uY2MgPSBvcmdhbml6ZUNhcHRpb25TZXJ2aWNlcyhjYXB0aW9ucyk7XG4gIH1cblxuICBpZiAocHJldmlvdXNNYW5pZmVzdCkge1xuICAgIHJldHVybiBwb3NpdGlvbk1hbmlmZXN0T25UaW1lbGluZSh7XG4gICAgICBvbGRNYW5pZmVzdDogcHJldmlvdXNNYW5pZmVzdCxcbiAgICAgIG5ld01hbmlmZXN0OiBtYW5pZmVzdFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG1hbmlmZXN0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBSIChyZXBldGl0aW9uKSB2YWx1ZSBmb3IgYSBsaXZlIHN0cmVhbSAoZm9yIHRoZSBmaW5hbCBzZWdtZW50XG4gKiBpbiBhIG1hbmlmZXN0IHdoZXJlIHRoZSByIHZhbHVlIGlzIG5lZ2F0aXZlIDEpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogICAgICAgIGN1cnJlbnQgdGltZSAodHlwaWNhbGx5IHRoZSB0b3RhbCB0aW1lIHVwIHVudGlsIHRoZSBmaW5hbCBzZWdtZW50KVxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiAgICAgICAgZHVyYXRpb24gcHJvcGVydHkgZm9yIHRoZSBnaXZlbiA8UyAvPlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICBSIHZhbHVlIHRvIHJlYWNoIHRoZSBlbmQgb2YgdGhlIGdpdmVuIHBlcmlvZFxuICovXG52YXIgZ2V0TGl2ZVJWYWx1ZSA9IGZ1bmN0aW9uIGdldExpdmVSVmFsdWUoYXR0cmlidXRlcywgdGltZSwgZHVyYXRpb24pIHtcbiAgdmFyIE5PVyA9IGF0dHJpYnV0ZXMuTk9XLFxuICAgICAgY2xpZW50T2Zmc2V0ID0gYXR0cmlidXRlcy5jbGllbnRPZmZzZXQsXG4gICAgICBhdmFpbGFiaWxpdHlTdGFydFRpbWUgPSBhdHRyaWJ1dGVzLmF2YWlsYWJpbGl0eVN0YXJ0VGltZSxcbiAgICAgIF9hdHRyaWJ1dGVzJHRpbWVzY2FsZSA9IGF0dHJpYnV0ZXMudGltZXNjYWxlLFxuICAgICAgdGltZXNjYWxlID0gX2F0dHJpYnV0ZXMkdGltZXNjYWxlID09PSB2b2lkIDAgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlLFxuICAgICAgX2F0dHJpYnV0ZXMkcGVyaW9kU3RhID0gYXR0cmlidXRlcy5wZXJpb2RTdGFydCxcbiAgICAgIHBlcmlvZFN0YXJ0ID0gX2F0dHJpYnV0ZXMkcGVyaW9kU3RhID09PSB2b2lkIDAgPyAwIDogX2F0dHJpYnV0ZXMkcGVyaW9kU3RhLFxuICAgICAgX2F0dHJpYnV0ZXMkbWluaW11bVVwID0gYXR0cmlidXRlcy5taW5pbXVtVXBkYXRlUGVyaW9kLFxuICAgICAgbWluaW11bVVwZGF0ZVBlcmlvZCA9IF9hdHRyaWJ1dGVzJG1pbmltdW1VcCA9PT0gdm9pZCAwID8gMCA6IF9hdHRyaWJ1dGVzJG1pbmltdW1VcDtcbiAgdmFyIG5vdyA9IChOT1cgKyBjbGllbnRPZmZzZXQpIC8gMTAwMDtcbiAgdmFyIHBlcmlvZFN0YXJ0V0MgPSBhdmFpbGFiaWxpdHlTdGFydFRpbWUgKyBwZXJpb2RTdGFydDtcbiAgdmFyIHBlcmlvZEVuZFdDID0gbm93ICsgbWluaW11bVVwZGF0ZVBlcmlvZDtcbiAgdmFyIHBlcmlvZER1cmF0aW9uID0gcGVyaW9kRW5kV0MgLSBwZXJpb2RTdGFydFdDO1xuICByZXR1cm4gTWF0aC5jZWlsKChwZXJpb2REdXJhdGlvbiAqIHRpbWVzY2FsZSAtIHRpbWUpIC8gZHVyYXRpb24pO1xufTtcbi8qKlxuICogVXNlcyBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSBTZWdtZW50VGVtcGxhdGUuU2VnbWVudFRpbWVsaW5lIHRvIGRldGVybWluZSBzZWdtZW50XG4gKiB0aW1pbmcgYW5kIGR1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgICAgICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqXG4gKiBAcmV0dXJuIHt7bnVtYmVyOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIsIHRpbWU6IG51bWJlciwgdGltZWxpbmU6IG51bWJlcn1bXX1cbiAqICAgICAgICAgTGlzdCBvZiBPYmplY3RzIHdpdGggc2VnbWVudCB0aW1pbmcgYW5kIGR1cmF0aW9uIGluZm9cbiAqL1xuXG5cbnZhciBwYXJzZUJ5VGltZWxpbmUgPSBmdW5jdGlvbiBwYXJzZUJ5VGltZWxpbmUoYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSB7XG4gIHZhciB0eXBlID0gYXR0cmlidXRlcy50eXBlLFxuICAgICAgX2F0dHJpYnV0ZXMkbWluaW11bVVwMiA9IGF0dHJpYnV0ZXMubWluaW11bVVwZGF0ZVBlcmlvZCxcbiAgICAgIG1pbmltdW1VcGRhdGVQZXJpb2QgPSBfYXR0cmlidXRlcyRtaW5pbXVtVXAyID09PSB2b2lkIDAgPyAwIDogX2F0dHJpYnV0ZXMkbWluaW11bVVwMixcbiAgICAgIF9hdHRyaWJ1dGVzJG1lZGlhID0gYXR0cmlidXRlcy5tZWRpYSxcbiAgICAgIG1lZGlhID0gX2F0dHJpYnV0ZXMkbWVkaWEgPT09IHZvaWQgMCA/ICcnIDogX2F0dHJpYnV0ZXMkbWVkaWEsXG4gICAgICBzb3VyY2VEdXJhdGlvbiA9IGF0dHJpYnV0ZXMuc291cmNlRHVyYXRpb24sXG4gICAgICBfYXR0cmlidXRlcyR0aW1lc2NhbGUyID0gYXR0cmlidXRlcy50aW1lc2NhbGUsXG4gICAgICB0aW1lc2NhbGUgPSBfYXR0cmlidXRlcyR0aW1lc2NhbGUyID09PSB2b2lkIDAgPyAxIDogX2F0dHJpYnV0ZXMkdGltZXNjYWxlMixcbiAgICAgIF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYiA9IGF0dHJpYnV0ZXMuc3RhcnROdW1iZXIsXG4gICAgICBzdGFydE51bWJlciA9IF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYiA9PT0gdm9pZCAwID8gMSA6IF9hdHRyaWJ1dGVzJHN0YXJ0TnVtYixcbiAgICAgIHRpbWVsaW5lID0gYXR0cmlidXRlcy5wZXJpb2RTdGFydDtcbiAgdmFyIHNlZ21lbnRzID0gW107XG4gIHZhciB0aW1lID0gLTE7XG5cbiAgZm9yICh2YXIgc0luZGV4ID0gMDsgc0luZGV4IDwgc2VnbWVudFRpbWVsaW5lLmxlbmd0aDsgc0luZGV4KyspIHtcbiAgICB2YXIgUyA9IHNlZ21lbnRUaW1lbGluZVtzSW5kZXhdO1xuICAgIHZhciBkdXJhdGlvbiA9IFMuZDtcbiAgICB2YXIgcmVwZWF0ID0gUy5yIHx8IDA7XG4gICAgdmFyIHNlZ21lbnRUaW1lID0gUy50IHx8IDA7XG5cbiAgICBpZiAodGltZSA8IDApIHtcbiAgICAgIC8vIGZpcnN0IHNlZ21lbnRcbiAgICAgIHRpbWUgPSBzZWdtZW50VGltZTtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudFRpbWUgJiYgc2VnbWVudFRpbWUgPiB0aW1lKSB7XG4gICAgICAvLyBkaXNjb250aW51aXR5XG4gICAgICAvLyBUT0RPOiBIb3cgdG8gaGFuZGxlIHRoaXMgdHlwZSBvZiBkaXNjb250aW51aXR5XG4gICAgICAvLyB0aW1lbGluZSsrIGhlcmUgd291bGQgdHJlYXQgaXQgbGlrZSBITFMgZGlzY29udHVpdHkgYW5kIGNvbnRlbnQgd291bGRcbiAgICAgIC8vIGdldCBhcHBlbmRlZCB3aXRob3V0IGdhcFxuICAgICAgLy8gRS5HLlxuICAgICAgLy8gIDxTIHQ9XCIwXCIgZD1cIjFcIiAvPlxuICAgICAgLy8gIDxTIGQ9XCIxXCIgLz5cbiAgICAgIC8vICA8UyBkPVwiMVwiIC8+XG4gICAgICAvLyAgPFMgdD1cIjVcIiBkPVwiMVwiIC8+XG4gICAgICAvLyB3b3VsZCBoYXZlICRUaW1lJCB2YWx1ZXMgb2YgWzAsIDEsIDIsIDVdXG4gICAgICAvLyBzaG91bGQgdGhpcyBiZSBhcHBlbmVkIGF0IHRpbWUgcG9zaXRpb25zIFswLCAxLCAyLCAzXSwoI0VYVC1YLURJU0NPTlRJTlVJVFkpXG4gICAgICAvLyBvciBbMCwgMSwgMiwgZ2FwLCBnYXAsIDVdPyAoI0VYVC1YLUdBUClcbiAgICAgIC8vIGRvZXMgdGhlIHZhbHVlIG9mIHNvdXJjZUR1cmF0aW9uIGNvbnNpZGVyIHRoaXMgd2hlbiBjYWxjdWxhdGluZyBhcmJpdHJhcnlcbiAgICAgIC8vIG5lZ2F0aXZlIEByIHJlcGVhdCB2YWx1ZT9cbiAgICAgIC8vIEUuRy4gU2FtZSBlbGVtZW50cyBhcyBhYm92ZSB3aXRoIHRoaXMgYWRkZWQgYXQgdGhlIGVuZFxuICAgICAgLy8gIDxTIGQ9XCIxXCIgcj1cIi0xXCIgLz5cbiAgICAgIC8vICB3aXRoIGEgc291cmNlRHVyYXRpb24gb2YgMTBcbiAgICAgIC8vIFdvdWxkIHRoZSAyIGdhcHMgYmUgaW5jbHVkZWQgaW4gdGhlIHRpbWUgZHVyYXRpb24gY2FsY3VsYXRpb25zIHJlc3VsdGluZyBpblxuICAgICAgLy8gOCBzZWdtZW50cyB3aXRoICRUaW1lJCB2YWx1ZXMgb2YgWzAsIDEsIDIsIDUsIDYsIDcsIDgsIDldIG9yIDEwIHNlZ21lbnRzXG4gICAgICAvLyB3aXRoICRUaW1lJCB2YWx1ZXMgb2YgWzAsIDEsIDIsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV0gP1xuICAgICAgdGltZSA9IHNlZ21lbnRUaW1lO1xuICAgIH1cblxuICAgIHZhciBjb3VudCA9IHZvaWQgMDtcblxuICAgIGlmIChyZXBlYXQgPCAwKSB7XG4gICAgICB2YXIgbmV4dFMgPSBzSW5kZXggKyAxO1xuXG4gICAgICBpZiAobmV4dFMgPT09IHNlZ21lbnRUaW1lbGluZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGFzdCBzZWdtZW50XG4gICAgICAgIGlmICh0eXBlID09PSAnZHluYW1pYycgJiYgbWluaW11bVVwZGF0ZVBlcmlvZCA+IDAgJiYgbWVkaWEuaW5kZXhPZignJE51bWJlciQnKSA+IDApIHtcbiAgICAgICAgICBjb3VudCA9IGdldExpdmVSVmFsdWUoYXR0cmlidXRlcywgdGltZSwgZHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE86IFRoaXMgbWF5IGJlIGluY29ycmVjdCBkZXBlbmRpbmcgb24gY29uY2x1c2lvbiBvZiBUT0RPIGFib3ZlXG4gICAgICAgICAgY291bnQgPSAoc291cmNlRHVyYXRpb24gKiB0aW1lc2NhbGUgLSB0aW1lKSAvIGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCA9IChzZWdtZW50VGltZWxpbmVbbmV4dFNdLnQgLSB0aW1lKSAvIGR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IHJlcGVhdCArIDE7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IHN0YXJ0TnVtYmVyICsgc2VnbWVudHMubGVuZ3RoICsgY291bnQ7XG4gICAgdmFyIG51bWJlciA9IHN0YXJ0TnVtYmVyICsgc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG51bWJlciA8IGVuZCkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHRpbWVsaW5lOiB0aW1lbGluZVxuICAgICAgfSk7XG4gICAgICB0aW1lICs9IGR1cmF0aW9uO1xuICAgICAgbnVtYmVyKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxudmFyIGlkZW50aWZpZXJQYXR0ZXJuID0gL1xcJChbQS16XSopKD86KCUwKShbMC05XSspZCk/XFwkL2c7XG4vKipcbiAqIFJlcGxhY2VzIHRlbXBsYXRlIGlkZW50aWZpZXJzIHdpdGggY29ycmVzcG9uZGluZyB2YWx1ZXMuIFRvIGJlIHVzZWQgYXMgdGhlIGNhbGxiYWNrXG4gKiBmb3IgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gKlxuICogQG5hbWUgcmVwbGFjZUNhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICogICAgICAgIEVudGlyZSBtYXRjaCBvZiBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllclxuICogICAgICAgIE5hbWUgb2YgbWF0Y2hlZCBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0XG4gKiAgICAgICAgRm9ybWF0IHRhZyBzdHJpbmcuIEl0cyBwcmVzZW5jZSBpbmRpY2F0ZXMgdGhhdCBwYWRkaW5nIGlzIGV4cGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhcbiAqICAgICAgICBEZXNpcmVkIGxlbmd0aCBvZiB0aGUgcmVwbGFjZWQgdmFsdWUuIFZhbHVlcyBsZXNzIHRoYW4gdGhpcyB3aWR0aCBzaGFsbCBiZSBsZWZ0XG4gKiAgICAgICAgemVybyBwYWRkZWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgUmVwbGFjZW1lbnQgZm9yIHRoZSBtYXRjaGVkIGlkZW50aWZpZXJcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGFzIGEgY2FsbGJhY2sgZm9yIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSB0byByZXBsYWNlXG4gKiB0ZW1wbGF0ZSBpZGVudGlmaWVyc1xuICpcbiAqIEBwYXJhbSB7T2JlY3R9IHZhbHVlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHZhbHVlcyB0aGF0IHNoYWxsIGJlIHVzZWQgdG8gcmVwbGFjZSBrbm93biBpZGVudGlmaWVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5SZXByZXNlbnRhdGlvbklEXG4gKiAgICAgICAgVmFsdWUgb2YgdGhlIFJlcHJlc2VudGF0aW9uQGlkIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5OdW1iZXJcbiAqICAgICAgICBOdW1iZXIgb2YgdGhlIGNvcnJlc3BvbmRpbmcgc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5CYW5kd2lkdGhcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AYmFuZHdpZHRoIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZXMuVGltZVxuICogICAgICAgIFRpbWVzdGFtcCB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcmV0dXJuIHtyZXBsYWNlQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIHRvIGJlIHVzZWQgd2l0aCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UgdG8gcmVwbGFjZSBpZGVudGlmaWVyc1xuICovXG5cbnZhciBpZGVudGlmaWVyUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBpZGVudGlmaWVyUmVwbGFjZW1lbnQodmFsdWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIGlkZW50aWZpZXIsIGZvcm1hdCwgd2lkdGgpIHtcbiAgICBpZiAobWF0Y2ggPT09ICckJCcpIHtcbiAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgcmV0dXJuICckJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlc1tpZGVudGlmaWVyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSAnJyArIHZhbHVlc1tpZGVudGlmaWVyXTtcblxuICAgIGlmIChpZGVudGlmaWVyID09PSAnUmVwcmVzZW50YXRpb25JRCcpIHtcbiAgICAgIC8vIEZvcm1hdCB0YWcgc2hhbGwgbm90IGJlIHByZXNlbnQgd2l0aCBSZXByZXNlbnRhdGlvbklEXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gd2lkdGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIiArIG5ldyBBcnJheSh3aWR0aCAtIHZhbHVlLmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHZhbHVlO1xuICB9O1xufTtcbi8qKlxuICogQ29uc3RydWN0cyBhIHNlZ21lbnQgdXJsIGZyb20gYSB0ZW1wbGF0ZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiAgICAgICAgVGVtcGxhdGUgc3RyaW5nIHRvIGNvbnN0cnVjdCB1cmwgZnJvbVxuICogQHBhcmFtIHtPYmVjdH0gdmFsdWVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdmFsdWVzIHRoYXQgc2hhbGwgYmUgdXNlZCB0byByZXBsYWNlIGtub3duIGlkZW50aWZpZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLlJlcHJlc2VudGF0aW9uSURcbiAqICAgICAgICBWYWx1ZSBvZiB0aGUgUmVwcmVzZW50YXRpb25AaWQgYXR0cmlidXRlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLk51bWJlclxuICogICAgICAgIE51bWJlciBvZiB0aGUgY29ycmVzcG9uZGluZyBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVzLkJhbmR3aWR0aFxuICogICAgICAgIFZhbHVlIG9mIHRoZSBSZXByZXNlbnRhdGlvbkBiYW5kd2lkdGggYXR0cmlidXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlcy5UaW1lXG4gKiAgICAgICAgVGltZXN0YW1wIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIHNlZ21lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgU2VnbWVudCB1cmwgd2l0aCBpZGVudGlmaWVycyByZXBsYWNlZFxuICovXG5cbnZhciBjb25zdHJ1Y3RUZW1wbGF0ZVVybCA9IGZ1bmN0aW9uIGNvbnN0cnVjdFRlbXBsYXRlVXJsKHVybCwgdmFsdWVzKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZShpZGVudGlmaWVyUGF0dGVybiwgaWRlbnRpZmllclJlcGxhY2VtZW50KHZhbHVlcykpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvcm1hdGlvbiBhYm91dCBlYWNoXG4gKiBzZWdtZW50IG5lZWRlZCB0byBnZW5lcmF0ZSBzZWdtZW50IHVyaXMgYW5kIHRoZSBjb21wbGV0ZSBzZWdtZW50IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIGluaGVyaXRlZCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50IGVsZW1lbnRzIHdpdGggYXR0cmlidXRlXG4gKiAgICAgICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3RbXXx1bmRlZmluZWR9IHNlZ21lbnRUaW1lbGluZVxuICogICAgICAgIExpc3Qgb2Ygb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZXMgb2YgZWFjaCBTIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpblxuICogICAgICAgIHRoZSBTZWdtZW50VGltZWxpbmUgZWxlbWVudFxuICogQHJldHVybiB7e251bWJlcjogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyLCB0aW1lOiBudW1iZXIsIHRpbWVsaW5lOiBudW1iZXJ9W119XG4gKiAgICAgICAgIExpc3Qgb2YgT2JqZWN0cyB3aXRoIHNlZ21lbnQgdGltaW5nIGFuZCBkdXJhdGlvbiBpbmZvXG4gKi9cblxudmFyIHBhcnNlVGVtcGxhdGVJbmZvID0gZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZUluZm8oYXR0cmlidXRlcywgc2VnbWVudFRpbWVsaW5lKSB7XG4gIGlmICghYXR0cmlidXRlcy5kdXJhdGlvbiAmJiAhc2VnbWVudFRpbWVsaW5lKSB7XG4gICAgLy8gaWYgbmVpdGhlciBAZHVyYXRpb24gb3IgU2VnbWVudFRpbWVsaW5lIGFyZSBwcmVzZW50LCB0aGVuIHRoZXJlIHNoYWxsIGJlIGV4YWN0bHlcbiAgICAvLyBvbmUgbWVkaWEgc2VnbWVudFxuICAgIHJldHVybiBbe1xuICAgICAgbnVtYmVyOiBhdHRyaWJ1dGVzLnN0YXJ0TnVtYmVyIHx8IDEsXG4gICAgICBkdXJhdGlvbjogYXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbixcbiAgICAgIHRpbWU6IDAsXG4gICAgICB0aW1lbGluZTogYXR0cmlidXRlcy5wZXJpb2RTdGFydFxuICAgIH1dO1xuICB9XG5cbiAgaWYgKGF0dHJpYnV0ZXMuZHVyYXRpb24pIHtcbiAgICByZXR1cm4gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQnlUaW1lbGluZShhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgbGlzdCBvZiBzZWdtZW50cyB1c2luZyBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSB0aGUgU2VnbWVudFRlbXBsYXRlIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICAgICAgIG5hbWVzIGFzIGtleXNcbiAqIEBwYXJhbSB7T2JqZWN0W118dW5kZWZpbmVkfSBzZWdtZW50VGltZWxpbmVcbiAqICAgICAgICBMaXN0IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGVzIG9mIGVhY2ggUyBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW5cbiAqICAgICAgICB0aGUgU2VnbWVudFRpbWVsaW5lIGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICogICAgICAgICBMaXN0IG9mIHNlZ21lbnQgb2JqZWN0c1xuICovXG5cbnZhciBzZWdtZW50c0Zyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uIHNlZ21lbnRzRnJvbVRlbXBsYXRlKGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSkge1xuICB2YXIgdGVtcGxhdGVWYWx1ZXMgPSB7XG4gICAgUmVwcmVzZW50YXRpb25JRDogYXR0cmlidXRlcy5pZCxcbiAgICBCYW5kd2lkdGg6IGF0dHJpYnV0ZXMuYmFuZHdpZHRoIHx8IDBcbiAgfTtcbiAgdmFyIF9hdHRyaWJ1dGVzJGluaXRpYWxpeiA9IGF0dHJpYnV0ZXMuaW5pdGlhbGl6YXRpb24sXG4gICAgICBpbml0aWFsaXphdGlvbiA9IF9hdHRyaWJ1dGVzJGluaXRpYWxpeiA9PT0gdm9pZCAwID8ge1xuICAgIHNvdXJjZVVSTDogJycsXG4gICAgcmFuZ2U6ICcnXG4gIH0gOiBfYXR0cmlidXRlcyRpbml0aWFsaXo7XG4gIHZhciBtYXBTZWdtZW50ID0gdXJsVHlwZVRvU2VnbWVudCh7XG4gICAgYmFzZVVybDogYXR0cmlidXRlcy5iYXNlVXJsLFxuICAgIHNvdXJjZTogY29uc3RydWN0VGVtcGxhdGVVcmwoaW5pdGlhbGl6YXRpb24uc291cmNlVVJMLCB0ZW1wbGF0ZVZhbHVlcyksXG4gICAgcmFuZ2U6IGluaXRpYWxpemF0aW9uLnJhbmdlXG4gIH0pO1xuICB2YXIgc2VnbWVudHMgPSBwYXJzZVRlbXBsYXRlSW5mbyhhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xuICByZXR1cm4gc2VnbWVudHMubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgdGVtcGxhdGVWYWx1ZXMuTnVtYmVyID0gc2VnbWVudC5udW1iZXI7XG4gICAgdGVtcGxhdGVWYWx1ZXMuVGltZSA9IHNlZ21lbnQudGltZTtcbiAgICB2YXIgdXJpID0gY29uc3RydWN0VGVtcGxhdGVVcmwoYXR0cmlidXRlcy5tZWRpYSB8fCAnJywgdGVtcGxhdGVWYWx1ZXMpOyAvLyBTZWUgREFTSCBzcGVjIHNlY3Rpb24gNS4zLjkuMi4yXG4gICAgLy8gLSBpZiB0aW1lc2NhbGUgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMS5cblxuICAgIHZhciB0aW1lc2NhbGUgPSBhdHRyaWJ1dGVzLnRpbWVzY2FsZSB8fCAxOyAvLyAtIGlmIHByZXNlbnRhdGlvblRpbWVPZmZzZXQgaXNuJ3QgcHJlc2VudCBvbiBhbnkgbGV2ZWwsIGRlZmF1bHQgdG8gMFxuXG4gICAgdmFyIHByZXNlbnRhdGlvblRpbWVPZmZzZXQgPSBhdHRyaWJ1dGVzLnByZXNlbnRhdGlvblRpbWVPZmZzZXQgfHwgMDtcbiAgICB2YXIgcHJlc2VudGF0aW9uVGltZSA9IC8vIEV2ZW4gaWYgdGhlIEB0IGF0dHJpYnV0ZSBpcyBub3Qgc3BlY2lmaWVkIGZvciB0aGUgc2VnbWVudCwgc2VnbWVudC50aW1lIGlzXG4gICAgLy8gY2FsY3VsYXRlZCBpbiBtcGQtcGFyc2VyIHByaW9yIHRvIHRoaXMsIHNvIGl0J3MgYXNzdW1lZCB0byBiZSBhdmFpbGFibGUuXG4gICAgYXR0cmlidXRlcy5wZXJpb2RTdGFydCArIChzZWdtZW50LnRpbWUgLSBwcmVzZW50YXRpb25UaW1lT2Zmc2V0KSAvIHRpbWVzY2FsZTtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdXJpOiB1cmksXG4gICAgICB0aW1lbGluZTogc2VnbWVudC50aW1lbGluZSxcbiAgICAgIGR1cmF0aW9uOiBzZWdtZW50LmR1cmF0aW9uLFxuICAgICAgcmVzb2x2ZWRVcmk6IHJlc29sdmVVcmwoYXR0cmlidXRlcy5iYXNlVXJsIHx8ICcnLCB1cmkpLFxuICAgICAgbWFwOiBtYXBTZWdtZW50LFxuICAgICAgbnVtYmVyOiBzZWdtZW50Lm51bWJlcixcbiAgICAgIHByZXNlbnRhdGlvblRpbWU6IHByZXNlbnRhdGlvblRpbWVcbiAgICB9O1xuICAgIHJldHVybiBtYXA7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIDxTZWdtZW50VXJsPiAob2YgdHlwZSBVUkxUeXBlIGZyb20gdGhlIERBU0ggc3BlYyA1LjMuOS4yIFRhYmxlIDE0KVxuICogdG8gYW4gb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgb3V0cHV0IG9mIGEgc2VnbWVudCBpbiB2aWRlb2pzL21wZC1wYXJzZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICBPYmplY3QgY29udGFpbmluZyBhbGwgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgZWxlbWVudHMgd2l0aCBhdHRyaWJ1dGVcbiAqICAgbmFtZXMgYXMga2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRVcmxcbiAqICAgPFNlZ21lbnRVUkw+IG5vZGUgdG8gdHJhbnNsYXRlIGludG8gYSBzZWdtZW50IG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSB0cmFuc2xhdGVkIHNlZ21lbnQgb2JqZWN0XG4gKi9cblxudmFyIFNlZ21lbnRVUkxUb1NlZ21lbnRPYmplY3QgPSBmdW5jdGlvbiBTZWdtZW50VVJMVG9TZWdtZW50T2JqZWN0KGF0dHJpYnV0ZXMsIHNlZ21lbnRVcmwpIHtcbiAgdmFyIGJhc2VVcmwgPSBhdHRyaWJ1dGVzLmJhc2VVcmwsXG4gICAgICBfYXR0cmlidXRlcyRpbml0aWFsaXogPSBhdHRyaWJ1dGVzLmluaXRpYWxpemF0aW9uLFxuICAgICAgaW5pdGlhbGl6YXRpb24gPSBfYXR0cmlidXRlcyRpbml0aWFsaXogPT09IHZvaWQgMCA/IHt9IDogX2F0dHJpYnV0ZXMkaW5pdGlhbGl6O1xuICB2YXIgaW5pdFNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgIHNvdXJjZTogaW5pdGlhbGl6YXRpb24uc291cmNlVVJMLFxuICAgIHJhbmdlOiBpbml0aWFsaXphdGlvbi5yYW5nZVxuICB9KTtcbiAgdmFyIHNlZ21lbnQgPSB1cmxUeXBlVG9TZWdtZW50KHtcbiAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgIHNvdXJjZTogc2VnbWVudFVybC5tZWRpYSxcbiAgICByYW5nZTogc2VnbWVudFVybC5tZWRpYVJhbmdlXG4gIH0pO1xuICBzZWdtZW50Lm1hcCA9IGluaXRTZWdtZW50O1xuICByZXR1cm4gc2VnbWVudDtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhIGxpc3Qgb2Ygc2VnbWVudHMgdXNpbmcgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkgdGhlIFNlZ21lbnRMaXN0IGVsZW1lbnRcbiAqIFNlZ21lbnRMaXN0IChEQVNIIFNQRUMgU2VjdGlvbiA1LjMuOS4zLjIpIGNvbnRhaW5zIGEgc2V0IG9mIDxTZWdtZW50VVJMPiBub2Rlcy4gIEVhY2hcbiAqIG5vZGUgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgaW50byBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiAgIE9iamVjdCBjb250YWluaW5nIGFsbCBpbmhlcml0ZWQgYXR0cmlidXRlcyBmcm9tIHBhcmVudCBlbGVtZW50cyB3aXRoIGF0dHJpYnV0ZVxuICogICBuYW1lcyBhcyBrZXlzXG4gKiBAcGFyYW0ge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgTGlzdCBvZiBvYmplY3RzIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIFMgZWxlbWVudCBjb250YWluZWQgd2l0aGluXG4gKiAgICAgICAgdGhlIFNlZ21lbnRUaW1lbGluZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3QuPEFycmF5Pn0gbGlzdCBvZiBzZWdtZW50c1xuICovXG5cblxudmFyIHNlZ21lbnRzRnJvbUxpc3QgPSBmdW5jdGlvbiBzZWdtZW50c0Zyb21MaXN0KGF0dHJpYnV0ZXMsIHNlZ21lbnRUaW1lbGluZSkge1xuICB2YXIgZHVyYXRpb24gPSBhdHRyaWJ1dGVzLmR1cmF0aW9uLFxuICAgICAgX2F0dHJpYnV0ZXMkc2VnbWVudFVyID0gYXR0cmlidXRlcy5zZWdtZW50VXJscyxcbiAgICAgIHNlZ21lbnRVcmxzID0gX2F0dHJpYnV0ZXMkc2VnbWVudFVyID09PSB2b2lkIDAgPyBbXSA6IF9hdHRyaWJ1dGVzJHNlZ21lbnRVcixcbiAgICAgIHBlcmlvZFN0YXJ0ID0gYXR0cmlidXRlcy5wZXJpb2RTdGFydDsgLy8gUGVyIHNwZWMgKDUuMy45LjIuMSkgbm8gd2F5IHRvIGRldGVybWluZSBzZWdtZW50IGR1cmF0aW9uIE9SXG4gIC8vIGlmIGJvdGggU2VnbWVudFRpbWVsaW5lIGFuZCBAZHVyYXRpb24gYXJlIGRlZmluZWQsIGl0IGlzIG91dHNpZGUgb2Ygc3BlYy5cblxuICBpZiAoIWR1cmF0aW9uICYmICFzZWdtZW50VGltZWxpbmUgfHwgZHVyYXRpb24gJiYgc2VnbWVudFRpbWVsaW5lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TRUdNRU5UX1RJTUVfVU5TUEVDSUZJRUQpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRVcmxNYXAgPSBzZWdtZW50VXJscy5tYXAoZnVuY3Rpb24gKHNlZ21lbnRVcmxPYmplY3QpIHtcbiAgICByZXR1cm4gU2VnbWVudFVSTFRvU2VnbWVudE9iamVjdChhdHRyaWJ1dGVzLCBzZWdtZW50VXJsT2JqZWN0KTtcbiAgfSk7XG4gIHZhciBzZWdtZW50VGltZUluZm87XG5cbiAgaWYgKGR1cmF0aW9uKSB7XG4gICAgc2VnbWVudFRpbWVJbmZvID0gcGFyc2VCeUR1cmF0aW9uKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgaWYgKHNlZ21lbnRUaW1lbGluZSkge1xuICAgIHNlZ21lbnRUaW1lSW5mbyA9IHBhcnNlQnlUaW1lbGluZShhdHRyaWJ1dGVzLCBzZWdtZW50VGltZWxpbmUpO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gc2VnbWVudFRpbWVJbmZvLm1hcChmdW5jdGlvbiAoc2VnbWVudFRpbWUsIGluZGV4KSB7XG4gICAgaWYgKHNlZ21lbnRVcmxNYXBbaW5kZXhdKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRVcmxNYXBbaW5kZXhdOyAvLyBTZWUgREFTSCBzcGVjIHNlY3Rpb24gNS4zLjkuMi4yXG4gICAgICAvLyAtIGlmIHRpbWVzY2FsZSBpc24ndCBwcmVzZW50IG9uIGFueSBsZXZlbCwgZGVmYXVsdCB0byAxLlxuXG4gICAgICB2YXIgdGltZXNjYWxlID0gYXR0cmlidXRlcy50aW1lc2NhbGUgfHwgMTsgLy8gLSBpZiBwcmVzZW50YXRpb25UaW1lT2Zmc2V0IGlzbid0IHByZXNlbnQgb24gYW55IGxldmVsLCBkZWZhdWx0IHRvIDBcblxuICAgICAgdmFyIHByZXNlbnRhdGlvblRpbWVPZmZzZXQgPSBhdHRyaWJ1dGVzLnByZXNlbnRhdGlvblRpbWVPZmZzZXQgfHwgMDtcbiAgICAgIHNlZ21lbnQudGltZWxpbmUgPSBzZWdtZW50VGltZS50aW1lbGluZTtcbiAgICAgIHNlZ21lbnQuZHVyYXRpb24gPSBzZWdtZW50VGltZS5kdXJhdGlvbjtcbiAgICAgIHNlZ21lbnQubnVtYmVyID0gc2VnbWVudFRpbWUubnVtYmVyO1xuICAgICAgc2VnbWVudC5wcmVzZW50YXRpb25UaW1lID0gcGVyaW9kU3RhcnQgKyAoc2VnbWVudFRpbWUudGltZSAtIHByZXNlbnRhdGlvblRpbWVPZmZzZXQpIC8gdGltZXNjYWxlO1xuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgfSAvLyBTaW5jZSB3ZSdyZSBtYXBwaW5nIHdlIHNob3VsZCBnZXQgcmlkIG9mIGFueSBibGFuayBzZWdtZW50cyAoaW4gY2FzZVxuICAgIC8vIHRoZSBnaXZlbiBTZWdtZW50VGltZWxpbmUgaXMgaGFuZGxpbmcgZm9yIG1vcmUgZWxlbWVudHMgdGhhbiB3ZSBoYXZlXG4gICAgLy8gU2VnbWVudFVSTHMgZm9yKS5cblxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gc2VnbWVudDtcbiAgfSk7XG4gIHJldHVybiBzZWdtZW50cztcbn07XG5cbnZhciBnZW5lcmF0ZVNlZ21lbnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50cyhfcmVmKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgc2VnbWVudEluZm8gPSBfcmVmLnNlZ21lbnRJbmZvO1xuICB2YXIgc2VnbWVudEF0dHJpYnV0ZXM7XG4gIHZhciBzZWdtZW50c0ZuO1xuXG4gIGlmIChzZWdtZW50SW5mby50ZW1wbGF0ZSkge1xuICAgIHNlZ21lbnRzRm4gPSBzZWdtZW50c0Zyb21UZW1wbGF0ZTtcbiAgICBzZWdtZW50QXR0cmlidXRlcyA9IG1lcmdlKGF0dHJpYnV0ZXMsIHNlZ21lbnRJbmZvLnRlbXBsYXRlKTtcbiAgfSBlbHNlIGlmIChzZWdtZW50SW5mby5iYXNlKSB7XG4gICAgc2VnbWVudHNGbiA9IHNlZ21lbnRzRnJvbUJhc2U7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby5iYXNlKTtcbiAgfSBlbHNlIGlmIChzZWdtZW50SW5mby5saXN0KSB7XG4gICAgc2VnbWVudHNGbiA9IHNlZ21lbnRzRnJvbUxpc3Q7XG4gICAgc2VnbWVudEF0dHJpYnV0ZXMgPSBtZXJnZShhdHRyaWJ1dGVzLCBzZWdtZW50SW5mby5saXN0KTtcbiAgfVxuXG4gIHZhciBzZWdtZW50c0luZm8gPSB7XG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICB9O1xuXG4gIGlmICghc2VnbWVudHNGbikge1xuICAgIHJldHVybiBzZWdtZW50c0luZm87XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBzZWdtZW50c0ZuKHNlZ21lbnRBdHRyaWJ1dGVzLCBzZWdtZW50SW5mby5zZWdtZW50VGltZWxpbmUpOyAvLyBUaGUgQGR1cmF0aW9uIGF0dHJpYnV0ZSB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW4gdGhlIHBsYXlsaXN0J3MgdGFyZ2V0RHVyYXRpb24gd2hpY2hcbiAgLy8gbXVzdCBiZSBpbiBzZWNvbmRzLiBTaW5jZSB3ZSd2ZSBnZW5lcmF0ZWQgdGhlIHNlZ21lbnQgbGlzdCwgd2Ugbm8gbG9uZ2VyIG5lZWRcbiAgLy8gQGR1cmF0aW9uIHRvIGJlIGluIEB0aW1lc2NhbGUgdW5pdHMsIHNvIHdlIGNhbiBjb252ZXJ0IGl0IGhlcmUuXG5cbiAgaWYgKHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uKSB7XG4gICAgdmFyIF9zZWdtZW50QXR0cmlidXRlcyA9IHNlZ21lbnRBdHRyaWJ1dGVzLFxuICAgICAgICBkdXJhdGlvbiA9IF9zZWdtZW50QXR0cmlidXRlcy5kdXJhdGlvbixcbiAgICAgICAgX3NlZ21lbnRBdHRyaWJ1dGVzJHRpID0gX3NlZ21lbnRBdHRyaWJ1dGVzLnRpbWVzY2FsZSxcbiAgICAgICAgdGltZXNjYWxlID0gX3NlZ21lbnRBdHRyaWJ1dGVzJHRpID09PSB2b2lkIDAgPyAxIDogX3NlZ21lbnRBdHRyaWJ1dGVzJHRpO1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uID0gZHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gQGR1cmF0aW9uIGF0dHJpYnV0ZSwgdXNlIHRoZSBsYXJnZXN0IHNlZ21lbnQgZHVyYXRpb24gYXNcbiAgICAvLyBhcyB0YXJnZXQgZHVyYXRpb25cbiAgICBzZWdtZW50QXR0cmlidXRlcy5kdXJhdGlvbiA9IHNlZ21lbnRzLnJlZHVjZShmdW5jdGlvbiAobWF4LCBzZWdtZW50KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBNYXRoLmNlaWwoc2VnbWVudC5kdXJhdGlvbikpO1xuICAgIH0sIDApO1xuICB9IGVsc2Uge1xuICAgIHNlZ21lbnRBdHRyaWJ1dGVzLmR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHNlZ21lbnRzSW5mby5hdHRyaWJ1dGVzID0gc2VnbWVudEF0dHJpYnV0ZXM7XG4gIHNlZ21lbnRzSW5mby5zZWdtZW50cyA9IHNlZ21lbnRzOyAvLyBUaGlzIGlzIGEgc2lkeCBib3ggd2l0aG91dCBhY3R1YWwgc2VnbWVudCBpbmZvcm1hdGlvblxuXG4gIGlmIChzZWdtZW50SW5mby5iYXNlICYmIHNlZ21lbnRBdHRyaWJ1dGVzLmluZGV4UmFuZ2UpIHtcbiAgICBzZWdtZW50c0luZm8uc2lkeCA9IHNlZ21lbnRzWzBdO1xuICAgIHNlZ21lbnRzSW5mby5zZWdtZW50cyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzSW5mbztcbn07XG52YXIgdG9QbGF5bGlzdHMgPSBmdW5jdGlvbiB0b1BsYXlsaXN0cyhyZXByZXNlbnRhdGlvbnMpIHtcbiAgcmV0dXJuIHJlcHJlc2VudGF0aW9ucy5tYXAoZ2VuZXJhdGVTZWdtZW50cyk7XG59O1xuXG52YXIgZmluZENoaWxkcmVuID0gZnVuY3Rpb24gZmluZENoaWxkcmVuKGVsZW1lbnQsIG5hbWUpIHtcbiAgcmV0dXJuIGZyb20oZWxlbWVudC5jaGlsZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgdGFnTmFtZSA9IF9yZWYudGFnTmFtZTtcbiAgICByZXR1cm4gdGFnTmFtZSA9PT0gbmFtZTtcbiAgfSk7XG59O1xudmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbiBnZXRDb250ZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBkaXZpc2lvbiBvcGVyYXRpb24gdG8gYSBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIHByb3ZpZGVkIHN0cmluZyB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHBhcnNlZCBzdHJpbmcgdmFsdWVcbiAqL1xudmFyIHBhcnNlRGl2aXNpb25WYWx1ZSA9IGZ1bmN0aW9uIHBhcnNlRGl2aXNpb25WYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5zcGxpdCgnLycpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VycmVudCkge1xuICAgIHJldHVybiBwcmV2IC8gY3VycmVudDtcbiAgfSkpO1xufTtcblxudmFyIHBhcnNlRHVyYXRpb24gPSBmdW5jdGlvbiBwYXJzZUR1cmF0aW9uKHN0cikge1xuICB2YXIgU0VDT05EU19JTl9ZRUFSID0gMzY1ICogMjQgKiA2MCAqIDYwO1xuICB2YXIgU0VDT05EU19JTl9NT05USCA9IDMwICogMjQgKiA2MCAqIDYwO1xuICB2YXIgU0VDT05EU19JTl9EQVkgPSAyNCAqIDYwICogNjA7XG4gIHZhciBTRUNPTkRTX0lOX0hPVVIgPSA2MCAqIDYwO1xuICB2YXIgU0VDT05EU19JTl9NSU4gPSA2MDsgLy8gUDEwWTEwTTEwRFQxMEgxME0xMC4xU1xuXG4gIHZhciBkdXJhdGlvblJlZ2V4ID0gL1AoPzooXFxkKilZKT8oPzooXFxkKilNKT8oPzooXFxkKilEKT8oPzpUKD86KFxcZCopSCk/KD86KFxcZCopTSk/KD86KFtcXGQuXSopUyk/KT8vO1xuICB2YXIgbWF0Y2ggPSBkdXJhdGlvblJlZ2V4LmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgX21hdGNoJHNsaWNlID0gbWF0Y2guc2xpY2UoMSksXG4gICAgICB5ZWFyID0gX21hdGNoJHNsaWNlWzBdLFxuICAgICAgbW9udGggPSBfbWF0Y2gkc2xpY2VbMV0sXG4gICAgICBkYXkgPSBfbWF0Y2gkc2xpY2VbMl0sXG4gICAgICBob3VyID0gX21hdGNoJHNsaWNlWzNdLFxuICAgICAgbWludXRlID0gX21hdGNoJHNsaWNlWzRdLFxuICAgICAgc2Vjb25kID0gX21hdGNoJHNsaWNlWzVdO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHllYXIgfHwgMCkgKiBTRUNPTkRTX0lOX1lFQVIgKyBwYXJzZUZsb2F0KG1vbnRoIHx8IDApICogU0VDT05EU19JTl9NT05USCArIHBhcnNlRmxvYXQoZGF5IHx8IDApICogU0VDT05EU19JTl9EQVkgKyBwYXJzZUZsb2F0KGhvdXIgfHwgMCkgKiBTRUNPTkRTX0lOX0hPVVIgKyBwYXJzZUZsb2F0KG1pbnV0ZSB8fCAwKSAqIFNFQ09ORFNfSU5fTUlOICsgcGFyc2VGbG9hdChzZWNvbmQgfHwgMCk7XG59O1xudmFyIHBhcnNlRGF0ZSA9IGZ1bmN0aW9uIHBhcnNlRGF0ZShzdHIpIHtcbiAgLy8gRGF0ZSBmb3JtYXQgd2l0aG91dCB0aW1lem9uZSBhY2NvcmRpbmcgdG8gSVNPIDg2MDFcbiAgLy8gWVlZLU1NLUREVGhoOm1tOnNzLnNzc3Nzc1xuICB2YXIgZGF0ZVJlZ2V4ID0gL15cXGQrLVxcZCstXFxkK1RcXGQrOlxcZCs6XFxkKyhcXC5cXGQrKT8kLzsgLy8gSWYgdGhlIGRhdGUgc3RyaW5nIGRvZXMgbm90IHNwZWNpZml5IGEgdGltZXpvbmUsIHdlIG11c3Qgc3BlY2lmaXkgVVRDLiBUaGlzIGlzXG4gIC8vIGV4cHJlc3NlZCBieSBlbmRpbmcgd2l0aCAnWidcblxuICBpZiAoZGF0ZVJlZ2V4LnRlc3Qoc3RyKSkge1xuICAgIHN0ciArPSAnWic7XG4gIH1cblxuICByZXR1cm4gRGF0ZS5wYXJzZShzdHIpO1xufTtcblxudmFyIHBhcnNlcnMgPSB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBlbnRpcmUgTWVkaWEgUHJlc2VudGF0aW9uLiBGb3JtYXQgaXMgYSBkdXJhdGlvbiBzdHJpbmdcbiAgICogYXMgc3BlY2lmaWVkIGluIElTTyA4NjAxXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKi9cbiAgbWVkaWFQcmVzZW50YXRpb25EdXJhdGlvbjogZnVuY3Rpb24gbWVkaWFQcmVzZW50YXRpb25EdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBTZWdtZW50IGF2YWlsYWJpbGl0eSBzdGFydCB0aW1lIGZvciBhbGwgU2VnbWVudHMgcmVmZXJyZWQgdG8gaW4gdGhpc1xuICAgKiBNUEQuIEZvciBhIGR5bmFtaWMgbWFuaWZlc3QsIGl0IHNwZWNpZmllcyB0aGUgYW5jaG9yIGZvciB0aGUgZWFybGllc3QgYXZhaWxhYmlsaXR5XG4gICAqIHRpbWUuIEZvcm1hdCBpcyBhIGRhdGUgc3RyaW5nIGFzIHNwZWNpZmllZCBpbiBJU08gODYwMVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRhdGUgYXMgc2Vjb25kcyBmcm9tIHVuaXggZXBvY2hcbiAgICovXG4gIGF2YWlsYWJpbGl0eVN0YXJ0VGltZTogZnVuY3Rpb24gYXZhaWxhYmlsaXR5U3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRGF0ZSh2YWx1ZSkgLyAxMDAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHNtYWxsZXN0IHBlcmlvZCBiZXR3ZWVuIHBvdGVudGlhbCBjaGFuZ2VzIHRvIHRoZSBNUEQuIEZvcm1hdCBpcyBhXG4gICAqIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICBtaW5pbXVtVXBkYXRlUGVyaW9kOiBmdW5jdGlvbiBtaW5pbXVtVXBkYXRlUGVyaW9kKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRHVyYXRpb24odmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHN1Z2dlc3RlZCBwcmVzZW50YXRpb24gZGVsYXkuIEZvcm1hdCBpcyBhXG4gICAqIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICBzdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheTogZnVuY3Rpb24gc3VnZ2VzdGVkUHJlc2VudGF0aW9uRGVsYXkodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNwZWNpZmljZXMgdGhlIHR5cGUgb2YgbXBkLiBDYW4gYmUgZWl0aGVyIFwic3RhdGljXCIgb3IgXCJkeW5hbWljXCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB0eXBlIGFzIGEgc3RyaW5nXG4gICAqL1xuICB0eXBlOiBmdW5jdGlvbiB0eXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBzbWFsbGVzdCB0aW1lIHNoaWZ0aW5nIGJ1ZmZlciBmb3IgYW55IFJlcHJlc2VudGF0aW9uXG4gICAqIGluIHRoZSBNUEQuIEZvcm1hdCBpcyBhIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICB0aW1lU2hpZnRCdWZmZXJEZXB0aDogZnVuY3Rpb24gdGltZVNoaWZ0QnVmZmVyRGVwdGgodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgUGVyaW9kU3RhcnQgdGltZSBvZiB0aGUgUGVyaW9kIHJlbGF0aXZlIHRvIHRoZSBhdmFpbGFiaWxpdHlTdGFydHRpbWUuXG4gICAqIEZvcm1hdCBpcyBhIGR1cmF0aW9uIHN0cmluZyBhcyBzcGVjaWZpZWQgaW4gSVNPIDg2MDFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqL1xuICBzdGFydDogZnVuY3Rpb24gc3RhcnQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VEdXJhdGlvbih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgd2lkdGggb2YgdGhlIHZpc3VhbCBwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgd2lkdGhcbiAgICovXG4gIHdpZHRoOiBmdW5jdGlvbiB3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGhlaWdodCBvZiB0aGUgdmlzdWFsIHByZXNlbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBoZWlnaHRcbiAgICovXG4gIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgYml0cmF0ZSBvZiB0aGUgcmVwcmVzZW50YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgYmFuZHdpZHRoXG4gICAqL1xuICBiYW5kd2lkdGg6IGZ1bmN0aW9uIGJhbmR3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGZyYW1lIHJhdGUgb2YgdGhlIHJlcHJlc2VudGF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgdmFsdWUgb2YgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIGZyYW1lIHJhdGVcbiAgICovXG4gIGZyYW1lUmF0ZTogZnVuY3Rpb24gZnJhbWVSYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRGl2aXNpb25WYWx1ZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRoZSBmaXJzdCBNZWRpYSBTZWdtZW50IGluIHRoaXMgUmVwcmVzZW50YXRpb24gaW4gdGhlIFBlcmlvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBudW1iZXJcbiAgICovXG4gIHN0YXJ0TnVtYmVyOiBmdW5jdGlvbiBzdGFydE51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHRpbWVzY2FsZSBpbiB1bml0cyBwZXIgc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCB0aW1lc2NhbGVcbiAgICovXG4gIHRpbWVzY2FsZTogZnVuY3Rpb24gdGltZXNjYWxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgcHJlc2VudGF0aW9uVGltZU9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGFzIGEgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGFyc2VkIHByZXNlbnRhdGlvblRpbWVPZmZzZXRcbiAgICovXG4gIHByZXNlbnRhdGlvblRpbWVPZmZzZXQ6IGZ1bmN0aW9uIHByZXNlbnRhdGlvblRpbWVPZmZzZXQodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBjb25zdGFudCBhcHByb3hpbWF0ZSBTZWdtZW50IGR1cmF0aW9uXG4gICAqIE5PVEU6IFRoZSA8UGVyaW9kPiBlbGVtZW50IGFsc28gY29udGFpbnMgYW4gQGR1cmF0aW9uIGF0dHJpYnV0ZS4gVGhpcyBkdXJhdGlvblxuICAgKiAgICAgICBzcGVjaWZpZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSBQZXJpb2QuIFRoaXMgYXR0cmlidXRlIGlzIGN1cnJlbnRseSBub3RcbiAgICogICAgICAgc3VwcG9ydGVkIGJ5IHRoZSByZXN0IG9mIHRoZSBwYXJzZXIsIGhvd2V2ZXIgd2Ugc3RpbGwgY2hlY2sgZm9yIGl0IHRvIHByZXZlbnRcbiAgICogICAgICAgZXJyb3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBkdXJhdGlvblxuICAgKi9cbiAgZHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHBhcnNlZFZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICAgIGlmIChpc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZUR1cmF0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkVmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgU2VnbWVudCBkdXJhdGlvbiwgaW4gdW5pdHMgb2YgdGhlIHZhbHVlIG9mIHRoZSBAdGltZXNjYWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBkdXJhdGlvblxuICAgKi9cbiAgZDogZnVuY3Rpb24gZCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIE1QRCBzdGFydCB0aW1lLCBpbiBAdGltZXNjYWxlIHVuaXRzLCB0aGUgZmlyc3QgU2VnbWVudCBpbiB0aGUgc2VyaWVzXG4gICAqIHN0YXJ0cyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQZXJpb2RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwYXJzZWQgdGltZVxuICAgKi9cbiAgdDogZnVuY3Rpb24gdCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHJlcGVhdCBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGZvbGxvd2luZyBjb250aWd1b3VzIFNlZ21lbnRzIHdpdGggdGhlXG4gICAqIHNhbWUgZHVyYXRpb24gZXhwcmVzc2VkIGJ5IHRoZSB2YWx1ZSBvZiBAZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICAgICAgIHZhbHVlIG9mIGF0dHJpYnV0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBhcnNlZCBudW1iZXJcbiAgICovXG4gIHI6IGZ1bmN0aW9uIHIodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBwYXJzZXIgZm9yIGFsbCBvdGhlciBhdHRyaWJ1dGVzLiBBY3RzIGFzIGEgbm8tb3AgYW5kIGp1c3QgcmV0dXJucyB0aGUgdmFsdWVcbiAgICogYXMgYSBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICB2YWx1ZSBvZiBhdHRyaWJ1dGUgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFVucGFyc2VkIHZhbHVlXG4gICAqL1xuICBERUZBVUxUOiBmdW5jdGlvbiBERUZBVUxUKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuLyoqXG4gKiBHZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBhbmQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBub2RlLCBwYXJzZXMgYXR0cmlidXRlcyB3aXRoIGtub3duXG4gKiB0eXBlcywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYXR0cmlidXRlIG5hbWVzIG1hcHBlZCB0byB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBlbFxuICogICAgICAgIFRoZSBub2RlIHRvIHBhcnNlIGF0dHJpYnV0ZXMgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBPYmplY3Qgd2l0aCBhbGwgYXR0cmlidXRlcyBvZiBlbCBwYXJzZWRcbiAqL1xuXG52YXIgcGFyc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGVsKSB7XG4gIGlmICghKGVsICYmIGVsLmF0dHJpYnV0ZXMpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGZyb20oZWwuYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChhLCBlKSB7XG4gICAgdmFyIHBhcnNlRm4gPSBwYXJzZXJzW2UubmFtZV0gfHwgcGFyc2Vycy5ERUZBVUxUO1xuICAgIGFbZS5uYW1lXSA9IHBhcnNlRm4oZS52YWx1ZSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KTtcbn07XG5cbnZhciBrZXlTeXN0ZW1zTWFwID0ge1xuICAndXJuOnV1aWQ6MTA3N2VmZWMtYzBiMi00ZDAyLWFjZTMtM2MxZTUyZTJmYjRiJzogJ29yZy53My5jbGVhcmtleScsXG4gICd1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWQnOiAnY29tLndpZGV2aW5lLmFscGhhJyxcbiAgJ3Vybjp1dWlkOjlhMDRmMDc5LTk4NDAtNDI4Ni1hYjkyLWU2NWJlMDg4NWY5NSc6ICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeScsXG4gICd1cm46dXVpZDpmMjM5ZTc2OS1lZmEzLTQ4NTAtOWMxNi1hOTAzYzY5MzJlZmInOiAnY29tLmFkb2JlLnByaW1ldGltZSdcbn07XG4vKipcbiAqIEJ1aWxkcyBhIGxpc3Qgb2YgdXJscyB0aGF0IGlzIHRoZSBwcm9kdWN0IG9mIHRoZSByZWZlcmVuY2UgdXJscyBhbmQgQmFzZVVSTCB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSByZWZlcmVuY2VVcmxzXG4gKiAgICAgICAgTGlzdCBvZiByZWZlcmVuY2UgdXJscyB0byByZXNvbHZlIHRvXG4gKiBAcGFyYW0ge05vZGVbXX0gYmFzZVVybEVsZW1lbnRzXG4gKiAgICAgICAgTGlzdCBvZiBCYXNlVVJMIG5vZGVzIGZyb20gdGhlIG1wZFxuICogQHJldHVybiB7c3RyaW5nW119XG4gKiAgICAgICAgIExpc3Qgb2YgcmVzb2x2ZWQgdXJsc1xuICovXG5cbnZhciBidWlsZEJhc2VVcmxzID0gZnVuY3Rpb24gYnVpbGRCYXNlVXJscyhyZWZlcmVuY2VVcmxzLCBiYXNlVXJsRWxlbWVudHMpIHtcbiAgaWYgKCFiYXNlVXJsRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlZmVyZW5jZVVybHM7XG4gIH1cblxuICByZXR1cm4gZmxhdHRlbihyZWZlcmVuY2VVcmxzLm1hcChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIGJhc2VVcmxFbGVtZW50cy5tYXAoZnVuY3Rpb24gKGJhc2VVcmxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVVybChyZWZlcmVuY2UsIGdldENvbnRlbnQoYmFzZVVybEVsZW1lbnQpKTtcbiAgICB9KTtcbiAgfSkpO1xufTtcbi8qKlxuICogQ29udGFpbnMgYWxsIFNlZ21lbnQgaW5mb3JtYXRpb24gZm9yIGl0cyBjb250YWluaW5nIEFkYXB0YXRpb25TZXRcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWdtZW50SW5mb3JtYXRpb25cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fHVuZGVmaW5lZH0gdGVtcGxhdGVcbiAqICAgICAgICAgICBDb250YWlucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIFNlZ21lbnRUZW1wbGF0ZSBub2RlXG4gKiBAcHJvcGVydHkge09iamVjdFtdfHVuZGVmaW5lZH0gc2VnbWVudFRpbWVsaW5lXG4gKiAgICAgICAgICAgQ29udGFpbnMgYSBsaXN0IG9mIGF0cnJpYnV0ZXMgZm9yIGVhY2ggUyBub2RlIHdpdGhpbiB0aGUgU2VnbWVudFRpbWVsaW5lIG5vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fHVuZGVmaW5lZH0gbGlzdFxuICogICAgICAgICAgIENvbnRhaW5zIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgU2VnbWVudExpc3Qgbm9kZVxuICogQHByb3BlcnR5IHtPYmplY3R8dW5kZWZpbmVkfSBiYXNlXG4gKiAgICAgICAgICAgQ29udGFpbnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBTZWdtZW50QmFzZSBub2RlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgU2VnbWVudCBpbmZvcm1hdGlvbiBjb250YWluZWQgd2l0aGluIHRoZSBBZGFwdGF0aW9uU2V0IG5vZGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IGFkYXB0YXRpb25TZXRcbiAqICAgICAgICBUaGUgQWRhcHRhdGlvblNldCBub2RlIHRvIGdldCBTZWdtZW50IGluZm9ybWF0aW9uIGZyb21cbiAqIEByZXR1cm4ge1NlZ21lbnRJbmZvcm1hdGlvbn1cbiAqICAgICAgICAgVGhlIFNlZ21lbnQgaW5mb3JtYXRpb24gY29udGFpbmVkIHdpdGhpbiB0aGUgcHJvdmlkZWQgQWRhcHRhdGlvblNldFxuICovXG5cbnZhciBnZXRTZWdtZW50SW5mb3JtYXRpb24gPSBmdW5jdGlvbiBnZXRTZWdtZW50SW5mb3JtYXRpb24oYWRhcHRhdGlvblNldCkge1xuICB2YXIgc2VnbWVudFRlbXBsYXRlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdTZWdtZW50VGVtcGxhdGUnKVswXTtcbiAgdmFyIHNlZ21lbnRMaXN0ID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdTZWdtZW50TGlzdCcpWzBdO1xuICB2YXIgc2VnbWVudFVybHMgPSBzZWdtZW50TGlzdCAmJiBmaW5kQ2hpbGRyZW4oc2VnbWVudExpc3QsICdTZWdtZW50VVJMJykubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG1lcmdlKHtcbiAgICAgIHRhZzogJ1NlZ21lbnRVUkwnXG4gICAgfSwgcGFyc2VBdHRyaWJ1dGVzKHMpKTtcbiAgfSk7XG4gIHZhciBzZWdtZW50QmFzZSA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnU2VnbWVudEJhc2UnKVswXTtcbiAgdmFyIHNlZ21lbnRUaW1lbGluZVBhcmVudE5vZGUgPSBzZWdtZW50TGlzdCB8fCBzZWdtZW50VGVtcGxhdGU7XG4gIHZhciBzZWdtZW50VGltZWxpbmUgPSBzZWdtZW50VGltZWxpbmVQYXJlbnROb2RlICYmIGZpbmRDaGlsZHJlbihzZWdtZW50VGltZWxpbmVQYXJlbnROb2RlLCAnU2VnbWVudFRpbWVsaW5lJylbMF07XG4gIHZhciBzZWdtZW50SW5pdGlhbGl6YXRpb25QYXJlbnROb2RlID0gc2VnbWVudExpc3QgfHwgc2VnbWVudEJhc2UgfHwgc2VnbWVudFRlbXBsYXRlO1xuICB2YXIgc2VnbWVudEluaXRpYWxpemF0aW9uID0gc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSAmJiBmaW5kQ2hpbGRyZW4oc2VnbWVudEluaXRpYWxpemF0aW9uUGFyZW50Tm9kZSwgJ0luaXRpYWxpemF0aW9uJylbMF07IC8vIFNlZ21lbnRUZW1wbGF0ZSBpcyBoYW5kbGVkIHNsaWdodGx5IGRpZmZlcmVudGx5LCBzaW5jZSBpdCBjYW4gaGF2ZSBib3RoXG4gIC8vIEBpbml0aWFsaXphdGlvbiBhbmQgYW4gPEluaXRpYWxpemF0aW9uPiBub2RlLiAgQGluaXRpYWxpemF0aW9uIGNhbiBiZSB0ZW1wbGF0ZWQsXG4gIC8vIHdoaWxlIHRoZSBub2RlIGNhbiBoYXZlIGEgdXJsIGFuZCByYW5nZSBzcGVjaWZpZWQuICBJZiB0aGUgPFNlZ21lbnRUZW1wbGF0ZT4gaGFzXG4gIC8vIGJvdGggQGluaXRpYWxpemF0aW9uIGFuZCBhbiA8SW5pdGlhbGl6YXRpb24+IHN1YmVsZW1lbnQgd2Ugb3B0IHRvIG92ZXJyaWRlIHdpdGhcbiAgLy8gdGhlIG5vZGUsIGFzIHRoaXMgaW50ZXJhY3Rpb24gaXMgbm90IGRlZmluZWQgaW4gdGhlIHNwZWMuXG5cbiAgdmFyIHRlbXBsYXRlID0gc2VnbWVudFRlbXBsYXRlICYmIHBhcnNlQXR0cmlidXRlcyhzZWdtZW50VGVtcGxhdGUpO1xuXG4gIGlmICh0ZW1wbGF0ZSAmJiBzZWdtZW50SW5pdGlhbGl6YXRpb24pIHtcbiAgICB0ZW1wbGF0ZS5pbml0aWFsaXphdGlvbiA9IHNlZ21lbnRJbml0aWFsaXphdGlvbiAmJiBwYXJzZUF0dHJpYnV0ZXMoc2VnbWVudEluaXRpYWxpemF0aW9uKTtcbiAgfSBlbHNlIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5pbml0aWFsaXphdGlvbikge1xuICAgIC8vIElmIGl0IGlzIEBpbml0aWFsaXphdGlvbiB3ZSBjb252ZXJ0IGl0IHRvIGFuIG9iamVjdCBzaW5jZSB0aGlzIGlzIHRoZSBmb3JtYXQgdGhhdFxuICAgIC8vIGxhdGVyIGZ1bmN0aW9ucyB3aWxsIHJlbHkgb24gZm9yIHRoZSBpbml0aWFsaXphdGlvbiBzZWdtZW50LiAgVGhpcyBpcyBvbmx5IHZhbGlkXG4gICAgLy8gZm9yIDxTZWdtZW50VGVtcGxhdGU+XG4gICAgdGVtcGxhdGUuaW5pdGlhbGl6YXRpb24gPSB7XG4gICAgICBzb3VyY2VVUkw6IHRlbXBsYXRlLmluaXRpYWxpemF0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHZhciBzZWdtZW50SW5mbyA9IHtcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgc2VnbWVudFRpbWVsaW5lOiBzZWdtZW50VGltZWxpbmUgJiYgZmluZENoaWxkcmVuKHNlZ21lbnRUaW1lbGluZSwgJ1MnKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBwYXJzZUF0dHJpYnV0ZXMocyk7XG4gICAgfSksXG4gICAgbGlzdDogc2VnbWVudExpc3QgJiYgbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRMaXN0KSwge1xuICAgICAgc2VnbWVudFVybHM6IHNlZ21lbnRVcmxzLFxuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSksXG4gICAgYmFzZTogc2VnbWVudEJhc2UgJiYgbWVyZ2UocGFyc2VBdHRyaWJ1dGVzKHNlZ21lbnRCYXNlKSwge1xuICAgICAgaW5pdGlhbGl6YXRpb246IHBhcnNlQXR0cmlidXRlcyhzZWdtZW50SW5pdGlhbGl6YXRpb24pXG4gICAgfSlcbiAgfTtcbiAgT2JqZWN0LmtleXMoc2VnbWVudEluZm8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghc2VnbWVudEluZm9ba2V5XSkge1xuICAgICAgZGVsZXRlIHNlZ21lbnRJbmZvW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRJbmZvO1xufTtcbi8qKlxuICogQ29udGFpbnMgU2VnbWVudCBpbmZvcm1hdGlvbiBhbmQgYXR0cmlidXRlcyBuZWVkZWQgdG8gY29uc3RydWN0IGEgUGxheWxpc3Qgb2JqZWN0XG4gKiBmcm9tIGEgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge1NlZ21lbnRJbmZvcm1hdGlvbn0gc2VnbWVudEluZm9cbiAqICAgICAgICAgICBTZWdtZW50IGluZm9ybWF0aW9uIGZvciB0aGlzIFJlcHJlc2VudGF0aW9uXG4gKiBAcHJvcGVydHkge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgICAgIEluaGVyaXRlZCBhdHRyaWJ1dGVzIGZvciB0aGlzIFJlcHJlc2VudGF0aW9uXG4gKi9cblxuLyoqXG4gKiBNYXBzIGEgUmVwcmVzZW50YXRpb24gbm9kZSB0byBhbiBvYmplY3QgY29udGFpbmluZyBTZWdtZW50IGluZm9ybWF0aW9uIGFuZCBhdHRyaWJ1dGVzXG4gKlxuICogQG5hbWUgaW5oZXJpdEJhc2VVcmxzQ2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOb2RlfSByZXByZXNlbnRhdGlvblxuICogICAgICAgIFJlcHJlc2VudGF0aW9uIG5vZGUgZnJvbSB0aGUgbXBkXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9ufVxuICogICAgICAgICBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gY29uc3RydWN0IGEgUGxheWxpc3Qgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgZm9yIEFycmF5LnByb3RvdHlwZS5tYXAgZm9yIG1hcHBpbmcgUmVwcmVzZW50YXRpb24gbm9kZXMgdG9cbiAqIFNlZ21lbnQgaW5mb3JtYXRpb24gYW5kIGF0dHJpYnV0ZXMgdXNpbmcgaW5oZXJpdGVkIEJhc2VVUkwgbm9kZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFkYXB0YXRpb25TZXRBdHRyaWJ1dGVzXG4gKiAgICAgICAgQ29udGFpbnMgYXR0cmlidXRlcyBpbmhlcml0ZWQgYnkgdGhlIEFkYXB0YXRpb25TZXRcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFkYXB0YXRpb25TZXRCYXNlVXJsc1xuICogICAgICAgIENvbnRhaW5zIGxpc3Qgb2YgcmVzb2x2ZWQgYmFzZSB1cmxzIGluaGVyaXRlZCBieSB0aGUgQWRhcHRhdGlvblNldFxuICogQHBhcmFtIHtTZWdtZW50SW5mb3JtYXRpb259IGFkYXB0YXRpb25TZXRTZWdtZW50SW5mb1xuICogICAgICAgIENvbnRhaW5zIFNlZ21lbnQgaW5mb3JtYXRpb24gZm9yIHRoZSBBZGFwdGF0aW9uU2V0XG4gKiBAcmV0dXJuIHtpbmhlcml0QmFzZVVybHNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cblxudmFyIGluaGVyaXRCYXNlVXJscyA9IGZ1bmN0aW9uIGluaGVyaXRCYXNlVXJscyhhZGFwdGF0aW9uU2V0QXR0cmlidXRlcywgYWRhcHRhdGlvblNldEJhc2VVcmxzLCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXByZXNlbnRhdGlvbikge1xuICAgIHZhciByZXBCYXNlVXJsRWxlbWVudHMgPSBmaW5kQ2hpbGRyZW4ocmVwcmVzZW50YXRpb24sICdCYXNlVVJMJyk7XG4gICAgdmFyIHJlcEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhhZGFwdGF0aW9uU2V0QmFzZVVybHMsIHJlcEJhc2VVcmxFbGVtZW50cyk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBtZXJnZShhZGFwdGF0aW9uU2V0QXR0cmlidXRlcywgcGFyc2VBdHRyaWJ1dGVzKHJlcHJlc2VudGF0aW9uKSk7XG4gICAgdmFyIHJlcHJlc2VudGF0aW9uU2VnbWVudEluZm8gPSBnZXRTZWdtZW50SW5mb3JtYXRpb24ocmVwcmVzZW50YXRpb24pO1xuICAgIHJldHVybiByZXBCYXNlVXJscy5tYXAoZnVuY3Rpb24gKGJhc2VVcmwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlZ21lbnRJbmZvOiBtZXJnZShhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8sIHJlcHJlc2VudGF0aW9uU2VnbWVudEluZm8pLFxuICAgICAgICBhdHRyaWJ1dGVzOiBtZXJnZShhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgYmFzZVVybDogYmFzZVVybFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn07XG4vKipcbiAqIFRyYW5mb3JtcyBhIHNlcmllcyBvZiBjb250ZW50IHByb3RlY3Rpb24gbm9kZXMgdG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHBzc2ggZGF0YSBieSBrZXkgc3lzdGVtXG4gKlxuICogQHBhcmFtIHtOb2RlW119IGNvbnRlbnRQcm90ZWN0aW9uTm9kZXNcbiAqICAgICAgICBDb250ZW50IHByb3RlY3Rpb24gbm9kZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyBwc3NoIGRhdGEgYnkga2V5IHN5c3RlbVxuICovXG5cbnZhciBnZW5lcmF0ZUtleVN5c3RlbUluZm9ybWF0aW9uID0gZnVuY3Rpb24gZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbihjb250ZW50UHJvdGVjdGlvbk5vZGVzKSB7XG4gIHJldHVybiBjb250ZW50UHJvdGVjdGlvbk5vZGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobm9kZSk7IC8vIEFsdGhvdWdoIGl0IGNvdWxkIGJlIGFyZ3VlZCB0aGF0IGFjY29yZGluZyB0byB0aGUgVVVJRCBSRkMgc3BlYyB0aGUgVVVJRCBzdHJpbmcgKGEtZiBjaGFycykgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICAgIC8vIGFzIGEgbG93ZXJjYXNlIHN0cmluZyBpdCBhbHNvIG1lbnRpb25zIGl0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGNhc2UtaW5zZW5zaXRpdmUgb24gaW5wdXQuIFNpbmNlIHRoZSBrZXkgc3lzdGVtXG4gICAgLy8gVVVJRHMgaW4gdGhlIGtleVN5c3RlbXNNYXAgYXJlIGhhcmRjb2RlZCBhcyBsb3dlcmNhc2UgaW4gdGhlIGNvZGViYXNlIHRoZXJlIGlzbid0IGFueSByZWFzb24gbm90IHRvIGRvXG4gICAgLy8gLnRvTG93ZXJDYXNlKCkgb24gdGhlIGlucHV0IFVVSUQgc3RyaW5nIGZyb20gdGhlIG1hbmlmZXN0IChhdCBsZWFzdCBJIGNvdWxkIG5vdCB0aGluayBvZiBvbmUpLlxuXG4gICAgaWYgKGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkpIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkgPSBhdHRyaWJ1dGVzLnNjaGVtZUlkVXJpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgdmFyIGtleVN5c3RlbSA9IGtleVN5c3RlbXNNYXBbYXR0cmlidXRlcy5zY2hlbWVJZFVyaV07XG5cbiAgICBpZiAoa2V5U3lzdGVtKSB7XG4gICAgICBhY2Nba2V5U3lzdGVtXSA9IHtcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICAgIHZhciBwc3NoTm9kZSA9IGZpbmRDaGlsZHJlbihub2RlLCAnY2VuYzpwc3NoJylbMF07XG5cbiAgICAgIGlmIChwc3NoTm9kZSkge1xuICAgICAgICB2YXIgcHNzaCA9IGdldENvbnRlbnQocHNzaE5vZGUpO1xuICAgICAgICBhY2Nba2V5U3lzdGVtXS5wc3NoID0gcHNzaCAmJiBkZWNvZGVCNjRUb1VpbnQ4QXJyYXkocHNzaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTsgLy8gZGVmaW5lZCBpbiBBTlNJX1NDVEUgMjE0LTEgMjAxNlxuXG5cbnZhciBwYXJzZUNhcHRpb25TZXJ2aWNlTWV0YWRhdGEgPSBmdW5jdGlvbiBwYXJzZUNhcHRpb25TZXJ2aWNlTWV0YWRhdGEoc2VydmljZSkge1xuICAvLyA2MDggY2FwdGlvbnNcbiAgaWYgKHNlcnZpY2Uuc2NoZW1lSWRVcmkgPT09ICd1cm46c2N0ZTpkYXNoOmNjOmNlYS02MDg6MjAxNScpIHtcbiAgICB2YXIgdmFsdWVzID0gdHlwZW9mIHNlcnZpY2UudmFsdWUgIT09ICdzdHJpbmcnID8gW10gOiBzZXJ2aWNlLnZhbHVlLnNwbGl0KCc7Jyk7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgY2hhbm5lbDtcbiAgICAgIHZhciBsYW5ndWFnZTsgLy8gZGVmYXVsdCBsYW5ndWFnZSB0byB2YWx1ZVxuXG4gICAgICBsYW5ndWFnZSA9IHZhbHVlO1xuXG4gICAgICBpZiAoL15DQ1xcZD0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgnPScpO1xuXG4gICAgICAgIGNoYW5uZWwgPSBfdmFsdWUkc3BsaXRbMF07XG4gICAgICAgIGxhbmd1YWdlID0gX3ZhbHVlJHNwbGl0WzFdO1xuICAgICAgfSBlbHNlIGlmICgvXkNDXFxkJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY2hhbm5lbCA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsOiBjaGFubmVsLFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2VydmljZS5zY2hlbWVJZFVyaSA9PT0gJ3VybjpzY3RlOmRhc2g6Y2M6Y2VhLTcwODoyMDE1Jykge1xuICAgIHZhciBfdmFsdWVzID0gdHlwZW9mIHNlcnZpY2UudmFsdWUgIT09ICdzdHJpbmcnID8gW10gOiBzZXJ2aWNlLnZhbHVlLnNwbGl0KCc7Jyk7XG5cbiAgICByZXR1cm4gX3ZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgZmxhZ3MgPSB7XG4gICAgICAgIC8vIHNlcnZpY2Ugb3IgY2hhbm5lbCBudW1iZXIgMS02M1xuICAgICAgICAnY2hhbm5lbCc6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gbGFuZ3VhZ2UgaXMgYSAzQUxQSEEgcGVyIElTTyA2MzkuMi9CXG4gICAgICAgIC8vIGZpZWxkIGlzIHJlcXVpcmVkXG4gICAgICAgICdsYW5ndWFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gQklUIDEvMCBvciA/XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgMSwgbWVhbmluZyAxNjo5IGFzcGVjdCByYXRpbywgMCBpcyA0OjMsID8gaXMgdW5rbm93blxuICAgICAgICAnYXNwZWN0UmF0aW8nOiAxLFxuICAgICAgICAvLyBCSVQgMS8wXG4gICAgICAgIC8vIGVhc3kgcmVhZGVyIGZsYWcgaW5kaWNhdGVkIHRoZSB0ZXh0IGlzIHRhaWxlZCB0byB0aGUgbmVlZHMgb2YgYmVnaW5uaW5nIHJlYWRlcnNcbiAgICAgICAgLy8gZGVmYXVsdCAwLCBvciBvZmZcbiAgICAgICAgJ2Vhc3lSZWFkZXInOiAwLFxuICAgICAgICAvLyBCSVQgMS8wXG4gICAgICAgIC8vIElmIDNkIG1ldGFkYXRhIGlzIHByZXNlbnQgKENFQS03MDguMSkgdGhlbiAxXG4gICAgICAgIC8vIGRlZmF1bHQgMFxuICAgICAgICAnM0QnOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoLz0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQyID0gdmFsdWUuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgIGNoYW5uZWwgPSBfdmFsdWUkc3BsaXQyWzBdLFxuICAgICAgICAgICAgX3ZhbHVlJHNwbGl0MiQgPSBfdmFsdWUkc3BsaXQyWzFdLFxuICAgICAgICAgICAgb3B0cyA9IF92YWx1ZSRzcGxpdDIkID09PSB2b2lkIDAgPyAnJyA6IF92YWx1ZSRzcGxpdDIkO1xuXG4gICAgICAgIGZsYWdzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBmbGFncy5sYW5ndWFnZSA9IHZhbHVlO1xuICAgICAgICBvcHRzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgdmFyIF9vcHQkc3BsaXQgPSBvcHQuc3BsaXQoJzonKSxcbiAgICAgICAgICAgICAgbmFtZSA9IF9vcHQkc3BsaXRbMF0sXG4gICAgICAgICAgICAgIHZhbCA9IF9vcHQkc3BsaXRbMV07XG5cbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xhbmcnKSB7XG4gICAgICAgICAgICBmbGFncy5sYW5ndWFnZSA9IHZhbDsgLy8gZXIgZm9yIGVhc3lSZWFkZXJ5XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnZXInKSB7XG4gICAgICAgICAgICBmbGFncy5lYXN5UmVhZGVyID0gTnVtYmVyKHZhbCk7IC8vIHdhciBmb3Igd2lkZSBhc3BlY3QgcmF0aW9cbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd3YXInKSB7XG4gICAgICAgICAgICBmbGFncy5hc3BlY3RSYXRpbyA9IE51bWJlcih2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJzNEJykge1xuICAgICAgICAgICAgZmxhZ3NbJzNEJ10gPSBOdW1iZXIodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhZ3MubGFuZ3VhZ2UgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsYWdzLmNoYW5uZWwpIHtcbiAgICAgICAgZmxhZ3MuY2hhbm5lbCA9ICdTRVJWSUNFJyArIGZsYWdzLmNoYW5uZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGFncztcbiAgICB9KTtcbiAgfVxufTtcbi8qKlxuICogTWFwcyBhbiBBZGFwdGF0aW9uU2V0IG5vZGUgdG8gYSBsaXN0IG9mIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uIG9iamVjdHNcbiAqXG4gKiBAbmFtZSB0b1JlcHJlc2VudGF0aW9uc0NhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Tm9kZX0gYWRhcHRhdGlvblNldFxuICogICAgICAgIEFkYXB0YXRpb25TZXQgbm9kZSBmcm9tIHRoZSBtcGRcbiAqIEByZXR1cm4ge1JlcHJlc2VudGF0aW9uSW5mb3JtYXRpb25bXX1cbiAqICAgICAgICAgTGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgUmVwcmVzZW50YWlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGNhbGxiYWNrIGZvciBBcnJheS5wcm90b3R5cGUubWFwIGZvciBtYXBwaW5nIEFkYXB0YXRpb25TZXQgbm9kZXMgdG8gYSBsaXN0IG9mXG4gKiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBlcmlvZEF0dHJpYnV0ZXNcbiAqICAgICAgICBDb250YWlucyBhdHRyaWJ1dGVzIGluaGVyaXRlZCBieSB0aGUgUGVyaW9kXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJpb2RCYXNlVXJsc1xuICogICAgICAgIENvbnRhaW5zIGxpc3Qgb2YgcmVzb2x2ZWQgYmFzZSB1cmxzIGluaGVyaXRlZCBieSB0aGUgUGVyaW9kXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwZXJpb2RTZWdtZW50SW5mb1xuICogICAgICAgIENvbnRhaW5zIFNlZ21lbnQgSW5mb3JtYXRpb24gYXQgdGhlIHBlcmlvZCBsZXZlbFxuICogQHJldHVybiB7dG9SZXByZXNlbnRhdGlvbnNDYWxsYmFja31cbiAqICAgICAgICAgQ2FsbGJhY2sgbWFwIGZ1bmN0aW9uXG4gKi9cblxudmFyIHRvUmVwcmVzZW50YXRpb25zID0gZnVuY3Rpb24gdG9SZXByZXNlbnRhdGlvbnMocGVyaW9kQXR0cmlidXRlcywgcGVyaW9kQmFzZVVybHMsIHBlcmlvZFNlZ21lbnRJbmZvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYWRhcHRhdGlvblNldCkge1xuICAgIHZhciBhZGFwdGF0aW9uU2V0QXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhhZGFwdGF0aW9uU2V0KTtcbiAgICB2YXIgYWRhcHRhdGlvblNldEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhwZXJpb2RCYXNlVXJscywgZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdCYXNlVVJMJykpO1xuICAgIHZhciByb2xlID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdSb2xlJylbMF07XG4gICAgdmFyIHJvbGVBdHRyaWJ1dGVzID0ge1xuICAgICAgcm9sZTogcGFyc2VBdHRyaWJ1dGVzKHJvbGUpXG4gICAgfTtcbiAgICB2YXIgYXR0cnMgPSBtZXJnZShwZXJpb2RBdHRyaWJ1dGVzLCBhZGFwdGF0aW9uU2V0QXR0cmlidXRlcywgcm9sZUF0dHJpYnV0ZXMpO1xuICAgIHZhciBhY2Nlc3NpYmlsaXR5ID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdBY2Nlc3NpYmlsaXR5JylbMF07XG4gICAgdmFyIGNhcHRpb25TZXJ2aWNlcyA9IHBhcnNlQ2FwdGlvblNlcnZpY2VNZXRhZGF0YShwYXJzZUF0dHJpYnV0ZXMoYWNjZXNzaWJpbGl0eSkpO1xuXG4gICAgaWYgKGNhcHRpb25TZXJ2aWNlcykge1xuICAgICAgYXR0cnMgPSBtZXJnZShhdHRycywge1xuICAgICAgICBjYXB0aW9uU2VydmljZXM6IGNhcHRpb25TZXJ2aWNlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGxhYmVsID0gZmluZENoaWxkcmVuKGFkYXB0YXRpb25TZXQsICdMYWJlbCcpWzBdO1xuXG4gICAgaWYgKGxhYmVsICYmIGxhYmVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGFiZWxWYWwgPSBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZS50cmltKCk7XG4gICAgICBhdHRycyA9IG1lcmdlKGF0dHJzLCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbFZhbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRQcm90ZWN0aW9uID0gZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbihmaW5kQ2hpbGRyZW4oYWRhcHRhdGlvblNldCwgJ0NvbnRlbnRQcm90ZWN0aW9uJykpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbnRlbnRQcm90ZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgIGF0dHJzID0gbWVyZ2UoYXR0cnMsIHtcbiAgICAgICAgY29udGVudFByb3RlY3Rpb246IGNvbnRlbnRQcm90ZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudEluZm8gPSBnZXRTZWdtZW50SW5mb3JtYXRpb24oYWRhcHRhdGlvblNldCk7XG4gICAgdmFyIHJlcHJlc2VudGF0aW9ucyA9IGZpbmRDaGlsZHJlbihhZGFwdGF0aW9uU2V0LCAnUmVwcmVzZW50YXRpb24nKTtcbiAgICB2YXIgYWRhcHRhdGlvblNldFNlZ21lbnRJbmZvID0gbWVyZ2UocGVyaW9kU2VnbWVudEluZm8sIHNlZ21lbnRJbmZvKTtcbiAgICByZXR1cm4gZmxhdHRlbihyZXByZXNlbnRhdGlvbnMubWFwKGluaGVyaXRCYXNlVXJscyhhdHRycywgYWRhcHRhdGlvblNldEJhc2VVcmxzLCBhZGFwdGF0aW9uU2V0U2VnbWVudEluZm8pKSk7XG4gIH07XG59O1xuLyoqXG4gKiBDb250YWlucyBhbGwgcGVyaW9kIGluZm9ybWF0aW9uIGZvciBtYXBwaW5nIG5vZGVzIG9udG8gYWRhcHRhdGlvbiBzZXRzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlcmlvZEluZm9ybWF0aW9uXG4gKiBAcHJvcGVydHkge05vZGV9IHBlcmlvZC5ub2RlXG4gKiAgICAgICAgICAgUGVyaW9kIG5vZGUgZnJvbSB0aGUgbXBkXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGVyaW9kLmF0dHJpYnV0ZXNcbiAqICAgICAgICAgICBQYXJzZWQgcGVyaW9kIGF0dHJpYnV0ZXMgZnJvbSBub2RlIHBsdXMgYW55IGFkZGVkXG4gKi9cblxuLyoqXG4gKiBNYXBzIGEgUGVyaW9kSW5mb3JtYXRpb24gb2JqZWN0IHRvIGEgbGlzdCBvZiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzIGZvciBhbGxcbiAqIEFkYXB0YXRpb25TZXQgbm9kZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgUGVyaW9kLlxuICpcbiAqIEBuYW1lIHRvQWRhcHRhdGlvblNldHNDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1BlcmlvZEluZm9ybWF0aW9ufSBwZXJpb2RcbiAqICAgICAgICBQZXJpb2Qgb2JqZWN0IGNvbnRhaW5pbmcgbmVjZXNzYXJ5IHBlcmlvZCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmlvZFN0YXJ0XG4gKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgUGVyaW9kIHdpdGhpbiB0aGUgbXBkXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uW119XG4gKiAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIFJlcHJlc2VudGFpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBjYWxsYmFjayBmb3IgQXJyYXkucHJvdG90eXBlLm1hcCBmb3IgbWFwcGluZyBQZXJpb2Qgbm9kZXMgdG8gYSBsaXN0IG9mXG4gKiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1wZEF0dHJpYnV0ZXNcbiAqICAgICAgICBDb250YWlucyBhdHRyaWJ1dGVzIGluaGVyaXRlZCBieSB0aGUgbXBkXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBtcGRCYXNlVXJsc1xuICogICAgICAgIENvbnRhaW5zIGxpc3Qgb2YgcmVzb2x2ZWQgYmFzZSB1cmxzIGluaGVyaXRlZCBieSB0aGUgbXBkXG4gKiBAcmV0dXJuIHt0b0FkYXB0YXRpb25TZXRzQ2FsbGJhY2t9XG4gKiAgICAgICAgIENhbGxiYWNrIG1hcCBmdW5jdGlvblxuICovXG5cbnZhciB0b0FkYXB0YXRpb25TZXRzID0gZnVuY3Rpb24gdG9BZGFwdGF0aW9uU2V0cyhtcGRBdHRyaWJ1dGVzLCBtcGRCYXNlVXJscykge1xuICByZXR1cm4gZnVuY3Rpb24gKHBlcmlvZCwgaW5kZXgpIHtcbiAgICB2YXIgcGVyaW9kQmFzZVVybHMgPSBidWlsZEJhc2VVcmxzKG1wZEJhc2VVcmxzLCBmaW5kQ2hpbGRyZW4ocGVyaW9kLm5vZGUsICdCYXNlVVJMJykpO1xuICAgIHZhciBwZXJpb2RBdHRyaWJ1dGVzID0gbWVyZ2UobXBkQXR0cmlidXRlcywge1xuICAgICAgcGVyaW9kU3RhcnQ6IHBlcmlvZC5hdHRyaWJ1dGVzLnN0YXJ0XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHBlcmlvZC5hdHRyaWJ1dGVzLmR1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcGVyaW9kQXR0cmlidXRlcy5wZXJpb2REdXJhdGlvbiA9IHBlcmlvZC5hdHRyaWJ1dGVzLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIHZhciBhZGFwdGF0aW9uU2V0cyA9IGZpbmRDaGlsZHJlbihwZXJpb2Qubm9kZSwgJ0FkYXB0YXRpb25TZXQnKTtcbiAgICB2YXIgcGVyaW9kU2VnbWVudEluZm8gPSBnZXRTZWdtZW50SW5mb3JtYXRpb24ocGVyaW9kLm5vZGUpO1xuICAgIHJldHVybiBmbGF0dGVuKGFkYXB0YXRpb25TZXRzLm1hcCh0b1JlcHJlc2VudGF0aW9ucyhwZXJpb2RBdHRyaWJ1dGVzLCBwZXJpb2RCYXNlVXJscywgcGVyaW9kU2VnbWVudEluZm8pKSk7XG4gIH07XG59O1xuLyoqXG4gKiBHZXRzIFBlcmlvZEBzdGFydCBwcm9wZXJ0eSBmb3IgYSBnaXZlbiBwZXJpb2QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBPcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXR0cmlidXRlc1xuICogICAgICAgIFBlcmlvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJpb3JQZXJpb2RBdHRyaWJ1dGVzXVxuICogICAgICAgIFByaW9yIHBlcmlvZCBhdHRyaWJ1dGVzIChpZiBwcmlvciBwZXJpb2QgaXMgYXZhaWxhYmxlKVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubXBkVHlwZVxuICogICAgICAgIFRoZSBNUERAdHlwZSB0aGVzZSBwZXJpb2RzIGNhbWUgZnJvbVxuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKiAgICAgICAgIFRoZSBwZXJpb2Qgc3RhcnQsIG9yIG51bGwgaWYgaXQncyBhbiBlYXJseSBhdmFpbGFibGUgcGVyaW9kIG9yIGVycm9yXG4gKi9cblxudmFyIGdldFBlcmlvZFN0YXJ0ID0gZnVuY3Rpb24gZ2V0UGVyaW9kU3RhcnQoX3JlZikge1xuICB2YXIgYXR0cmlidXRlcyA9IF9yZWYuYXR0cmlidXRlcyxcbiAgICAgIHByaW9yUGVyaW9kQXR0cmlidXRlcyA9IF9yZWYucHJpb3JQZXJpb2RBdHRyaWJ1dGVzLFxuICAgICAgbXBkVHlwZSA9IF9yZWYubXBkVHlwZTtcblxuICAvLyBTdW1tYXJ5IG9mIHBlcmlvZCBzdGFydCB0aW1lIGNhbGN1bGF0aW9uIGZyb20gREFTSCBzcGVjIHNlY3Rpb24gNS4zLjIuMVxuICAvL1xuICAvLyBBIHBlcmlvZCdzIHN0YXJ0IGlzIHRoZSBmaXJzdCBwZXJpb2QncyBzdGFydCArIHRpbWUgZWxhcHNlZCBhZnRlciBwbGF5aW5nIGFsbFxuICAvLyBwcmlvciBwZXJpb2RzIHRvIHRoaXMgb25lLiBQZXJpb2RzIGNvbnRpbnVlIG9uZSBhZnRlciB0aGUgb3RoZXIgaW4gdGltZSAod2l0aG91dFxuICAvLyBnYXBzKSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwcmVzZW50YXRpb24uXG4gIC8vXG4gIC8vIFRoZSB2YWx1ZSBvZiBQZXJpb2RAc3RhcnQgc2hvdWxkIGJlOlxuICAvLyAxLiBpZiBQZXJpb2RAc3RhcnQgaXMgcHJlc2VudDogdmFsdWUgb2YgUGVyaW9kQHN0YXJ0XG4gIC8vIDIuIGlmIHByZXZpb3VzIHBlcmlvZCBleGlzdHMgYW5kIGl0IGhhcyBAZHVyYXRpb246IHByZXZpb3VzIFBlcmlvZEBzdGFydCArXG4gIC8vICAgIHByZXZpb3VzIFBlcmlvZEBkdXJhdGlvblxuICAvLyAzLiBpZiB0aGlzIGlzIGZpcnN0IHBlcmlvZCBhbmQgTVBEQHR5cGUgaXMgJ3N0YXRpYyc6IDBcbiAgLy8gNC4gaW4gYWxsIG90aGVyIGNhc2VzLCBjb25zaWRlciB0aGUgcGVyaW9kIGFuIFwiZWFybHkgYXZhaWxhYmxlIHBlcmlvZFwiIChub3RlOiBub3RcbiAgLy8gICAgY3VycmVudGx5IHN1cHBvcnRlZClcbiAgLy8gKDEpXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5zdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcy5zdGFydDtcbiAgfSAvLyAoMilcblxuXG4gIGlmIChwcmlvclBlcmlvZEF0dHJpYnV0ZXMgJiYgdHlwZW9mIHByaW9yUGVyaW9kQXR0cmlidXRlcy5zdGFydCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHByaW9yUGVyaW9kQXR0cmlidXRlcy5kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLnN0YXJ0ICsgcHJpb3JQZXJpb2RBdHRyaWJ1dGVzLmR1cmF0aW9uO1xuICB9IC8vICgzKVxuXG5cbiAgaWYgKCFwcmlvclBlcmlvZEF0dHJpYnV0ZXMgJiYgbXBkVHlwZSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyAoNClcbiAgLy8gVGhlcmUgaXMgY3VycmVudGx5IG5vIGxvZ2ljIGZvciBjYWxjdWxhdGluZyB0aGUgUGVyaW9kQHN0YXJ0IHZhbHVlIGlmIHRoZXJlIGlzXG4gIC8vIG5vIFBlcmlvZEBzdGFydCBvciBwcmlvciBQZXJpb2RAc3RhcnQgYW5kIFBlcmlvZEBkdXJhdGlvbiBhdmFpbGFibGUuIFRoaXMgaXMgbm90IG1hZGVcbiAgLy8gZXhwbGljaXQgYnkgdGhlIERBU0ggaW50ZXJvcCBndWlkZWxpbmVzIG9yIHRoZSBEQVNIIHNwZWMsIGhvd2V2ZXIsIHNpbmNlIHRoZXJlJ3NcbiAgLy8gbm90aGluZyBhYm91dCBhbnkgb3RoZXIgcmVzb2x1dGlvbiBzdHJhdGVnaWVzLCBpdCdzIGltcGxpZWQuIFRodXMsIHRoaXMgY2FzZSBzaG91bGRcbiAgLy8gYmUgY29uc2lkZXJlZCBhbiBlYXJseSBhdmFpbGFibGUgcGVyaW9kLCBvciBlcnJvciwgYW5kIG51bGwgc2hvdWxkIHN1ZmZpY2UgZm9yIGJvdGhcbiAgLy8gb2YgdGhvc2UgY2FzZXMuXG5cblxuICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgbXBkIHhtbCB0cmVlIHRvIGdlbmVyYXRlIGEgbGlzdCBvZiBSZXByZXNlbnRhdGlvbiBpbmZvcm1hdGlvbiBvYmplY3RzXG4gKiB0aGF0IGhhdmUgaW5oZXJpdGVkIGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQgbm9kZXNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG1wZFxuICogICAgICAgIFRoZSByb290IG5vZGUgb2YgdGhlIG1wZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBBdmFpbGFibGUgb3B0aW9ucyBmb3IgaW5oZXJpdEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1hbmlmZXN0VXJpXG4gKiAgICAgICAgVGhlIHVyaSBzb3VyY2Ugb2YgdGhlIG1wZFxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuTk9XXG4gKiAgICAgICAgQ3VycmVudCB0aW1lIHBlciBEQVNIIElPUC4gIERlZmF1bHQgaXMgY3VycmVudCB0aW1lIGluIG1zIHNpbmNlIGVwb2NoXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jbGllbnRPZmZzZXRcbiAqICAgICAgICBDbGllbnQgdGltZSBkaWZmZXJlbmNlIGZyb20gTk9XIChpbiBtaWxsaXNlY29uZHMpXG4gKiBAcmV0dXJuIHtSZXByZXNlbnRhdGlvbkluZm9ybWF0aW9uW119XG4gKiAgICAgICAgIExpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIFJlcHJlc2VudGF0aW9uIGluZm9ybWF0aW9uXG4gKi9cblxudmFyIGluaGVyaXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gaW5oZXJpdEF0dHJpYnV0ZXMobXBkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkbWFuaWZlc3RVcmkgPSBfb3B0aW9ucy5tYW5pZmVzdFVyaSxcbiAgICAgIG1hbmlmZXN0VXJpID0gX29wdGlvbnMkbWFuaWZlc3RVcmkgPT09IHZvaWQgMCA/ICcnIDogX29wdGlvbnMkbWFuaWZlc3RVcmksXG4gICAgICBfb3B0aW9ucyROT1cgPSBfb3B0aW9ucy5OT1csXG4gICAgICBOT1cgPSBfb3B0aW9ucyROT1cgPT09IHZvaWQgMCA/IERhdGUubm93KCkgOiBfb3B0aW9ucyROT1csXG4gICAgICBfb3B0aW9ucyRjbGllbnRPZmZzZXQgPSBfb3B0aW9ucy5jbGllbnRPZmZzZXQsXG4gICAgICBjbGllbnRPZmZzZXQgPSBfb3B0aW9ucyRjbGllbnRPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRjbGllbnRPZmZzZXQ7XG4gIHZhciBwZXJpb2ROb2RlcyA9IGZpbmRDaGlsZHJlbihtcGQsICdQZXJpb2QnKTtcblxuICBpZiAoIXBlcmlvZE5vZGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU5WQUxJRF9OVU1CRVJfT0ZfUEVSSU9EKTtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbnMgPSBmaW5kQ2hpbGRyZW4obXBkLCAnTG9jYXRpb24nKTtcbiAgdmFyIG1wZEF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobXBkKTtcbiAgdmFyIG1wZEJhc2VVcmxzID0gYnVpbGRCYXNlVXJscyhbbWFuaWZlc3RVcmldLCBmaW5kQ2hpbGRyZW4obXBkLCAnQmFzZVVSTCcpKTsgLy8gU2VlIERBU0ggc3BlYyBzZWN0aW9uIDUuMy4xLjIsIFNlbWFudGljcyBvZiBNUEQgZWxlbWVudC4gRGVmYXVsdCB0eXBlIHRvICdzdGF0aWMnLlxuXG4gIG1wZEF0dHJpYnV0ZXMudHlwZSA9IG1wZEF0dHJpYnV0ZXMudHlwZSB8fCAnc3RhdGljJztcbiAgbXBkQXR0cmlidXRlcy5zb3VyY2VEdXJhdGlvbiA9IG1wZEF0dHJpYnV0ZXMubWVkaWFQcmVzZW50YXRpb25EdXJhdGlvbiB8fCAwO1xuICBtcGRBdHRyaWJ1dGVzLk5PVyA9IE5PVztcbiAgbXBkQXR0cmlidXRlcy5jbGllbnRPZmZzZXQgPSBjbGllbnRPZmZzZXQ7XG5cbiAgaWYgKGxvY2F0aW9ucy5sZW5ndGgpIHtcbiAgICBtcGRBdHRyaWJ1dGVzLmxvY2F0aW9ucyA9IGxvY2F0aW9ucy5tYXAoZ2V0Q29udGVudCk7XG4gIH1cblxuICB2YXIgcGVyaW9kcyA9IFtdOyAvLyBTaW5jZSB0b0FkYXB0YXRpb25TZXRzIGFjdHMgb24gaW5kaXZpZHVhbCBwZXJpb2RzIHJpZ2h0IG5vdywgdGhlIHNpbXBsZXN0IGFwcHJvYWNoIHRvXG4gIC8vIGFkZGluZyBwcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBsb29raW5nIGF0IHByaW9yIHBlcmlvZHMgaXMgdG8gcGFyc2UgYXR0cmlidXRlcyBhbmQgYWRkXG4gIC8vIG1pc3Npbmcgb25lcyBiZWZvcmUgdG9BZGFwdGF0aW9uU2V0cyBpcyBjYWxsZWQuIElmIG1vcmUgc3VjaCBwcm9wZXJ0aWVzIGFyZSBhZGRlZCwgaXRcbiAgLy8gbWF5IGJlIGJldHRlciB0byByZWZhY3RvciB0b0FkYXB0YXRpb25TZXRzLlxuXG4gIHBlcmlvZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobm9kZSk7IC8vIFVzZSB0aGUgbGFzdCBtb2RpZmllZCBwcmlvciBwZXJpb2QsIGFzIGl0IG1heSBjb250YWluIGFkZGVkIGluZm9ybWF0aW9uIG5lY2Vzc2FyeVxuICAgIC8vIGZvciB0aGlzIHBlcmlvZC5cblxuICAgIHZhciBwcmlvclBlcmlvZCA9IHBlcmlvZHNbaW5kZXggLSAxXTtcbiAgICBhdHRyaWJ1dGVzLnN0YXJ0ID0gZ2V0UGVyaW9kU3RhcnQoe1xuICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgIHByaW9yUGVyaW9kQXR0cmlidXRlczogcHJpb3JQZXJpb2QgPyBwcmlvclBlcmlvZC5hdHRyaWJ1dGVzIDogbnVsbCxcbiAgICAgIG1wZFR5cGU6IG1wZEF0dHJpYnV0ZXMudHlwZVxuICAgIH0pO1xuICAgIHBlcmlvZHMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbnM6IG1wZEF0dHJpYnV0ZXMubG9jYXRpb25zLFxuICAgIHJlcHJlc2VudGF0aW9uSW5mbzogZmxhdHRlbihwZXJpb2RzLm1hcCh0b0FkYXB0YXRpb25TZXRzKG1wZEF0dHJpYnV0ZXMsIG1wZEJhc2VVcmxzKSkpXG4gIH07XG59O1xuXG52YXIgc3RyaW5nVG9NcGRYbWwgPSBmdW5jdGlvbiBzdHJpbmdUb01wZFhtbChtYW5pZmVzdFN0cmluZykge1xuICBpZiAobWFuaWZlc3RTdHJpbmcgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5EQVNIX0VNUFRZX01BTklGRVNUKTtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gIHZhciB4bWw7XG4gIHZhciBtcGQ7XG5cbiAgdHJ5IHtcbiAgICB4bWwgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKG1hbmlmZXN0U3RyaW5nLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgbXBkID0geG1sICYmIHhtbC5kb2N1bWVudEVsZW1lbnQudGFnTmFtZSA9PT0gJ01QRCcgPyB4bWwuZG9jdW1lbnRFbGVtZW50IDogbnVsbDtcbiAgfSBjYXRjaCAoZSkgey8vIGllIDExIHRocm93c3cgb24gaW52YWxpZCB4bWxcbiAgfVxuXG4gIGlmICghbXBkIHx8IG1wZCAmJiBtcGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuREFTSF9JTlZBTElEX1hNTCk7XG4gIH1cblxuICByZXR1cm4gbXBkO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIG1hbmlmZXN0IGZvciBhIFVUQ1RpbWluZyBub2RlLCByZXR1cm5pbmcgdGhlIG5vZGVzIGF0dHJpYnV0ZXMgaWYgZm91bmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbXBkXG4gKiAgICAgICAgWE1MIHN0cmluZyBvZiB0aGUgTVBEIG1hbmlmZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAqICAgICAgICAgQXR0cmlidXRlcyBvZiBVVENUaW1pbmcgbm9kZSBzcGVjaWZpZWQgaW4gdGhlIG1hbmlmZXN0LiBOdWxsIGlmIG5vbmUgZm91bmRcbiAqL1xuXG52YXIgcGFyc2VVVENUaW1pbmdTY2hlbWUgPSBmdW5jdGlvbiBwYXJzZVVUQ1RpbWluZ1NjaGVtZShtcGQpIHtcbiAgdmFyIFVUQ1RpbWluZ05vZGUgPSBmaW5kQ2hpbGRyZW4obXBkLCAnVVRDVGltaW5nJylbMF07XG5cbiAgaWYgKCFVVENUaW1pbmdOb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhVVENUaW1pbmdOb2RlKTtcblxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMuc2NoZW1lSWRVcmkpIHtcbiAgICBjYXNlICd1cm46bXBlZzpkYXNoOnV0YzpodHRwLWhlYWQ6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1oZWFkOjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnSEVBRCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAteHNkYXRlOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaXNvOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAteHNkYXRlOjIwMTInOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmh0dHAtaXNvOjIwMTInOlxuICAgICAgYXR0cmlidXRlcy5tZXRob2QgPSAnR0VUJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6ZGlyZWN0OjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOmRpcmVjdDoyMDEyJzpcbiAgICAgIGF0dHJpYnV0ZXMubWV0aG9kID0gJ0RJUkVDVCc7XG4gICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gRGF0ZS5wYXJzZShhdHRyaWJ1dGVzLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6aHR0cC1udHA6MjAxNCc6XG4gICAgY2FzZSAndXJuOm1wZWc6ZGFzaDp1dGM6bnRwOjIwMTQnOlxuICAgIGNhc2UgJ3VybjptcGVnOmRhc2g6dXRjOnNudHA6MjAxNCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUUpO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59O1xuXG52YXIgVkVSU0lPTiA9IHZlcnNpb247XG4vKlxuICogR2l2ZW4gYSBEQVNIIG1hbmlmZXN0IHN0cmluZyBhbmQgb3B0aW9ucywgcGFyc2VzIHRoZSBEQVNIIG1hbmlmZXN0IGludG8gYW4gb2JqZWN0IGluIHRoZVxuICogZm9ybSBvdXRwdXRlZCBieSBtM3U4LXBhcnNlciBhbmQgYWNjZXB0ZWQgYnkgdmlkZW9qcy9odHRwLXN0cmVhbWluZy5cbiAqXG4gKiBGb3IgbGl2ZSBEQVNIIG1hbmlmZXN0cywgaWYgYHByZXZpb3VzTWFuaWZlc3RgIGlzIHByb3ZpZGVkIGluIG9wdGlvbnMsIHRoZW4gdGhlIG5ld2x5XG4gKiBwYXJzZWQgREFTSCBtYW5pZmVzdCB3aWxsIGhhdmUgaXRzIG1lZGlhIHNlcXVlbmNlIGFuZCBkaXNjb250aW51aXR5IHNlcXVlbmNlIHZhbHVlc1xuICogdXBkYXRlZCB0byByZWZsZWN0IGl0cyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcHJpb3IgbWFuaWZlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hbmlmZXN0U3RyaW5nIC0gdGhlIERBU0ggbWFuaWZlc3QgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIC0gYW55IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBtYW5pZmVzdCBvYmplY3RcbiAqL1xuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShtYW5pZmVzdFN0cmluZywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHBhcnNlZE1hbmlmZXN0SW5mbyA9IGluaGVyaXRBdHRyaWJ1dGVzKHN0cmluZ1RvTXBkWG1sKG1hbmlmZXN0U3RyaW5nKSwgb3B0aW9ucyk7XG4gIHZhciBwbGF5bGlzdHMgPSB0b1BsYXlsaXN0cyhwYXJzZWRNYW5pZmVzdEluZm8ucmVwcmVzZW50YXRpb25JbmZvKTtcbiAgcmV0dXJuIHRvTTN1OCh7XG4gICAgZGFzaFBsYXlsaXN0czogcGxheWxpc3RzLFxuICAgIGxvY2F0aW9uczogcGFyc2VkTWFuaWZlc3RJbmZvLmxvY2F0aW9ucyxcbiAgICBzaWR4TWFwcGluZzogb3B0aW9ucy5zaWR4TWFwcGluZyxcbiAgICBwcmV2aW91c01hbmlmZXN0OiBvcHRpb25zLnByZXZpb3VzTWFuaWZlc3RcbiAgfSk7XG59O1xuLyoqXG4gKiBQYXJzZXMgdGhlIG1hbmlmZXN0IGZvciBhIFVUQ1RpbWluZyBub2RlLCByZXR1cm5pbmcgdGhlIG5vZGVzIGF0dHJpYnV0ZXMgaWYgZm91bmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3RTdHJpbmdcbiAqICAgICAgICBYTUwgc3RyaW5nIG9mIHRoZSBNUEQgbWFuaWZlc3RcbiAqIEByZXR1cm4ge09iamVjdHxudWxsfVxuICogICAgICAgICBBdHRyaWJ1dGVzIG9mIFVUQ1RpbWluZyBub2RlIHNwZWNpZmllZCBpbiB0aGUgbWFuaWZlc3QuIE51bGwgaWYgbm9uZSBmb3VuZFxuICovXG5cblxudmFyIHBhcnNlVVRDVGltaW5nID0gZnVuY3Rpb24gcGFyc2VVVENUaW1pbmcobWFuaWZlc3RTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlVVRDVGltaW5nU2NoZW1lKHN0cmluZ1RvTXBkWG1sKG1hbmlmZXN0U3RyaW5nKSk7XG59O1xuXG5leHBvcnQgeyBWRVJTSU9OLCBhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0JDEgYXMgYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCwgZ2VuZXJhdGVTaWR4S2V5LCBpbmhlcml0QXR0cmlidXRlcywgcGFyc2UsIHBhcnNlVVRDVGltaW5nLCBzdHJpbmdUb01wZFhtbCwgdG9NM3U4LCB0b1BsYXlsaXN0cyB9O1xuIl0sIm5hbWVzIjpbInJlc29sdmVVcmwiLCJ3aW5kb3ciLCJmb3JFYWNoTWVkaWFHcm91cCIsImRlY29kZUI2NFRvVWludDhBcnJheSIsIkRPTVBhcnNlciIsInZlcnNpb24iLCJpc09iamVjdCIsIm9iaiIsIm1lcmdlIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsIm9iamVjdHMiLCJBcnJheSIsIl9rZXkiLCJyZWR1Y2UiLCJyZXN1bHQiLCJzb3VyY2UiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImlzQXJyYXkiLCJjb25jYXQiLCJ2YWx1ZXMiLCJvIiwibWFwIiwiayIsInJhbmdlIiwic3RhcnQiLCJlbmQiLCJpIiwicHVzaCIsImZsYXR0ZW4iLCJsaXN0cyIsIngiLCJ5IiwiZnJvbSIsImxpc3QiLCJmaW5kSW5kZXhlcyIsImwiLCJhIiwiZSIsImZpbmRJbmRleCIsIm1hdGNoaW5nRnVuY3Rpb24iLCJ1bmlvbiIsImtleUZ1bmN0aW9uIiwiYWNjIiwiZWwiLCJlcnJvcnMiLCJJTlZBTElEX05VTUJFUl9PRl9QRVJJT0QiLCJEQVNIX0VNUFRZX01BTklGRVNUIiwiREFTSF9JTlZBTElEX1hNTCIsIk5PX0JBU0VfVVJMIiwiTUlTU0lOR19TRUdNRU5UX0lORk9STUFUSU9OIiwiU0VHTUVOVF9USU1FX1VOU1BFQ0lGSUVEIiwiVU5TVVBQT1JURURfVVRDX1RJTUlOR19TQ0hFTUUiLCJ1cmxUeXBlVG9TZWdtZW50IiwiX3JlZiIsIl9yZWYkYmFzZVVybCIsImJhc2VVcmwiLCJfcmVmJHNvdXJjZSIsIl9yZWYkcmFuZ2UiLCJfcmVmJGluZGV4UmFuZ2UiLCJpbmRleFJhbmdlIiwic2VnbWVudCIsInVyaSIsInJlc29sdmVkVXJpIiwicmFuZ2VTdHIiLCJyYW5nZXMiLCJzcGxpdCIsInN0YXJ0UmFuZ2UiLCJCaWdJbnQiLCJwYXJzZUludCIsImVuZFJhbmdlIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImJ5dGVyYW5nZSIsIm9mZnNldCIsImJ5dGVSYW5nZVRvU3RyaW5nIiwicGFyc2VFbmROdW1iZXIiLCJlbmROdW1iZXIiLCJpc05hTiIsInNlZ21lbnRSYW5nZSIsInN0YXRpYyIsIl9zdGF0aWMiLCJhdHRyaWJ1dGVzIiwiZHVyYXRpb24iLCJfYXR0cmlidXRlcyR0aW1lc2NhbGUiLCJ0aW1lc2NhbGUiLCJzb3VyY2VEdXJhdGlvbiIsInBlcmlvZER1cmF0aW9uIiwic2VnbWVudER1cmF0aW9uIiwiZHluYW1pYyIsIk5PVyIsImNsaWVudE9mZnNldCIsImF2YWlsYWJpbGl0eVN0YXJ0VGltZSIsIl9hdHRyaWJ1dGVzJHRpbWVzY2FsZTIiLCJfYXR0cmlidXRlcyRwZXJpb2RTdGEiLCJwZXJpb2RTdGFydCIsIl9hdHRyaWJ1dGVzJG1pbmltdW1VcCIsIm1pbmltdW1VcGRhdGVQZXJpb2QiLCJfYXR0cmlidXRlcyR0aW1lU2hpZnQiLCJ0aW1lU2hpZnRCdWZmZXJEZXB0aCIsIkluZmluaXR5Iiwibm93IiwicGVyaW9kU3RhcnRXQyIsInBlcmlvZEVuZFdDIiwic2VnbWVudENvdW50IiwiTWF0aCIsImNlaWwiLCJhdmFpbGFibGVTdGFydCIsImZsb29yIiwiYXZhaWxhYmxlRW5kIiwibWF4IiwibWluIiwidG9TZWdtZW50cyIsIm51bWJlciIsIl9hdHRyaWJ1dGVzJHRpbWVzY2FsZTMiLCJfYXR0cmlidXRlcyRzdGFydE51bWIiLCJzdGFydE51bWJlciIsInRpbWVsaW5lIiwidGltZSIsInBhcnNlQnlEdXJhdGlvbiIsInR5cGUiLCJfYXR0cmlidXRlcyR0aW1lc2NhbGU0IiwiX3NlZ21lbnRSYW5nZSR0eXBlIiwic2VnbWVudHMiLCJpbmRleCIsInNlY3Rpb25EdXJhdGlvbiIsInNlZ21lbnRzRnJvbUJhc2UiLCJfYXR0cmlidXRlcyRpbml0aWFsaXoiLCJpbml0aWFsaXphdGlvbiIsIl9hdHRyaWJ1dGVzJGluZGV4UmFuZyIsInByZXNlbnRhdGlvblRpbWUiLCJfYXR0cmlidXRlcyRudW1iZXIiLCJFcnJvciIsImluaXRTZWdtZW50Iiwic291cmNlVVJMIiwic2VnbWVudFRpbWVJbmZvIiwiYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCQxIiwiYWRkU2lkeFNlZ21lbnRzVG9QbGF5bGlzdCIsInBsYXlsaXN0Iiwic2lkeCIsInNpZHhCeXRlUmFuZ2UiLCJzaWR4RW5kIiwibWVkaWFSZWZlcmVuY2VzIiwicmVmZXJlbmNlcyIsImZpbHRlciIsInIiLCJyZWZlcmVuY2VUeXBlIiwiZW5kTGlzdCIsIm1lZGlhU2VxdWVuY2UiLCJzdGFydEluZGV4IiwiZmlyc3RPZmZzZXQiLCJyZWZlcmVuY2UiLCJzaXplIiwicmVmZXJlbmNlZFNpemUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJlbmRJbmRleCIsIlNVUFBPUlRFRF9NRURJQV9UWVBFUyIsIlRJTUVfRlVER0UiLCJnZXRVbmlxdWVUaW1lbGluZVN0YXJ0cyIsInRpbWVsaW5lU3RhcnRzIiwic29ydCIsImIiLCJmaW5kUGxheWxpc3RXaXRoTmFtZSIsInBsYXlsaXN0cyIsIm5hbWUiLCJOQU1FIiwiZ2V0TWVkaWFHcm91cFBsYXlsaXN0cyIsIm1hbmlmZXN0IiwibWVkaWFHcm91cFBsYXlsaXN0cyIsInByb3BlcnRpZXMiLCJncm91cCIsImxhYmVsIiwidXBkYXRlTWVkaWFTZXF1ZW5jZUZvclBsYXlsaXN0IiwiX3JlZjIiLCJ1cGRhdGVTZXF1ZW5jZU51bWJlcnMiLCJfcmVmMyIsIm9sZFBsYXlsaXN0cyIsIm5ld1BsYXlsaXN0cyIsImRpc2NvbnRpbnVpdHlTZXF1ZW5jZSIsIl9yZWY0Iiwib2xkUGxheWxpc3QiLCJmaXJzdE5ld1NlZ21lbnQiLCJvbGRNYXRjaGluZ1NlZ21lbnRJbmRleCIsIm9sZFNlZ21lbnQiLCJhYnMiLCJkaXNjb250aW51aXR5IiwiZGlzY29udGludWl0eVN0YXJ0cyIsInVuc2hpZnQiLCJvbGRNYXRjaGluZ1NlZ21lbnQiLCJwb3NpdGlvbk1hbmlmZXN0T25UaW1lbGluZSIsIl9yZWY1Iiwib2xkTWFuaWZlc3QiLCJuZXdNYW5pZmVzdCIsImdlbmVyYXRlU2lkeEtleSIsIm1lcmdlRGlzY29udGlndW91c1BsYXlsaXN0cyIsIm1lcmdlZFBsYXlsaXN0cyIsImlkIiwibGFuZyIsIl9hY2MkbmFtZSRzZWdtZW50cyIsImFwcGx5IiwiY29udGVudFByb3RlY3Rpb24iLCJzaWR4TWFwcGluZyIsInNpZHhLZXkiLCJzaWR4TWF0Y2giLCJhZGRTaWR4U2VnbWVudHNUb1BsYXlsaXN0cyIsImZvcm1hdEF1ZGlvUGxheWxpc3QiLCJpc0F1ZGlvT25seSIsIl9hdHRyaWJ1dGVzIiwiQkFORFdJRFRIIiwiYmFuZHdpZHRoIiwiQ09ERUNTIiwiY29kZWNzIiwidGFyZ2V0RHVyYXRpb24iLCJBVURJTyIsIlNVQlRJVExFUyIsImZvcm1hdFZ0dFBsYXlsaXN0IiwiX20zdThBdHRyaWJ1dGVzIiwibTN1OEF0dHJpYnV0ZXMiLCJvcmdhbml6ZUF1ZGlvUGxheWxpc3RzIiwibWFpblBsYXlsaXN0IiwiZm9ybWF0dGVkUGxheWxpc3RzIiwicm9sZSIsInZhbHVlIiwibGFuZ3VhZ2UiLCJyb2xlTGFiZWwiLCJhdXRvc2VsZWN0IiwiZGVmYXVsdCIsImZvcm1hdHRlZCIsImZpcnN0TGFiZWwiLCJvcmdhbml6ZVZ0dFBsYXlsaXN0cyIsIm9yZ2FuaXplQ2FwdGlvblNlcnZpY2VzIiwiY2FwdGlvblNlcnZpY2VzIiwic3ZjT2JqIiwic3ZjIiwic2VydmljZSIsImNoYW5uZWwiLCJpbnN0cmVhbUlkIiwiaGFzT3duUHJvcGVydHkiLCJhc3BlY3RSYXRpbyIsImVhc3lSZWFkZXIiLCJmb3JtYXRWaWRlb1BsYXlsaXN0IiwiX2F0dHJpYnV0ZXMyIiwiUkVTT0xVVElPTiIsIndpZHRoIiwiaGVpZ2h0IiwiZnJhbWVSYXRlIiwidmlkZW9Pbmx5IiwibWltZVR5cGUiLCJjb250ZW50VHlwZSIsImF1ZGlvT25seSIsInZ0dE9ubHkiLCJfcmVmNiIsImFkZE1lZGlhU2VxdWVuY2VWYWx1ZXMiLCJfcmVmNyIsImZsYXR0ZW5NZWRpYUdyb3VwUGxheWxpc3RzIiwibWVkaWFHcm91cE9iamVjdCIsImxhYmVsQ29udGVudHMiLCJ0b00zdTgiLCJfcmVmOCIsIl9tZWRpYUdyb3VwcyIsImRhc2hQbGF5bGlzdHMiLCJsb2NhdGlvbnMiLCJfcmVmOCRzaWR4TWFwcGluZyIsInByZXZpb3VzTWFuaWZlc3QiLCJfZGFzaFBsYXlsaXN0cyQwJGF0dHIiLCJzdWdnZXN0ZWRQcmVzZW50YXRpb25EZWxheSIsInZpZGVvUGxheWxpc3RzIiwiYXVkaW9QbGF5bGlzdHMiLCJ2dHRQbGF5bGlzdHMiLCJjYXB0aW9ucyIsIkJvb2xlYW4iLCJhbGxvd0NhY2hlIiwibWVkaWFHcm91cHMiLCJWSURFTyIsIm9yZ2FuaXplZEF1ZGlvR3JvdXAiLCJvcmdhbml6ZWRWdHRHcm91cCIsInBsYXlsaXN0VGltZWxpbmVTdGFydHMiLCJfcmVmOSIsImF1ZGlvIiwic3VicyIsImNjIiwiZ2V0TGl2ZVJWYWx1ZSIsInBhcnNlQnlUaW1lbGluZSIsInNlZ21lbnRUaW1lbGluZSIsIl9hdHRyaWJ1dGVzJG1pbmltdW1VcDIiLCJfYXR0cmlidXRlcyRtZWRpYSIsIm1lZGlhIiwic0luZGV4IiwiUyIsImQiLCJyZXBlYXQiLCJzZWdtZW50VGltZSIsInQiLCJjb3VudCIsIm5leHRTIiwiaW5kZXhPZiIsImlkZW50aWZpZXJQYXR0ZXJuIiwiaWRlbnRpZmllclJlcGxhY2VtZW50IiwibWF0Y2giLCJpZGVudGlmaWVyIiwiZm9ybWF0Iiwiam9pbiIsImNvbnN0cnVjdFRlbXBsYXRlVXJsIiwidXJsIiwicmVwbGFjZSIsInBhcnNlVGVtcGxhdGVJbmZvIiwic2VnbWVudHNGcm9tVGVtcGxhdGUiLCJ0ZW1wbGF0ZVZhbHVlcyIsIlJlcHJlc2VudGF0aW9uSUQiLCJCYW5kd2lkdGgiLCJtYXBTZWdtZW50IiwiVGltZSIsInByZXNlbnRhdGlvblRpbWVPZmZzZXQiLCJTZWdtZW50VVJMVG9TZWdtZW50T2JqZWN0Iiwic2VnbWVudFVybCIsIm1lZGlhUmFuZ2UiLCJzZWdtZW50c0Zyb21MaXN0IiwiX2F0dHJpYnV0ZXMkc2VnbWVudFVyIiwic2VnbWVudFVybHMiLCJzZWdtZW50VXJsTWFwIiwic2VnbWVudFVybE9iamVjdCIsImdlbmVyYXRlU2VnbWVudHMiLCJzZWdtZW50SW5mbyIsInNlZ21lbnRBdHRyaWJ1dGVzIiwic2VnbWVudHNGbiIsInRlbXBsYXRlIiwiYmFzZSIsInNlZ21lbnRzSW5mbyIsIl9zZWdtZW50QXR0cmlidXRlcyIsIl9zZWdtZW50QXR0cmlidXRlcyR0aSIsInRvUGxheWxpc3RzIiwicmVwcmVzZW50YXRpb25zIiwiZmluZENoaWxkcmVuIiwiZWxlbWVudCIsImNoaWxkTm9kZXMiLCJ0YWdOYW1lIiwiZ2V0Q29udGVudCIsInRleHRDb250ZW50IiwidHJpbSIsInBhcnNlRGl2aXNpb25WYWx1ZSIsInBhcnNlRmxvYXQiLCJwcmV2IiwiY3VycmVudCIsInBhcnNlRHVyYXRpb24iLCJzdHIiLCJTRUNPTkRTX0lOX1lFQVIiLCJTRUNPTkRTX0lOX01PTlRIIiwiU0VDT05EU19JTl9EQVkiLCJTRUNPTkRTX0lOX0hPVVIiLCJTRUNPTkRTX0lOX01JTiIsImR1cmF0aW9uUmVnZXgiLCJleGVjIiwiX21hdGNoJHNsaWNlIiwic2xpY2UiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwicGFyc2VEYXRlIiwiZGF0ZVJlZ2V4IiwidGVzdCIsIkRhdGUiLCJwYXJzZSIsInBhcnNlcnMiLCJtZWRpYVByZXNlbnRhdGlvbkR1cmF0aW9uIiwicGFyc2VkVmFsdWUiLCJERUZBVUxUIiwicGFyc2VBdHRyaWJ1dGVzIiwicGFyc2VGbiIsImtleVN5c3RlbXNNYXAiLCJidWlsZEJhc2VVcmxzIiwicmVmZXJlbmNlVXJscyIsImJhc2VVcmxFbGVtZW50cyIsImJhc2VVcmxFbGVtZW50IiwiZ2V0U2VnbWVudEluZm9ybWF0aW9uIiwiYWRhcHRhdGlvblNldCIsInNlZ21lbnRUZW1wbGF0ZSIsInNlZ21lbnRMaXN0IiwicyIsInRhZyIsInNlZ21lbnRCYXNlIiwic2VnbWVudFRpbWVsaW5lUGFyZW50Tm9kZSIsInNlZ21lbnRJbml0aWFsaXphdGlvblBhcmVudE5vZGUiLCJzZWdtZW50SW5pdGlhbGl6YXRpb24iLCJpbmhlcml0QmFzZVVybHMiLCJhZGFwdGF0aW9uU2V0QXR0cmlidXRlcyIsImFkYXB0YXRpb25TZXRCYXNlVXJscyIsImFkYXB0YXRpb25TZXRTZWdtZW50SW5mbyIsInJlcHJlc2VudGF0aW9uIiwicmVwQmFzZVVybEVsZW1lbnRzIiwicmVwQmFzZVVybHMiLCJyZXByZXNlbnRhdGlvblNlZ21lbnRJbmZvIiwiZ2VuZXJhdGVLZXlTeXN0ZW1JbmZvcm1hdGlvbiIsImNvbnRlbnRQcm90ZWN0aW9uTm9kZXMiLCJub2RlIiwic2NoZW1lSWRVcmkiLCJ0b0xvd2VyQ2FzZSIsImtleVN5c3RlbSIsInBzc2hOb2RlIiwicHNzaCIsInBhcnNlQ2FwdGlvblNlcnZpY2VNZXRhZGF0YSIsIl92YWx1ZSRzcGxpdCIsIl92YWx1ZXMiLCJmbGFncyIsInVuZGVmaW5lZCIsIl92YWx1ZSRzcGxpdDIiLCJfdmFsdWUkc3BsaXQyJCIsIm9wdHMiLCJvcHQiLCJfb3B0JHNwbGl0IiwidmFsIiwidG9SZXByZXNlbnRhdGlvbnMiLCJwZXJpb2RBdHRyaWJ1dGVzIiwicGVyaW9kQmFzZVVybHMiLCJwZXJpb2RTZWdtZW50SW5mbyIsInJvbGVBdHRyaWJ1dGVzIiwiYXR0cnMiLCJhY2Nlc3NpYmlsaXR5IiwibGFiZWxWYWwiLCJub2RlVmFsdWUiLCJ0b0FkYXB0YXRpb25TZXRzIiwibXBkQXR0cmlidXRlcyIsIm1wZEJhc2VVcmxzIiwicGVyaW9kIiwiYWRhcHRhdGlvblNldHMiLCJnZXRQZXJpb2RTdGFydCIsInByaW9yUGVyaW9kQXR0cmlidXRlcyIsIm1wZFR5cGUiLCJpbmhlcml0QXR0cmlidXRlcyIsIm1wZCIsIm9wdGlvbnMiLCJfb3B0aW9ucyIsIl9vcHRpb25zJG1hbmlmZXN0VXJpIiwibWFuaWZlc3RVcmkiLCJfb3B0aW9ucyROT1ciLCJfb3B0aW9ucyRjbGllbnRPZmZzZXQiLCJwZXJpb2ROb2RlcyIsInBlcmlvZHMiLCJwcmlvclBlcmlvZCIsInJlcHJlc2VudGF0aW9uSW5mbyIsInN0cmluZ1RvTXBkWG1sIiwibWFuaWZlc3RTdHJpbmciLCJwYXJzZXIiLCJ4bWwiLCJwYXJzZUZyb21TdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInBhcnNlVVRDVGltaW5nU2NoZW1lIiwiVVRDVGltaW5nTm9kZSIsIm1ldGhvZCIsIlZFUlNJT04iLCJwYXJzZWRNYW5pZmVzdEluZm8iLCJwYXJzZVVUQ1RpbWluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/mpd-parser/dist/mpd-parser.es.js\n");

/***/ })

};
;