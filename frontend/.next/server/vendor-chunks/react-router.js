"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(rsc)/./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(rsc)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router v6.22.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */ const NavigationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */ function useHref(to, _temp) {\n    let { relative } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */ function useInRouterContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */ function useLocation() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */ function useNavigationType() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */ function useMatch(pattern) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { pathname } = useLocation();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n    if (!isStatic) {\n        // We should be able to get rid of this once react 18.3 is released\n        // See: https://github.com/facebook/react/pull/26395\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n    }\n}\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */ function useNavigate() {\n    let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    let { basename, future, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nconst OutletContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */ function useOutletContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */ function useOutlet(context) {\n    let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */ function useParams() {\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */ function useResolvedPath(to, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { future } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */ function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + 'parent route path has no trailing \"*\". This means if you navigate ' + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = pathname;\n    if (parentPathnameBase !== \"/\") {\n        // Determine the remaining pathname by removing the # of URL segments the\n        // parentPathnameBase has, instead of removing based on character count.\n        // This is because we can't guarantee that incoming/outgoing encodings/\n        // decodings will match exactly.\n        // We decode paths before matching on a per-segment basis with\n        // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\n        // match what `window.location.pathname` would reflect.  Those don't 100%\n        // align when it comes to encoded URI characters such as % and &.\n        //\n        // So we may end up with:\n        //   pathname:           \"/descendant/a%25b/match\"\n        //   parentPathnameBase: \"/descendant/a%b\"\n        //\n        // And the direct substring removal approach won't work :/\n        let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n        let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n        remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n    }\n    let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : 0;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" ' + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + 'null value by default resulting in an \"empty\" page.') : 0;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState, future);\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (true) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error !== undefined ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error !== undefined ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n}\nfunction RenderedRoute(_ref) {\n    let { routeContext, match, children } = _ref;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n        dataRouterState = null;\n    }\n    if (future === void 0) {\n        future = null;\n    }\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n        !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    // If we're in a partial hydration mode, detect if we need to render down to\n    // a given HydrateFallback while we load the rest of the hydration data\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState && future && future.v7_partialHydration) {\n        for(let i = 0; i < renderedMatches.length; i++){\n            let match = renderedMatches[i];\n            // Track the deepest fallback up until the first route without data\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                let { loaderData, errors } = dataRouterState;\n                let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n                if (match.route.lazy || needsToRunLoader) {\n                    // We found the first route that's not ready to render (waiting on\n                    // lazy, or has a loader that hasn't run yet).  Flag that we need to\n                    // render a fallback and render up until the appropriate fallback\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    } else {\n                        renderedMatches = [\n                            renderedMatches[0]\n                        ];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        // Only data routers handle errors/fallbacks\n        let error;\n        let shouldRenderHydrateFallback = false;\n        let errorElement = null;\n        let hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : undefined;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                } else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            } else if (match.route.Component) {\n                // Note: This is a de-optimized path since React won't re-use the\n                // ReactElement since it's identity changes with each new\n                // React.createElement call.  We keep this so folks can use\n                // `<Route Component={...}>` in `<Routes>` but generally `Component`\n                // usage is only advised in `RouterProvider` when we can convert it to\n                // `element` ahead of time.\n                children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet,\n                    matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        };\n        // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook = /*#__PURE__*/ function(DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/ function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n    !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return route;\n}\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + ' can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    return thisRoute.route.id;\n}\n/**\n * Returns the ID for the nearest contextual route\n */ function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            revalidate: dataRouterContext.router.revalidate,\n            state: state.revalidation\n        }), [\n        dataRouterContext.router.revalidate,\n        state.revalidation\n    ]);\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function useMatches() {\n    let { matches, loaderData } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>matches.map((m)=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\n/**\n * Returns the loaderData for the given routeId\n */ function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */ function useRouteError() {\n    var _state$errors;\n    let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error !== undefined) {\n        return error;\n    }\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */ function useAsyncValue() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */ function useAsyncError() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */ function useBlocker(shouldBlock) {\n    let { router, basename } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n    let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        // If they provided us a function and we've got an active basename, strip\n        // it from the locations we expose to the user to match the behavior of\n        // useLocation\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: _extends({}, currentLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n            }),\n            nextLocation: _extends({}, nextLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n            }),\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\n}\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */ function useNavigateStable() {\n    let { router } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            router.navigate(to, _extends({\n                fromRouteId: id\n            }, options));\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n    }\n}\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        if (v7_startTransition && startTransitionImpl) {\n            startTransitionImpl(()=>setStateImpl(newState));\n        } else {\n            setStateImpl(newState);\n        }\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n    let { routes, future, state } = _ref2;\n    return useRoutesImpl(routes, undefined, state, future);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */ function MemoryRouter(_ref3) {\n    let { basename, children, initialEntries, initialIndex, future } = _ref3;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */ function Navigate(_ref4) {\n    let { to, replace, state, relative } = _ref4;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { future, static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>navigate(JSON.parse(jsonPath), {\n            replace,\n            state,\n            relative\n        }), [\n        navigate,\n        jsonPath,\n        relative,\n        replace,\n        state\n    ]);\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */ function Outlet(props) {\n    return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */ function Route(_props) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */ function Router(_ref5) {\n    let { basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop, navigator, static: staticProp = false, future } = _ref5;\n    !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp,\n            future: _extends({\n                v7_relativeSplatPath: false\n            }, future)\n        }), [\n        basename,\n        future,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : 0;\n    if (locationContext == null) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */ function Routes(_ref6) {\n    let { children, location } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function Await(_ref7) {\n    let { children, errorElement, resolve } = _ref7;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/ function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(()=>{});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{}); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n        } else {\n            // Raw (untracked) promise - track it\n            status = AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n            // Freeze the UI by throwing a never resolved promise\n            throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n            // No errorElement, throw to the nearest route-level error boundary\n            throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n            // Render via our errorElement\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === AwaitRenderStatus.success) {\n            // Render children with resolved value\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: children\n            });\n        }\n        // Throw to the suspense boundary\n        throw promise;\n    }\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */ function ResolveAwait(_ref8) {\n    let { children } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */ function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    let routes = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index)=>{\n        if (!/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (true) {\n            if (route.element) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            element: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n            Component: undefined\n        });\n    }\n    if (route.HydrateFallback) {\n        if (true) {\n            if (route.hydrateFallbackElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\n            HydrateFallback: undefined\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (true) {\n            if (route.errorElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            errorElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n            ErrorBoundary: undefined\n        });\n    }\n    return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes,\n        mapRouteProperties\n    }).initialize();\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ2tSO0FBQ3JGO0FBRTVOLFNBQVN5QjtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsOEVBQThFO0FBQzlFLDJCQUEyQjtBQUMzQixNQUFNUSxvQkFBb0IsV0FBVyxHQUFFdkMsZ0RBQW1CLENBQUM7QUFDM0QsSUFBSXlDLElBQXFDLEVBQUU7SUFDekNGLGtCQUFrQkcsV0FBVyxHQUFHO0FBQ2xDO0FBQ0EsTUFBTUMseUJBQXlCLFdBQVcsR0FBRTNDLGdEQUFtQixDQUFDO0FBQ2hFLElBQUl5QyxJQUFxQyxFQUFFO0lBQ3pDRSx1QkFBdUJELFdBQVcsR0FBRztBQUN2QztBQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFNUMsZ0RBQW1CLENBQUM7QUFDdEQsSUFBSXlDLElBQXFDLEVBQUU7SUFDekNHLGFBQWFGLFdBQVcsR0FBRztBQUM3QjtBQUVBOzs7Ozs7OztDQVFDLEdBRUQsTUFB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QUN6RDtRQUNBeUQsZUFBZWxFLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtrRSxhQUFhO1FBQ3pEcE87UUFDQWdPO0lBQ0YsR0FBR0ssVUFBVTtBQUNmO0FBRXkxQixDQUN6MUIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnJlZXplLW5leHQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanM/MmExZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlYWN0IFJvdXRlciB2Ni4yMi4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFVOU0FGRV9pbnZhcmlhbnQsIGpvaW5QYXRocywgbWF0Y2hQYXRoLCBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcywgVU5TQUZFX3dhcm5pbmcsIHJlc29sdmVUbywgcGFyc2VQYXRoLCBtYXRjaFJvdXRlcywgQWN0aW9uLCBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsIHN0cmlwQmFzZW5hbWUsIElETEVfQkxPQ0tFUiwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGNyZWF0ZU1lbW9yeUhpc3RvcnksIEFib3J0ZWREZWZlcnJlZEVycm9yLCBjcmVhdGVSb3V0ZXIgfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLCBjcmVhdGVQYXRoLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVkaXJlY3REb2N1bWVudCwgcmVzb2x2ZVBhdGggfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLyBDcmVhdGUgcmVhY3Qtc3BlY2lmaWMgdHlwZXMgZnJvbSB0aGUgYWdub3N0aWMgdHlwZXMgaW4gQHJlbWl4LXJ1bi9yb3V0ZXIgdG9cbi8vIGV4cG9ydCBmcm9tIHJlYWN0LXJvdXRlclxuY29uc3QgRGF0YVJvdXRlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRGF0YVJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJcIjtcbn1cbmNvbnN0IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG59XG5jb25zdCBBd2FpdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xufVxuXG4vKipcbiAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAqXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXG4gKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCBgPFJvdXRlcj5gIEFQSVxuICogd2hlcmUgYm90aCB0aGUgbG9jYXRpb24gYW5kIGEgbmF2aWdhdG9yIG11c3QgYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBpbiBvcmRlclxuICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXG4gKiBhbmQvb3IgbG9jYXRpb24gd2VyZSB0byBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGhpc3RvcnkgaW5zdGFuY2UuXG4gKi9cblxuY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG59XG5jb25zdCBSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW10sXG4gIGlzRGF0YVJvdXRlOiBmYWxzZVxufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cbmNvbnN0IFJvdXRlRXJyb3JDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJvdXRlRXJyb3JDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZUVycm9yXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWhyZWZcbiAqL1xuZnVuY3Rpb24gdXNlSHJlZih0bywgX3RlbXApIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBoYXNoLFxuICAgIHBhdGhuYW1lLFxuICAgIHNlYXJjaFxuICB9ID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGhyZWYuICBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIGp1c3QgdXNlIHRoZSByYXdcbiAgLy8gYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZVxuICAvLyBvZiBhIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7XG4gICAgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSBgPFJvdXRlcj5gLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWluLXJvdXRlci1jb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcbiAqIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXG4gKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gKiBiZSBhYmxlIHRvIHByb3ZpZGUgc29tZXRoaW5nIGhpZ2hlci1sZXZlbCB0byBiZXR0ZXIgc3VpdCB5b3VyIG5lZWRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLWxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5sb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gYWN0aW9uIHdoaWNoIGRlc2NyaWJlcyBob3cgdGhlIHJvdXRlciBjYW1lIHRvXG4gKiB0aGUgY3VycmVudCBsb2NhdGlvbiwgZWl0aGVyIGJ5IGEgcG9wLCBwdXNoLCBvciByZXBsYWNlIG9uIHRoZSBoaXN0b3J5IHN0YWNrLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRpb24tdHlwZVxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KS5uYXZpZ2F0aW9uVHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUGF0aE1hdGNoIG9iamVjdCBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IFwiYWN0aXZlXCIgc3RhdGUsIGUuZy5cbiAqIGA8TmF2TGluaz5gLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW1hdGNoXG4gKi9cbmZ1bmN0aW9uIHVzZU1hdGNoKHBhdHRlcm4pIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgcGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSksIFtwYXRobmFtZSwgcGF0dGVybl0pO1xufVxuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBuYXZpZ2F0ZSgpIGZ1bmN0aW9uIHJldHVybmVkIGZyb20gdXNlTmF2aWdhdGUoKS5cbiAqL1xuXG5jb25zdCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcgPSBcIllvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIFwiICsgXCJ5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5cIjtcblxuLy8gTXV0ZSB3YXJuaW5ncyBmb3IgY2FsbHMgdG8gdXNlTmF2aWdhdGUgaW4gU1NSIGVudmlyb25tZW50c1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjYikge1xuICBsZXQgaXNTdGF0aWMgPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWM7XG4gIGlmICghaXNTdGF0aWMpIHtcbiAgICAvLyBXZSBzaG91bGQgYmUgYWJsZSB0byBnZXQgcmlkIG9mIHRoaXMgb25jZSByZWFjdCAxOC4zIGlzIHJlbGVhc2VkXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdChjYik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgYDxMaW5rPmBzLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpIHtcbiAgbGV0IHtcbiAgICBpc0RhdGFSb3V0ZVxuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICByZXR1cm4gaXNEYXRhUm91dGUgPyB1c2VOYXZpZ2F0ZVN0YWJsZSgpIDogdXNlTmF2aWdhdGVVbnN0YWJsZSgpO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGVVbnN0YWJsZSgpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VOYXZpZ2F0ZSgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGZ1dHVyZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCkpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA6IHZvaWQgMDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaGVyZSBzaW5jZSBpZiB0aGlzIGhhcHBlbnMgb24gZmlyc3QgcmVuZGVyIHRoZSBuYXZpZ2F0ZVxuICAgIC8vIGlzIHVzZWxlc3MgYmVjYXVzZSB3ZSBoYXZlbid0IHdpcmVkIHVwIG91ciBoaXN0b3J5IGxpc3RlbmVyIHlldFxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIik7XG5cbiAgICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgLy8gb3RoZXJ3aXNlIGl0J2xsIHByZXBlbmQgdGhlIGJhc2VuYW1lIGluc2lkZSBvZiB0aGUgcm91dGVyKS5cbiAgICAvLyBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIHdlIG5hdmlnYXRlIHRvIHRoZSByYXcgYmFzZW5hbWVcbiAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAvLyB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gICAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ID09IG51bGwgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICB9XG4gICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkocGF0aCwgb3B0aW9ucy5zdGF0ZSwgb3B0aW9ucyk7XG4gIH0sIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIGRhdGFSb3V0ZXJDb250ZXh0XSk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbmNvbnN0IE91dGxldENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0LWNvbnRleHRcbiAqL1xuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSBgPE91dGxldD5gIHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0XG4gKi9cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgb3V0bGV0KTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xuICovXG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJlc29sdmVkLXBhdGhcbiAqL1xuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgbGV0IHtcbiAgICBmdXR1cmVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCkpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKSwgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gYDxPdXRsZXQ+YCB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICogZWxlbWVudC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG59XG5cbi8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIHdpdGggYWNjZXB0IG9wdGlvbmFsIHBhcmFtIGZvciBSb3V0ZXJQcm92aWRlciB1c2FnZVxuZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZU1hdGNoID0gcGFyZW50TWF0Y2hlc1twYXJlbnRNYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBsZXQgcGFyZW50UGFyYW1zID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XG4gIGxldCBwYXJlbnRQYXRobmFtZUJhc2UgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZUJhc2UgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFJvdXRlID0gcm91dGVNYXRjaCAmJiByb3V0ZU1hdGNoLnJvdXRlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgLy8gWW91IHdvbid0IGdldCBhIHdhcm5pbmcgYWJvdXQgMiBkaWZmZXJlbnQgPFJvdXRlcz4gdW5kZXIgYSA8Um91dGU+XG4gICAgLy8gd2l0aG91dCBhIHRyYWlsaW5nICosIGJ1dCB0aGlzIGlzIGEgYmVzdC1lZmZvcnQgd2FybmluZyBhbnl3YXkgc2luY2Ugd2VcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cbiAgICAvL1xuICAgIC8vIEV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyA8Um91dGVzPlxuICAgIC8vICAgey8qIFRoaXMgcm91dGUgcGF0aCBNVVNUIGVuZCB3aXRoIC8qIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZ1wiIGVsZW1lbnQ9ezxCbG9nIC8+fSAvPlxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nL2ZlZWRcIiBlbGVtZW50PXs8QmxvZ0ZlZWQgLz59IC8+XG4gICAgLy8gPC9Sb3V0ZXM+XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiBCbG9nKCkge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPFJvdXRlcz5cbiAgICAvLyAgICAgICA8Um91dGUgcGF0aD1cInBvc3QvOmlkXCIgZWxlbWVudD17PFBvc3QgLz59IC8+XG4gICAgLy8gICAgIDwvUm91dGVzPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UocGFyZW50UGF0aG5hbWUsICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSwgXCJZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIGB1c2VSb3V0ZXMoKWApIGF0IFwiICsgKFwiXFxcIlwiICsgcGFyZW50UGF0aG5hbWUgKyBcIlxcXCIgKHVuZGVyIDxSb3V0ZSBwYXRoPVxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCI+KSBidXQgdGhlIFwiKSArIFwicGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFxcXCIqXFxcIi4gVGhpcyBtZWFucyBpZiB5b3UgbmF2aWdhdGUgXCIgKyBcImRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIFwiICsgXCJyb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXFxuXFxuXCIgKyAoXCJQbGVhc2UgY2hhbmdlIHRoZSBwYXJlbnQgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4gdG8gPFJvdXRlIFwiKSArIChcInBhdGg9XFxcIlwiICsgKHBhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBwYXJlbnRQYXRoICsgXCIvKlwiKSArIFwiXFxcIj4uXCIpKTtcbiAgfVxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcbiAgICBsZXQgcGFyc2VkTG9jYXRpb25BcmcgPSB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG4gICAgIShwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8ICgoX3BhcnNlZExvY2F0aW9uQXJnJHBhID0gcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyc2VkTG9jYXRpb25BcmckcGEuc3RhcnRzV2l0aChwYXJlbnRQYXRobmFtZUJhc2UpKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIldoZW4gb3ZlcnJpZGluZyB0aGUgbG9jYXRpb24gdXNpbmcgYDxSb3V0ZXMgbG9jYXRpb24+YCBvciBgdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb24pYCwgXCIgKyBcInRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBcIiArIChcIm1hdGNoZWQgYnkgYWxsIHBhcmVudCByb3V0ZXMuIFRoZSBjdXJyZW50IHBhdGhuYW1lIGJhc2UgaXMgXFxcIlwiICsgcGFyZW50UGF0aG5hbWVCYXNlICsgXCJcXFwiIFwiKSArIChcImJ1dCBwYXRobmFtZSBcXFwiXCIgKyBwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZSArIFwiXFxcIiB3YXMgZ2l2ZW4gaW4gdGhlIGBsb2NhdGlvbmAgcHJvcC5cIikpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAocGFyZW50UGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgIC8vIERldGVybWluZSB0aGUgcmVtYWluaW5nIHBhdGhuYW1lIGJ5IHJlbW92aW5nIHRoZSAjIG9mIFVSTCBzZWdtZW50cyB0aGVcbiAgICAvLyBwYXJlbnRQYXRobmFtZUJhc2UgaGFzLCBpbnN0ZWFkIG9mIHJlbW92aW5nIGJhc2VkIG9uIGNoYXJhY3RlciBjb3VudC5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgY2FuJ3QgZ3VhcmFudGVlIHRoYXQgaW5jb21pbmcvb3V0Z29pbmcgZW5jb2RpbmdzL1xuICAgIC8vIGRlY29kaW5ncyB3aWxsIG1hdGNoIGV4YWN0bHkuXG4gICAgLy8gV2UgZGVjb2RlIHBhdGhzIGJlZm9yZSBtYXRjaGluZyBvbiBhIHBlci1zZWdtZW50IGJhc2lzIHdpdGhcbiAgICAvLyBkZWNvZGVVUklDb21wb25lbnQoKSwgYnV0IHdlIHJlLWVuY29kZSBwYXRobmFtZXMgdmlhIGBuZXcgVVJMKClgIHNvIHRoZXlcbiAgICAvLyBtYXRjaCB3aGF0IGB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVgIHdvdWxkIHJlZmxlY3QuICBUaG9zZSBkb24ndCAxMDAlXG4gICAgLy8gYWxpZ24gd2hlbiBpdCBjb21lcyB0byBlbmNvZGVkIFVSSSBjaGFyYWN0ZXJzIHN1Y2ggYXMgJSBhbmQgJi5cbiAgICAvL1xuICAgIC8vIFNvIHdlIG1heSBlbmQgdXAgd2l0aDpcbiAgICAvLyAgIHBhdGhuYW1lOiAgICAgICAgICAgXCIvZGVzY2VuZGFudC9hJTI1Yi9tYXRjaFwiXG4gICAgLy8gICBwYXJlbnRQYXRobmFtZUJhc2U6IFwiL2Rlc2NlbmRhbnQvYSViXCJcbiAgICAvL1xuICAgIC8vIEFuZCB0aGUgZGlyZWN0IHN1YnN0cmluZyByZW1vdmFsIGFwcHJvYWNoIHdvbid0IHdvcmsgOi9cbiAgICBsZXQgcGFyZW50U2VnbWVudHMgPSBwYXJlbnRQYXRobmFtZUJhc2UucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgc2VnbWVudHMgPSBwYXRobmFtZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gXCIvXCIgKyBzZWdtZW50cy5zbGljZShwYXJlbnRTZWdtZW50cy5sZW5ndGgpLmpvaW4oXCIvXCIpO1xuICB9XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCB7XG4gICAgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lXG4gIH0pO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcocGFyZW50Um91dGUgfHwgbWF0Y2hlcyAhPSBudWxsLCBcIk5vIHJvdXRlcyBtYXRjaGVkIGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLkNvbXBvbmVudCAhPT0gdW5kZWZpbmVkIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5sYXp5ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIiArIFwiZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBcIiArIFwibnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcXFwiZW1wdHlcXFwiIHBhZ2UuXCIpIDogdm9pZCAwO1xuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzICYmIG1hdGNoZXMubWFwKG1hdGNoID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXSksXG4gICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gIH0pKSwgcGFyZW50TWF0Y2hlcywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpO1xuXG4gIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXG4gIC8vIGJlIHdyYXBwZWQgaW4gYSBuZXcgYExvY2F0aW9uQ29udGV4dC5Qcm92aWRlcmAgaW4gb3JkZXIgZm9yIGB1c2VMb2NhdGlvbmBcbiAgLy8gdG8gdXNlIHRoZSBzY29wZWQgbG9jYXRpb24gaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIGxvY2F0aW9uLlxuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbG9jYXRpb246IF9leHRlbmRzKHtcbiAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgc2VhcmNoOiBcIlwiLFxuICAgICAgICAgIGhhc2g6IFwiXCIsXG4gICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAga2V5OiBcImRlZmF1bHRcIlxuICAgICAgICB9LCBsb2NhdGlvbiksXG4gICAgICAgIG5hdmlnYXRpb25UeXBlOiBBY3Rpb24uUG9wXG4gICAgICB9XG4gICAgfSwgcmVuZGVyZWRNYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzO1xufVxuZnVuY3Rpb24gRGVmYXVsdEVycm9yQ29tcG9uZW50KCkge1xuICBsZXQgZXJyb3IgPSB1c2VSb3V0ZUVycm9yKCk7XG4gIGxldCBtZXNzYWdlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzICsgXCIgXCIgKyBlcnJvci5zdGF0dXNUZXh0IDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gIGxldCBzdGFjayA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XG4gIGxldCBsaWdodGdyZXkgPSBcInJnYmEoMjAwLDIwMCwyMDAsIDAuNSlcIjtcbiAgbGV0IHByZVN0eWxlcyA9IHtcbiAgICBwYWRkaW5nOiBcIjAuNXJlbVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gIH07XG4gIGxldCBjb2RlU3R5bGVzID0ge1xuICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XG4gIH07XG4gIGxldCBkZXZJbmZvID0gbnVsbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGVkIGJ5IFJlYWN0IFJvdXRlciBkZWZhdWx0IEVycm9yQm91bmRhcnk6XCIsIGVycm9yKTtcbiAgICBkZXZJbmZvID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdUQ4M0RcXHVEQ0JGIEhleSBkZXZlbG9wZXIgXFx1RDgzRFxcdURDNEJcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIllvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycyBieSBwcm92aWRpbmcgeW91ciBvd24gXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiRXJyb3JCb3VuZGFyeVwiKSwgXCIgb3JcIiwgXCIgXCIsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7XG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xuICAgIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJVbmV4cGVjdGVkIEFwcGxpY2F0aW9uIEVycm9yIVwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgIH1cbiAgfSwgbWVzc2FnZSksIHN0YWNrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHN0eWxlOiBwcmVTdHlsZXNcbiAgfSwgc3RhY2spIDogbnVsbCwgZGV2SW5mbyk7XG59XG5jb25zdCBkZWZhdWx0RXJyb3JFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVycm9yQ29tcG9uZW50LCBudWxsKTtcbmNsYXNzIFJlbmRlckVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24sXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiwgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZSBjb250aW51ZXMgdG8gZGlzcGxheS5cbiAgICAvLyBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3Igd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uICE9PSBcImlkbGVcIiAmJiBwcm9wcy5yZXZhbGlkYXRpb24gPT09IFwiaWRsZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXG4gICAgLy8gYW55IG5ldyBlcnJvcnMgdGhhdCBtYXkgY29tZSB0aHJvdWdoLiBXZSByZXRhaW4gdGhlIGV4aXN0aW5nIGVycm9yLCB3ZSBkb1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0aGUgZXJyb3IgcHJvdmlkZWQgZnJvbSB0aGUgYXBwIHN0YXRlIG1heSBiZSBjbGVhcmVkIHdpdGhvdXRcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciAhPT0gdW5kZWZpbmVkID8gcHJvcHMuZXJyb3IgOiBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvblxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBSb3V0ZXIgY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgIT09IHVuZGVmaW5lZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVFcnJvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY29tcG9uZW50XG4gICAgfSkpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZShfcmVmKSB7XG4gIGxldCB7XG4gICAgcm91dGVDb250ZXh0LFxuICAgIG1hdGNoLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcblxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXG4gIC8vIGluIGEgRGF0YVN0YXRpY1JvdXRlclxuICBpZiAoZGF0YVJvdXRlckNvbnRleHQgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiYgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJvdXRlQ29udGV4dFxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xuICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTI7XG4gIGlmIChwYXJlbnRNYXRjaGVzID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRNYXRjaGVzID0gW107XG4gIH1cbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGF0YVJvdXRlclN0YXRlID0gbnVsbDtcbiAgfVxuICBpZiAoZnV0dXJlID09PSB2b2lkIDApIHtcbiAgICBmdXR1cmUgPSBudWxsO1xuICB9XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTtcbiAgICBpZiAoKF9kYXRhUm91dGVyU3RhdGUgPSBkYXRhUm91dGVyU3RhdGUpICE9IG51bGwgJiYgX2RhdGFSb3V0ZXJTdGF0ZS5lcnJvcnMpIHtcbiAgICAgIC8vIERvbid0IGJhaWwgaWYgd2UgaGF2ZSBkYXRhIHJvdXRlciBlcnJvcnMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGluIHRoZVxuICAgICAgLy8gYm91bmRhcnkuICBVc2UgdGhlIHByZS1tYXRjaGVkIChvciBzaGltbWVkKSBtYXRjaGVzXG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcblxuICAvLyBJZiB3ZSBoYXZlIGRhdGEgZXJyb3JzLCB0cmltIG1hdGNoZXMgdG8gdGhlIGhpZ2hlc3QgZXJyb3IgYm91bmRhcnlcbiAgbGV0IGVycm9ycyA9IChfZGF0YVJvdXRlclN0YXRlMiA9IGRhdGFSb3V0ZXJTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUm91dGVyU3RhdGUyLmVycm9ycztcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XG4gICAgbGV0IGVycm9ySW5kZXggPSByZW5kZXJlZE1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCAmJiAoZXJyb3JzID09IG51bGwgPyB2b2lkIDAgOiBlcnJvcnNbbS5yb3V0ZS5pZF0pKTtcbiAgICAhKGVycm9ySW5kZXggPj0gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIGVycm9ycyBvbiByb3V0ZSBJRHM6IFwiICsgT2JqZWN0LmtleXMoZXJyb3JzKS5qb2luKFwiLFwiKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgTWF0aC5taW4ocmVuZGVyZWRNYXRjaGVzLmxlbmd0aCwgZXJyb3JJbmRleCArIDEpKTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGluIGEgcGFydGlhbCBoeWRyYXRpb24gbW9kZSwgZGV0ZWN0IGlmIHdlIG5lZWQgdG8gcmVuZGVyIGRvd24gdG9cbiAgLy8gYSBnaXZlbiBIeWRyYXRlRmFsbGJhY2sgd2hpbGUgd2UgbG9hZCB0aGUgcmVzdCBvZiB0aGUgaHlkcmF0aW9uIGRhdGFcbiAgbGV0IHJlbmRlckZhbGxiYWNrID0gZmFsc2U7XG4gIGxldCBmYWxsYmFja0luZGV4ID0gLTE7XG4gIGlmIChkYXRhUm91dGVyU3RhdGUgJiYgZnV0dXJlICYmIGZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtYXRjaCA9IHJlbmRlcmVkTWF0Y2hlc1tpXTtcbiAgICAgIC8vIFRyYWNrIHRoZSBkZWVwZXN0IGZhbGxiYWNrIHVwIHVudGlsIHRoZSBmaXJzdCByb3V0ZSB3aXRob3V0IGRhdGFcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICBmYWxsYmFja0luZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGxvYWRlckRhdGEsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgIH0gPSBkYXRhUm91dGVyU3RhdGU7XG4gICAgICAgIGxldCBuZWVkc1RvUnVuTG9hZGVyID0gbWF0Y2gucm91dGUubG9hZGVyICYmIGxvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQgJiYgKCFlcnJvcnMgfHwgZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIHRoZSBmaXJzdCByb3V0ZSB0aGF0J3Mgbm90IHJlYWR5IHRvIHJlbmRlciAod2FpdGluZyBvblxuICAgICAgICAgIC8vIGxhenksIG9yIGhhcyBhIGxvYWRlciB0aGF0IGhhc24ndCBydW4geWV0KS4gIEZsYWcgdGhhdCB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gcmVuZGVyIGEgZmFsbGJhY2sgYW5kIHJlbmRlciB1cCB1bnRpbCB0aGUgYXBwcm9wcmlhdGUgZmFsbGJhY2tcbiAgICAgICAgICByZW5kZXJGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaWYgKGZhbGxiYWNrSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGZhbGxiYWNrSW5kZXggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gW3JlbmRlcmVkTWF0Y2hlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9ycy9mYWxsYmFja3NcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuICAgIGxldCBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICBlcnJvciA9IGVycm9ycyAmJiBtYXRjaC5yb3V0ZS5pZCA/IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgICBlcnJvckVsZW1lbnQgPSBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgZGVmYXVsdEVycm9yRWxlbWVudDtcbiAgICAgIGlmIChyZW5kZXJGYWxsYmFjaykge1xuICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA8IDAgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICB3YXJuaW5nT25jZShcInJvdXRlLWZhbGxiYWNrXCIsIGZhbHNlLCBcIk5vIGBIeWRyYXRlRmFsbGJhY2tgIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyIGR1cmluZyBpbml0aWFsIGh5ZHJhdGlvblwiKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtYXRjaGVzID0gcGFyZW50TWF0Y2hlcy5jb25jYXQocmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpO1xuICAgIGxldCBnZXRDaGlsZHJlbiA9ICgpID0+IHtcbiAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgICAgIGNoaWxkcmVuID0gaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBkZS1vcHRpbWl6ZWQgcGF0aCBzaW5jZSBSZWFjdCB3b24ndCByZS11c2UgdGhlXG4gICAgICAgIC8vIFJlYWN0RWxlbWVudCBzaW5jZSBpdCdzIGlkZW50aXR5IGNoYW5nZXMgd2l0aCBlYWNoIG5ld1xuICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxuICAgICAgICAvLyBgPFJvdXRlIENvbXBvbmVudD17Li4ufT5gIGluIGA8Um91dGVzPmAgYnV0IGdlbmVyYWxseSBgQ29tcG9uZW50YFxuICAgICAgICAvLyB1c2FnZSBpcyBvbmx5IGFkdmlzZWQgaW4gYFJvdXRlclByb3ZpZGVyYCB3aGVuIHdlIGNhbiBjb252ZXJ0IGl0IHRvXG4gICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KG1hdGNoLnJvdXRlLkNvbXBvbmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4gPSBvdXRsZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyZWRSb3V0ZSwge1xuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIHJvdXRlQ29udGV4dDoge1xuICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGlzRGF0YVJvdXRlOiBkYXRhUm91dGVyU3RhdGUgIT0gbnVsbFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gT25seSB3cmFwIGluIGFuIGVycm9yIGJvdW5kYXJ5IHdpdGhpbiBkYXRhIHJvdXRlciB1c2FnZXMgd2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvXG4gICAgLy8gYW4gYW5jZXN0b3IgRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnRcbiAgICByZXR1cm4gZGF0YVJvdXRlclN0YXRlICYmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5IHx8IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBpbmRleCA9PT0gMCkgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW5kZXJFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBkYXRhUm91dGVyU3RhdGUucmV2YWxpZGF0aW9uLFxuICAgICAgY29tcG9uZW50OiBlcnJvckVsZW1lbnQsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBjaGlsZHJlbjogZ2V0Q2hpbGRyZW4oKSxcbiAgICAgIHJvdXRlQ29udGV4dDoge1xuICAgICAgICBvdXRsZXQ6IG51bGwsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGlzRGF0YVJvdXRlOiB0cnVlXG4gICAgICB9XG4gICAgfSkgOiBnZXRDaGlsZHJlbigpO1xuICB9LCBudWxsKTtcbn1cbnZhciBEYXRhUm91dGVySG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlckhvb2spIHtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG4gIHJldHVybiBEYXRhUm91dGVySG9vaztcbn0oRGF0YVJvdXRlckhvb2sgfHwge30pO1xudmFyIERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUJsb2NrZXJcIl0gPSBcInVzZUJsb2NrZXJcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUxvYWRlckRhdGFcIl0gPSBcInVzZUxvYWRlckRhdGFcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUFjdGlvbkRhdGFcIl0gPSBcInVzZUFjdGlvbkRhdGFcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlRXJyb3JcIl0gPSBcInVzZVJvdXRlRXJyb3JcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRpb25cIl0gPSBcInVzZU5hdmlnYXRpb25cIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlTG9hZGVyRGF0YVwiXSA9IFwidXNlUm91dGVMb2FkZXJEYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VNYXRjaGVzXCJdID0gXCJ1c2VNYXRjaGVzXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRlU3RhYmxlXCJdID0gXCJ1c2VOYXZpZ2F0ZVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVJZFwiXSA9IFwidXNlUm91dGVJZFwiO1xuICByZXR1cm4gRGF0YVJvdXRlclN0YXRlSG9vaztcbn0oRGF0YVJvdXRlclN0YXRlSG9vayB8fCB7fSk7XG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XG4gIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gICFjdHggPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAhc3RhdGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiByb3V0ZTtcbn1cblxuLy8gSW50ZXJuYWwgdmVyc2lvbiB3aXRoIGhvb2tOYW1lLWF3YXJlIGRlYnVnZ2luZ1xuZnVuY3Rpb24gdXNlQ3VycmVudFJvdXRlSWQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKTtcbiAgbGV0IHRoaXNSb3V0ZSA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgIXRoaXNSb3V0ZS5yb3V0ZS5pZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGhvb2tOYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFxcXCJpZFxcXCJcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHRoaXNSb3V0ZS5yb3V0ZS5pZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBJRCBmb3IgdGhlIG5lYXJlc3QgY29udGV4dHVhbCByb3V0ZVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZUlkKCkge1xuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUlkKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5hdmlnYXRpb24sIGRlZmF1bHRpbmcgdG8gYW4gXCJpZGxlXCIgbmF2aWdhdGlvbiB3aGVuXG4gKiBubyBuYXZpZ2F0aW9uIGlzIGluIHByb2dyZXNzXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRpb24pO1xuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmV2YWxpZGF0ZSBmdW5jdGlvbiBmb3IgbWFudWFsbHkgdHJpZ2dlcmluZyByZXZhbGlkYXRpb24sIGFzIHdlbGxcbiAqIGFzIHRoZSBjdXJyZW50IHN0YXRlIG9mIGFueSBtYW51YWwgcmV2YWxpZGF0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmV2YWxpZGF0ZTogZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsXG4gICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxuICB9KSwgW2RhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLCBzdGF0ZS5yZXZhbGlkYXRpb25dKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3RpdmUgcm91dGUgbWF0Y2hlcywgdXNlZnVsIGZvciBhY2Nlc3NpbmcgbG9hZGVyRGF0YSBmb3JcbiAqIHBhcmVudC9jaGlsZCByb3V0ZXMgb3IgdGhlIHJvdXRlIFwiaGFuZGxlXCIgcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gdXNlTWF0Y2hlcygpIHtcbiAgbGV0IHtcbiAgICBtYXRjaGVzLFxuICAgIGxvYWRlckRhdGFcbiAgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU1hdGNoZXMpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaGVzLm1hcChtID0+IFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBsb2FkZXJEYXRhKSksIFttYXRjaGVzLCBsb2FkZXJEYXRhXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGxvYWRlclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXJEYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICBpZiAoc3RhdGUuZXJyb3JzICYmIHN0YXRlLmVycm9yc1tyb3V0ZUlkXSAhPSBudWxsKSB7XG4gICAgY29uc29sZS5lcnJvcihcIllvdSBjYW5ub3QgYHVzZUxvYWRlckRhdGFgIGluIGFuIGVycm9yRWxlbWVudCAocm91dGVJZDogXCIgKyByb3V0ZUlkICsgXCIpXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVMb2FkZXJEYXRhKHJvdXRlSWQpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aW9uIGRhdGEgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGFjdGlvblxuICovXG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VBY3Rpb25EYXRhKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICByZXR1cm4gc3RhdGUuYWN0aW9uRGF0YSA/IHN0YXRlLmFjdGlvbkRhdGFbcm91dGVJZF0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBlcnJvciwgd2hpY2ggY291bGQgYmUgYSBsb2FkZXIvYWN0aW9uXG4gKiBlcnJvciBvciBhIHJlbmRlciBlcnJvci4gIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGZyb20geW91clxuICogRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgdG8gZGlzcGxheSBhIHByb3BlciBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCkge1xuICB2YXIgX3N0YXRlJGVycm9ycztcbiAgbGV0IGVycm9yID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUVycm9yQ29udGV4dCk7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG5cbiAgLy8gSWYgdGhpcyB3YXMgYSByZW5kZXIgZXJyb3IsIHdlIHB1dCBpdCBpbiBhIFJvdXRlRXJyb3IgY29udGV4dCBpbnNpZGVcbiAgLy8gb2YgUmVuZGVyRXJyb3JCb3VuZGFyeVxuICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSBsb29rIGZvciBlcnJvcnMgZnJvbSBvdXIgZGF0YSByb3V0ZXIgc3RhdGVcbiAgcmV0dXJuIChfc3RhdGUkZXJyb3JzID0gc3RhdGUuZXJyb3JzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGVycm9yc1tyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYXBweS1wYXRoIGRhdGEgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciBgPEF3YWl0IC8+YCB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VBc3luY1ZhbHVlKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXJyb3IgZnJvbSB0aGUgbmVhcmVzdCBhbmNlc3RvciBgPEF3YWl0IC8+YCB2YWx1ZVxuICovXG5mdW5jdGlvbiB1c2VBc3luY0Vycm9yKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2Vycm9yO1xufVxubGV0IGJsb2NrZXJJZCA9IDA7XG5cbi8qKlxuICogQWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGJsb2NrIG5hdmlnYXRpb25zIHdpdGhpbiB0aGUgU1BBIGFuZCBwcmVzZW50IHRoZVxuICogdXNlciBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgdG8gY29uZmlybSB0aGUgbmF2aWdhdGlvbi4gIE1vc3RseSB1c2VkIHRvIGF2b2lkXG4gKiB1c2luZyBoYWxmLWZpbGxlZCBmb3JtIGRhdGEuICBUaGlzIGRvZXMgbm90IGhhbmRsZSBoYXJkLXJlbG9hZHMgb3JcbiAqIGNyb3NzLW9yaWdpbiBuYXZpZ2F0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jaykge1xuICBsZXQge1xuICAgIHJvdXRlcixcbiAgICBiYXNlbmFtZVxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUJsb2NrZXIpO1xuICBsZXQgW2Jsb2NrZXJLZXksIHNldEJsb2NrZXJLZXldID0gUmVhY3QudXNlU3RhdGUoXCJcIik7XG4gIGxldCBibG9ja2VyRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhhcmcgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2hvdWxkQmxvY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XG4gICAgfVxuICAgIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXkgcHJvdmlkZWQgdXMgYSBmdW5jdGlvbiBhbmQgd2UndmUgZ290IGFuIGFjdGl2ZSBiYXNlbmFtZSwgc3RyaXBcbiAgICAvLyBpdCBmcm9tIHRoZSBsb2NhdGlvbnMgd2UgZXhwb3NlIHRvIHRoZSB1c2VyIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZlxuICAgIC8vIHVzZUxvY2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9ID0gYXJnO1xuICAgIHJldHVybiBzaG91bGRCbG9jayh7XG4gICAgICBjdXJyZW50TG9jYXRpb246IF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUoY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KSxcbiAgICAgIG5leHRMb2NhdGlvbjogX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0pO1xuICB9LCBbYmFzZW5hbWUsIHNob3VsZEJsb2NrXSk7XG5cbiAgLy8gVGhpcyBlZmZlY3QgaXMgaW4gY2hhcmdlIG9mIGJsb2NrZXIga2V5IGFzc2lnbm1lbnQgYW5kIGRlbGV0aW9uICh3aGljaCBpc1xuICAvLyB0aWdodGx5IGNvdXBsZWQgdG8gdGhlIGtleSlcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQga2V5ID0gU3RyaW5nKCsrYmxvY2tlcklkKTtcbiAgICBzZXRCbG9ja2VyS2V5KGtleSk7XG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGtleSk7XG4gIH0sIFtyb3V0ZXJdKTtcblxuICAvLyBUaGlzIGVmZmVjdCBoYW5kbGVzIGFzc2lnbmluZyB0aGUgYmxvY2tlckZ1bmN0aW9uLiAgVGhpcyBpcyB0byBoYW5kbGVcbiAgLy8gdW5zdGFibGUgYmxvY2tlciBmdW5jdGlvbiBpZGVudGl0aWVzLCBhbmQgaGFwcGVucyBvbmx5IGFmdGVyIHRoZSBwcmlvclxuICAvLyBlZmZlY3Qgc28gd2UgZG9uJ3QgZ2V0IGFuIG9ycGhhbmVkIGJsb2NrZXJGdW5jdGlvbiBpbiB0aGUgcm91dGVyIHdpdGggYVxuICAvLyBrZXkgb2YgXCJcIi4gIFVudGlsIHRoZW4gd2UganVzdCBoYXZlIHRoZSBJRExFX0JMT0NLRVIuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGJsb2NrZXJLZXkgIT09IFwiXCIpIHtcbiAgICAgIHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XG4gICAgfVxuICB9LCBbcm91dGVyLCBibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dKTtcblxuICAvLyBQcmVmZXIgdGhlIGJsb2NrZXIgZnJvbSBgc3RhdGVgIG5vdCBgcm91dGVyLnN0YXRlYCBzaW5jZSBEYXRhUm91dGVyQ29udGV4dFxuICAvLyBpcyBtZW1vaXplZCBzbyB0aGlzIGVuc3VyZXMgd2UgdXBkYXRlIG9uIGJsb2NrZXIgc3RhdGUgdXBkYXRlc1xuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiBJRExFX0JMT0NLRVI7XG59XG5cbi8qKlxuICogU3RhYmxlIHZlcnNpb24gb2YgdXNlTmF2aWdhdGUgdGhhdCBpcyB1c2VkIHdoZW4gd2UgYXJlIGluIHRoZSBjb250ZXh0IG9mXG4gKiBhIFJvdXRlclByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVN0YWJsZSgpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0ZVN0YWJsZSk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuICBsZXQgbmF2aWdhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpIDogdm9pZCAwO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXG4gICAgLy8gaXMgdXNlbGVzcyBiZWNhdXNlIHdlIGhhdmVuJ3Qgd2lyZWQgdXAgb3VyIHJvdXRlciBzdWJzY3JpYmVyIHlldFxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICByb3V0ZXIubmF2aWdhdGUodG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZXIubmF2aWdhdGUodG8sIF9leHRlbmRzKHtcbiAgICAgICAgZnJvbVJvdXRlSWQ6IGlkXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICB9LCBbcm91dGVyLCBpZF0pO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG5jb25zdCBhbHJlYWR5V2FybmVkID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kICYmICFhbHJlYWR5V2FybmVkW2tleV0pIHtcbiAgICBhbHJlYWR5V2FybmVkW2tleV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAgV2VicGFjayArIFJlYWN0IDE3IGZhaWxzIHRvIGNvbXBpbGUgb24gYW55IG9mIHRoZSBmb2xsb3dpbmcgYmVjYXVzZSB3ZWJwYWNrXG4gIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdFtcInN0YXJ0VHJhbnNpdGlvblwiXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG4gICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIGluIFJlYWN0IDE4IHdoZXJlIG1pbmlmaWNhdGlvbi9vYmZ1c2NhdGlvbiBlbmRzIHVwIHJlbW92aW5nIHRoZSBjYWxsIG9mXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvMTA1NzlcbiovXG5jb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbmNvbnN0IHN0YXJ0VHJhbnNpdGlvbkltcGwgPSBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXTtcblxuLyoqXG4gKiBHaXZlbiBhIFJlbWl4IFJvdXRlciBpbnN0YW5jZSwgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBVSVxuICovXG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgZmFsbGJhY2tFbGVtZW50LFxuICAgIHJvdXRlcixcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWY7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgaWYgKHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsKSB7XG4gICAgICBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICAgIH1cbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG5cbiAgLy8gTmVlZCB0byB1c2UgYSBsYXlvdXQgZWZmZWN0IGhlcmUgc28gd2UgYXJlIHN1YnNjcmliZWQgZWFybHkgZW5vdWdoIHRvXG4gIC8vIHBpY2sgdXAgb24gYW55IHJlbmRlci1kcml2ZW4gcmVkaXJlY3RzL25hdmlnYXRpb25zICh1c2VFZmZlY3QvPE5hdmlnYXRlPilcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbGxiYWNrRWxlbWVudCA9PSBudWxsIHx8ICFyb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgKyBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIikgOiB2b2lkIDA7XG4gICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXG4gICAgICBnbzogbiA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pLFxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KVxuICAgIH07XG4gIH0sIFtyb3V0ZXJdKTtcbiAgbGV0IGJhc2VuYW1lID0gcm91dGVyLmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcm91dGVyLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IGZhbHNlLFxuICAgIGJhc2VuYW1lXG4gIH0pLCBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXSk7XG5cbiAgLy8gVGhlIGZyYWdtZW50IGFuZCB7bnVsbH0gaGVyZSBhcmUgaW1wb3J0YW50ISAgV2UgbmVlZCB0aGVtIHRvIGtlZXAgUmVhY3QgMTgnc1xuICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAvLyBjb250YWluaW5nIHRoZSBoeWRyYXRlZCBzZXJ2ZXItc2lkZSBzdGF0aWNDb250ZXh0IChmcm9tIFN0YXRpY1JvdXRlclByb3ZpZGVyKS5cbiAgLy8gdXNlSWQgcmVsaWVzIG9uIHRoZSBjb21wb25lbnQgdHJlZSBzdHJ1Y3R1cmUgdG8gZ2VuZXJhdGUgZGV0ZXJtaW5pc3RpYyBpZCdzXG4gIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAvLyB3ZSBkb24ndCBuZWVkIHRoZSA8c2NyaXB0PiB0YWdcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0YXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IsXG4gICAgZnV0dXJlOiB7XG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogcm91dGVyLmZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxuICAgIH1cbiAgfSwgc3RhdGUuaW5pdGlhbGl6ZWQgfHwgcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pIDogZmFsbGJhY2tFbGVtZW50KSkpLCBudWxsKTtcbn1cbmZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICByb3V0ZXMsXG4gICAgZnV0dXJlLFxuICAgIHN0YXRlXG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlLCBmdXR1cmUpO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVyLWNvbXBvbmVudHMvbWVtb3J5LXJvdXRlclxuICovXG5mdW5jdGlvbiBNZW1vcnlSb3V0ZXIoX3JlZjMpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBpbml0aWFsRW50cmllcyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgZnV0dXJlXG4gIH0gPSBfcmVmMztcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgbGV0IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb25cbiAgfSA9IGZ1dHVyZSB8fCB7fTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsID8gc3RhcnRUcmFuc2l0aW9uSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKSA6IHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxuICAgIGZ1dHVyZTogZnV0dXJlXG4gIH0pO1xufVxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcbiAqIGB1c2VOYXZpZ2F0ZWAgaG9vayBpbnN0ZWFkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9uYXZpZ2F0ZVxuICovXG5mdW5jdGlvbiBOYXZpZ2F0ZShfcmVmNCkge1xuICBsZXQge1xuICAgIHRvLFxuICAgIHJlcGxhY2UsXG4gICAgc3RhdGUsXG4gICAgcmVsYXRpdmVcbiAgfSA9IF9yZWY0O1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcIjxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBmdXR1cmUsXG4gICAgc3RhdGljOiBpc1N0YXRpY1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKCFpc1N0YXRpYywgXCI8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIFwiICsgXCJUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgXCIgKyBcIm9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLlwiKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG5cbiAgLy8gUmVzb2x2ZSB0aGUgcGF0aCBvdXRzaWRlIG9mIHRoZSBlZmZlY3Qgc28gdGhhdCB3aGVuIGVmZmVjdHMgcnVuIHR3aWNlIGluXG4gIC8vIFN0cmljdE1vZGUgdGhleSBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBwbGFjZVxuICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcbiAgbGV0IGpzb25QYXRoID0gSlNPTi5zdHJpbmdpZnkocGF0aCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiBuYXZpZ2F0ZShKU09OLnBhcnNlKGpzb25QYXRoKSwge1xuICAgIHJlcGxhY2UsXG4gICAgc3RhdGUsXG4gICAgcmVsYXRpdmVcbiAgfSksIFtuYXZpZ2F0ZSwganNvblBhdGgsIHJlbGF0aXZlLCByZXBsYWNlLCBzdGF0ZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL291dGxldFxuICovXG5mdW5jdGlvbiBPdXRsZXQocHJvcHMpIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cbi8qKlxuICogRGVjbGFyZXMgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBhdCBhIGNlcnRhaW4gVVJMIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL3JvdXRlXG4gKi9cbmZ1bmN0aW9uIFJvdXRlKF9wcm9wcykge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgXCIgKyBcIm5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA7XG59XG4vKipcbiAqIFByb3ZpZGVzIGxvY2F0aW9uIGNvbnRleHQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcHAuXG4gKlxuICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgYDxSb3V0ZXI+YCBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIGA8QnJvd3NlclJvdXRlcj5gXG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSBgPFN0YXRpY1JvdXRlcj5gIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVyLWNvbXBvbmVudHMvcm91dGVyXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcihfcmVmNSkge1xuICBsZXQge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgICBjaGlsZHJlbiA9IG51bGwsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgICBuYXZpZ2F0aW9uVHlwZSA9IEFjdGlvbi5Qb3AsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlLFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjU7XG4gICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uXCIgKyBcIiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBQcmVzZXJ2ZSB0cmFpbGluZyBzbGFzaGVzIG9uIGJhc2VuYW1lLCBzbyB3ZSBjYW4gbGV0IHRoZSB1c2VyIGNvbnRyb2xcbiAgLy8gdGhlIGVuZm9yY2VtZW50IG9mIHRyYWlsaW5nIHNsYXNoZXMgdGhyb3VnaG91dCB0aGUgYXBwXG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7XG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2VcbiAgICB9LCBmdXR1cmUpXG4gIH0pLCBbYmFzZW5hbWUsIGZ1dHVyZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiXG4gIH0gPSBsb2NhdGlvblByb3A7XG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uVHlwZVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobG9jYXRpb25Db250ZXh0ICE9IG51bGwsIFwiPFJvdXRlciBiYXNlbmFtZT1cXFwiXCIgKyBiYXNlbmFtZSArIFwiXFxcIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiArIChcIlxcXCJcIiArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCArIFwiXFxcIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIFwiKSArIFwiYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuXCIpIDogdm9pZCAwO1xuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHZhbHVlOiBsb2NhdGlvbkNvbnRleHRcbiAgfSkpO1xufVxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiBgPFJvdXRlPmAgZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gUm91dGVzKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbG9jYXRpb25cbiAgfSA9IF9yZWY2O1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXG4gKiBpbiBhIGxvYWRlciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBBd2FpdChfcmVmNykge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGVycm9yRWxlbWVudCxcbiAgICByZXNvbHZlXG4gIH0gPSBfcmVmNztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwge1xuICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgZXJyb3JFbGVtZW50OiBlcnJvckVsZW1lbnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzb2x2ZUF3YWl0LCBudWxsLCBjaGlsZHJlbikpO1xufVxudmFyIEF3YWl0UmVuZGVyU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChBd2FpdFJlbmRlclN0YXR1cykge1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInBlbmRpbmdcIl0gPSAwXSA9IFwicGVuZGluZ1wiO1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInN1Y2Nlc3NcIl0gPSAxXSA9IFwic3VjY2Vzc1wiO1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcImVycm9yXCJdID0gMl0gPSBcImVycm9yXCI7XG4gIHJldHVybiBBd2FpdFJlbmRlclN0YXR1cztcbn0oQXdhaXRSZW5kZXJTdGF0dXMgfHwge30pO1xuY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbmNsYXNzIEF3YWl0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGVycm9yRWxlbWVudCxcbiAgICAgIHJlc29sdmVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgLy8gQ2F1Z2h0IGEgcmVuZGVyIGVycm9yLCBwcm92aWRlIGl0IGFzIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3I7XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge30pOyAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcm5pbmdzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmUuX3RyYWNrZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID0gcHJvbWlzZS5fZXJyb3IgIT09IHVuZGVmaW5lZCA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yIDogcHJvbWlzZS5fZGF0YSAhPT0gdW5kZWZpbmVkID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcyA6IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKGRhdGEgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICAgIH0pLCBlcnJvciA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmIHByb21pc2UuX2Vycm9yIGluc3RhbmNlb2YgQWJvcnRlZERlZmVycmVkRXJyb3IpIHtcbiAgICAgIC8vIEZyZWV6ZSB0aGUgVUkgYnkgdGhyb3dpbmcgYSBuZXZlciByZXNvbHZlZCBwcm9taXNlXG4gICAgICB0aHJvdyBuZXZlclNldHRsZWRQcm9taXNlO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgIC8vIFJlbmRlciB2aWEgb3VyIGVycm9yRWxlbWVudFxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvbWlzZSxcbiAgICAgICAgY2hpbGRyZW46IGVycm9yRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRocm93IHRvIHRoZSBzdXNwZW5zZSBib3VuZGFyeVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW5kaXJlY3Rpb24gdG8gbGV2ZXJhZ2UgdXNlQXN5bmNWYWx1ZSBmb3IgYSByZW5kZXItcHJvcCBBUEkgb24gYDxBd2FpdD5gXG4gKi9cbmZ1bmN0aW9uIFJlc29sdmVBd2FpdChfcmVmOCkge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmODtcbiAgbGV0IGRhdGEgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YSkgOiBjaGlsZHJlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2NyZWF0ZS1yb3V0ZXMtZnJvbS1jaGlsZHJlblxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGgpIHtcbiAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhcmVudFBhdGggPSBbXTtcbiAgfVxuICBsZXQgcm91dGVzID0gW107XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhKGVsZW1lbnQudHlwZSA9PT0gUm91dGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJbXCIgKyAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lKSArIFwiXSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISghZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsZXQgcm91dGUgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpO1xuICAgIH1cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbmZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICBsZXQgdXBkYXRlcyA9IHtcbiAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IHJvdXRlLmVycm9yRWxlbWVudCAhPSBudWxsXG4gIH07XG4gIGlmIChyb3V0ZS5Db21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYENvbXBvbmVudGAgYW5kIGBlbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgIENvbXBvbmVudDogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkh5ZHJhdGVGYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgSHlkcmF0ZUZhbGxiYWNrYCBhbmQgYGh5ZHJhdGVGYWxsYmFja0VsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYEh5ZHJhdGVGYWxsYmFja2Agd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5IeWRyYXRlRmFsbGJhY2spLFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5lcnJvckVsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlcnJvckVsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkVycm9yQm91bmRhcnkpLFxuICAgICAgRXJyb3JCb3VuZGFyeTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxJbmRleFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cblxuZXhwb3J0IHsgQXdhaXQsIE1lbW9yeVJvdXRlciwgTmF2aWdhdGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVyUHJvdmlkZXIsIFJvdXRlcywgRGF0YVJvdXRlckNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LCBEYXRhUm91dGVyU3RhdGVDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBMb2NhdGlvbkNvbnRleHQgYXMgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgTmF2aWdhdGlvbkNvbnRleHQgYXMgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBSb3V0ZUNvbnRleHQgYXMgVU5TQUZFX1JvdXRlQ29udGV4dCwgbWFwUm91dGVQcm9wZXJ0aWVzIGFzIFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsIHVzZVJvdXRlSWQgYXMgVU5TQUZFX3VzZVJvdXRlSWQsIHVzZVJvdXRlc0ltcGwgYXMgVU5TQUZFX3VzZVJvdXRlc0ltcGwsIGNyZWF0ZU1lbW9yeVJvdXRlciwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gYXMgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLCByZW5kZXJNYXRjaGVzLCB1c2VBY3Rpb25EYXRhLCB1c2VBc3luY0Vycm9yLCB1c2VBc3luY1ZhbHVlLCB1c2VCbG9ja2VyLCB1c2VIcmVmLCB1c2VJblJvdXRlckNvbnRleHQsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGUsIHVzZU5hdmlnYXRpb24sIHVzZU5hdmlnYXRpb25UeXBlLCB1c2VPdXRsZXQsIHVzZU91dGxldENvbnRleHQsIHVzZVBhcmFtcywgdXNlUmVzb2x2ZWRQYXRoLCB1c2VSZXZhbGlkYXRvciwgdXNlUm91dGVFcnJvciwgdXNlUm91dGVMb2FkZXJEYXRhLCB1c2VSb3V0ZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiVU5TQUZFX2ludmFyaWFudCIsImpvaW5QYXRocyIsIm1hdGNoUGF0aCIsIlVOU0FGRV9nZXRSZXNvbHZlVG9NYXRjaGVzIiwiVU5TQUZFX3dhcm5pbmciLCJyZXNvbHZlVG8iLCJwYXJzZVBhdGgiLCJtYXRjaFJvdXRlcyIsIkFjdGlvbiIsIlVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCIsInN0cmlwQmFzZW5hbWUiLCJJRExFX0JMT0NLRVIiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsImNyZWF0ZVJvdXRlciIsIk5hdmlnYXRpb25UeXBlIiwiY3JlYXRlUGF0aCIsImRlZmVyIiwiZ2VuZXJhdGVQYXRoIiwianNvbiIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlc29sdmVQYXRoIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiRGF0YVJvdXRlckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIiwiRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIkF3YWl0Q29udGV4dCIsIk5hdmlnYXRpb25Db250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiUm91dGVDb250ZXh0Iiwib3V0bGV0IiwibWF0Y2hlcyIsImlzRGF0YVJvdXRlIiwiUm91dGVFcnJvckNvbnRleHQiLCJ1c2VIcmVmIiwidG8iLCJfdGVtcCIsInJlbGF0aXZlIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwiYmFzZW5hbWUiLCJuYXZpZ2F0b3IiLCJ1c2VDb250ZXh0IiwiaGFzaCIsInBhdGhuYW1lIiwic2VhcmNoIiwidXNlUmVzb2x2ZWRQYXRoIiwiam9pbmVkUGF0aG5hbWUiLCJjcmVhdGVIcmVmIiwidXNlTG9jYXRpb24iLCJsb2NhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwibmF2aWdhdGlvblR5cGUiLCJ1c2VNYXRjaCIsInBhdHRlcm4iLCJ1c2VNZW1vIiwibmF2aWdhdGVFZmZlY3RXYXJuaW5nIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImNiIiwiaXNTdGF0aWMiLCJzdGF0aWMiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VOYXZpZ2F0ZSIsInVzZU5hdmlnYXRlU3RhYmxlIiwidXNlTmF2aWdhdGVVbnN0YWJsZSIsImRhdGFSb3V0ZXJDb250ZXh0IiwiZnV0dXJlIiwibG9jYXRpb25QYXRobmFtZSIsInJvdXRlUGF0aG5hbWVzSnNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2N19yZWxhdGl2ZVNwbGF0UGF0aCIsImFjdGl2ZVJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJuYXZpZ2F0ZSIsInVzZUNhbGxiYWNrIiwib3B0aW9ucyIsImdvIiwicGF0aCIsInBhcnNlIiwicmVwbGFjZSIsInB1c2giLCJzdGF0ZSIsIk91dGxldENvbnRleHQiLCJ1c2VPdXRsZXRDb250ZXh0IiwidXNlT3V0bGV0IiwiY29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwidXNlUGFyYW1zIiwicm91dGVNYXRjaCIsInBhcmFtcyIsIl90ZW1wMiIsInVzZVJvdXRlcyIsInJvdXRlcyIsImxvY2F0aW9uQXJnIiwidXNlUm91dGVzSW1wbCIsImRhdGFSb3V0ZXJTdGF0ZSIsInBhcmVudE1hdGNoZXMiLCJwYXJlbnRQYXJhbXMiLCJwYXJlbnRQYXRobmFtZSIsInBhcmVudFBhdGhuYW1lQmFzZSIsInBhdGhuYW1lQmFzZSIsInBhcmVudFJvdXRlIiwicm91dGUiLCJwYXJlbnRQYXRoIiwid2FybmluZ09uY2UiLCJlbmRzV2l0aCIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJfcGFyc2VkTG9jYXRpb25BcmckcGEiLCJwYXJzZWRMb2NhdGlvbkFyZyIsInN0YXJ0c1dpdGgiLCJyZW1haW5pbmdQYXRobmFtZSIsInBhcmVudFNlZ21lbnRzIiwic3BsaXQiLCJzZWdtZW50cyIsInNsaWNlIiwiam9pbiIsImVsZW1lbnQiLCJ1bmRlZmluZWQiLCJDb21wb25lbnQiLCJsYXp5IiwicmVuZGVyZWRNYXRjaGVzIiwiX3JlbmRlck1hdGNoZXMiLCJtYXAiLCJtYXRjaCIsImVuY29kZUxvY2F0aW9uIiwiUG9wIiwiRGVmYXVsdEVycm9yQ29tcG9uZW50IiwiZXJyb3IiLCJ1c2VSb3V0ZUVycm9yIiwibWVzc2FnZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJFcnJvciIsInN0YWNrIiwibGlnaHRncmV5IiwicHJlU3R5bGVzIiwicGFkZGluZyIsImJhY2tncm91bmRDb2xvciIsImNvZGVTdHlsZXMiLCJkZXZJbmZvIiwiY29uc29sZSIsIkZyYWdtZW50Iiwic3R5bGUiLCJmb250U3R5bGUiLCJkZWZhdWx0RXJyb3JFbGVtZW50IiwiUmVuZGVyRXJyb3JCb3VuZGFyeSIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJyZXZhbGlkYXRpb24iLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnREaWRDYXRjaCIsImVycm9ySW5mbyIsInJlbmRlciIsInJvdXRlQ29udGV4dCIsImNoaWxkcmVuIiwiY29tcG9uZW50IiwiUmVuZGVyZWRSb3V0ZSIsIl9yZWYiLCJzdGF0aWNDb250ZXh0IiwiZXJyb3JFbGVtZW50IiwiRXJyb3JCb3VuZGFyeSIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwiaWQiLCJfZGF0YVJvdXRlclN0YXRlMiIsIl9kYXRhUm91dGVyU3RhdGUiLCJlcnJvcnMiLCJlcnJvckluZGV4IiwiZmluZEluZGV4IiwibSIsImtleXMiLCJNYXRoIiwibWluIiwicmVuZGVyRmFsbGJhY2siLCJmYWxsYmFja0luZGV4IiwidjdfcGFydGlhbEh5ZHJhdGlvbiIsIkh5ZHJhdGVGYWxsYmFjayIsImh5ZHJhdGVGYWxsYmFja0VsZW1lbnQiLCJsb2FkZXJEYXRhIiwibmVlZHNUb1J1bkxvYWRlciIsImxvYWRlciIsInJlZHVjZVJpZ2h0IiwiaW5kZXgiLCJzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2siLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwidXNlUm91dGVDb250ZXh0IiwidXNlQ3VycmVudFJvdXRlSWQiLCJ0aGlzUm91dGUiLCJ1c2VSb3V0ZUlkIiwiVXNlUm91dGVJZCIsInVzZU5hdmlnYXRpb24iLCJVc2VOYXZpZ2F0aW9uIiwibmF2aWdhdGlvbiIsInVzZVJldmFsaWRhdG9yIiwiVXNlUmV2YWxpZGF0b3IiLCJyZXZhbGlkYXRlIiwicm91dGVyIiwidXNlTWF0Y2hlcyIsIlVzZU1hdGNoZXMiLCJ1c2VMb2FkZXJEYXRhIiwiVXNlTG9hZGVyRGF0YSIsInJvdXRlSWQiLCJ1c2VSb3V0ZUxvYWRlckRhdGEiLCJVc2VSb3V0ZUxvYWRlckRhdGEiLCJ1c2VBY3Rpb25EYXRhIiwiVXNlQWN0aW9uRGF0YSIsImFjdGlvbkRhdGEiLCJfc3RhdGUkZXJyb3JzIiwiVXNlUm91dGVFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJfZGF0YSIsInVzZUFzeW5jRXJyb3IiLCJfZXJyb3IiLCJibG9ja2VySWQiLCJ1c2VCbG9ja2VyIiwic2hvdWxkQmxvY2siLCJVc2VCbG9ja2VyIiwiYmxvY2tlcktleSIsInNldEJsb2NrZXJLZXkiLCJ1c2VTdGF0ZSIsImJsb2NrZXJGdW5jdGlvbiIsImFyZyIsImN1cnJlbnRMb2NhdGlvbiIsIm5leHRMb2NhdGlvbiIsImhpc3RvcnlBY3Rpb24iLCJ1c2VFZmZlY3QiLCJTdHJpbmciLCJkZWxldGVCbG9ja2VyIiwiZ2V0QmxvY2tlciIsImJsb2NrZXJzIiwiaGFzIiwiZ2V0IiwiVXNlTmF2aWdhdGVTdGFibGUiLCJmcm9tUm91dGVJZCIsImFscmVhZHlXYXJuZWQiLCJjb25kIiwiU1RBUlRfVFJBTlNJVElPTiIsInN0YXJ0VHJhbnNpdGlvbkltcGwiLCJSb3V0ZXJQcm92aWRlciIsImZhbGxiYWNrRWxlbWVudCIsInNldFN0YXRlSW1wbCIsInY3X3N0YXJ0VHJhbnNpdGlvbiIsInNldFN0YXRlIiwibmV3U3RhdGUiLCJzdWJzY3JpYmUiLCJuIiwib3B0cyIsInByZXZlbnRTY3JvbGxSZXNldCIsIlJvdXRlciIsImluaXRpYWxpemVkIiwiRGF0YVJvdXRlcyIsIl9yZWYyIiwiTWVtb3J5Um91dGVyIiwiX3JlZjMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsImhpc3RvcnlSZWYiLCJ2NUNvbXBhdCIsImhpc3RvcnkiLCJhY3Rpb24iLCJsaXN0ZW4iLCJOYXZpZ2F0ZSIsIl9yZWY0IiwianNvblBhdGgiLCJPdXRsZXQiLCJSb3V0ZSIsIl9wcm9wcyIsIl9yZWY1IiwiYmFzZW5hbWVQcm9wIiwibG9jYXRpb25Qcm9wIiwic3RhdGljUHJvcCIsIm5hdmlnYXRpb25Db250ZXh0IiwibG9jYXRpb25Db250ZXh0IiwidHJhaWxpbmdQYXRobmFtZSIsIlJvdXRlcyIsIl9yZWY2IiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiQXdhaXQiLCJfcmVmNyIsInJlc29sdmUiLCJBd2FpdEVycm9yQm91bmRhcnkiLCJSZXNvbHZlQXdhaXQiLCJBd2FpdFJlbmRlclN0YXR1cyIsIm5ldmVyU2V0dGxlZFByb21pc2UiLCJQcm9taXNlIiwicHJvbWlzZSIsInBlbmRpbmciLCJzdWNjZXNzIiwiZGVmaW5lUHJvcGVydHkiLCJyZW5kZXJFcnJvciIsInJlamVjdCIsImNhdGNoIiwiX3RyYWNrZWQiLCJ0aGVuIiwiZGF0YSIsIl9yZWY4IiwidG9SZW5kZXIiLCJDaGlsZHJlbiIsImZvckVhY2giLCJpc1ZhbGlkRWxlbWVudCIsInRyZWVQYXRoIiwidHlwZSIsIm5hbWUiLCJjYXNlU2Vuc2l0aXZlIiwiaGFzRXJyb3JCb3VuZGFyeSIsInNob3VsZFJldmFsaWRhdGUiLCJoYW5kbGUiLCJyZW5kZXJNYXRjaGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwidXBkYXRlcyIsImNyZWF0ZU1lbW9yeVJvdXRlciIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsaXplIiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJVTlNBRkVfTG9jYXRpb25Db250ZXh0IiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfdXNlUm91dGVJZCIsIlVOU0FGRV91c2VSb3V0ZXNJbXBsIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/react-router/dist/index.js\n");

/***/ })

};
;